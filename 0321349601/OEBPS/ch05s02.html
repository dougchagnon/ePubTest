<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Concurrent Collections</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Concurrent Collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lev1sec2"/>Concurrent Collections</h2></div></div></div>

<p>Java 5.0 improves on the synchronized collections by providing several <span class="emphasis"><em>concurrent</em></span> collection classes. Synchronized collections achieve their thread safety by serializing all access to the collection’s state. The cost of this approach is poor concurrency; when multiple threads contend for the collection-wide lock, throughput suffers.</p>
<p>The concurrent collections, on the other hand, are designed for concurrent access from multiple threads. Java 5.0 adds <code class="literal">ConcurrentHashMap</code>, a replacement for synchronized hash-based <code class="literal">Map</code> implementations, and <code class="literal">CopyOnWriteArrayList</code>, a replacement for synchronized <code class="literal">List</code> implementations for cases where traversal is the dominant operation. The new <code class="literal">ConcurrentMap</code> interface adds support for common compound actions such as put-if-absent, replace, and conditional remove.</p>
<div class="sidebar"><a id="ch05sb02"/><p class="title"><b/></p>
<p>Replacing synchronized collections with concurrent collections can offer dramatic scalability improvements with little risk.</p>
</div>
<p>Java 5.0 also adds two new collection types, <code class="literal">Queue</code> and <code class="literal">BlockingQueue</code>. A <code class="literal">Queue</code> is intended to hold a set of elements temporarily while they await processing. Several implementations are provided, including <code class="literal">ConcurrentLinkedQueue</code>, a <a id="iddle1461" class="indexterm"/><a id="iddle1490" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1493" class="indexterm"/><a id="iddle1494" class="indexterm"/><a id="iddle1558" class="indexterm"/><a id="iddle1937" class="indexterm"/><a id="iddle2879" class="indexterm"/><a id="iddle2880" class="indexterm"/><a id="iddle2887" class="indexterm"/><a id="iddle2990" class="indexterm"/><a id="iddle3005" class="indexterm"/><a id="iddle3044" class="indexterm"/><a id="iddle3045" class="indexterm"/><a id="iddle3046" class="indexterm"/><a id="iddle3047" class="indexterm"/><a id="iddle3048" class="indexterm"/><a id="iddle3075" class="indexterm"/><a id="iddle3116" class="indexterm"/><a id="iddle3117" class="indexterm"/><a id="iddle3144" class="indexterm"/><a id="iddle3153" class="indexterm"/><a id="iddle3552" class="indexterm"/><a id="iddle3665" class="indexterm"/><a id="iddle4062" class="indexterm"/><a id="iddle4134" class="indexterm"/><a id="iddle4218" class="indexterm"/><a id="iddle4219" class="indexterm"/><a id="iddle4220" class="indexterm"/><a id="iddle4221" class="indexterm"/><a id="iddle4331" class="indexterm"/><a id="iddle4332" class="indexterm"/><a id="iddle4333" class="indexterm"/><a id="iddle4334" class="indexterm"/><a id="iddle4474" class="indexterm"/><a id="iddle4475" class="indexterm"/><a id="iddle4502" class="indexterm"/><a id="iddle4969" class="indexterm"/><a id="iddle4970" class="indexterm"/><a id="iddle4971" class="indexterm"/><a id="iddle4972" class="indexterm"/><a id="iddle5152" class="indexterm"/>traditional FIFO queue, and <code class="literal">PriorityQueue</code>, a (non concurrent) priority ordered queue. <code class="literal">Queue</code> operations do not block; if the queue is empty, the retrieval operation returns <code class="literal">null</code>. While you can simulate the behavior of a <code class="literal">Queue</code> with a <code class="literal">List</code>—in fact, <code class="literal">LinkedList</code> also implements <code class="literal">Queue</code>—the <code class="literal">Queue</code> classes were added because eliminating the random-access requirements of <code class="literal">List</code> admits more efficient concurrent implementations.</p>
<p><code class="literal">BlockingQueue</code> extends <code class="literal">Queue</code> to add blocking insertion and retrieval operations. If the queue is empty, a retrieval blocks until an element is available, and if the queue is full (for bounded queues) an insertion blocks until there is space available. Blocking queues are extremely useful in producer-consumer designs, and are covered in greater detail in <a class="link" href="ch05s03.html" title="Blocking Queues and the Producer-consumer Pattern">Section 5.3</a>.</p>
<p>Just as <code class="literal">ConcurrentHashMap</code> is a concurrent replacement for a synchronized hash-based <code class="literal">Map</code>, Java 6 adds <code class="literal">ConcurrentSkipListMap</code> and <code class="literal">ConcurrentSkipListSet</code>, which are concurrent replacements for a synchronized <code class="literal">SortedMap</code> or <code class="literal">SortedSet</code> (such as <code class="literal">TreeMap</code> or <code class="literal">TreeSet</code> wrapped with <code class="literal">synchronizedMap</code>).</p>
<div class="section" title="ConcurrentHashMap"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lev2sec4"/>ConcurrentHashMap</h3></div></div></div>

<p>The synchronized collections classes hold a lock for the duration of each operation. Some operations, such as <code class="literal">HashMap.get</code> or <code class="literal">List.contains</code>, may involve more work than is initially obvious: traversing a hash bucket or list to find a specific object entails calling <code class="literal">equals</code> (which itself may involve a fair amount of computation) on a number of candidate objects. In a hash-based collection, if <code class="literal">hashCode</code> does not spread out hash values well, elements may be unevenly distributed among buckets; in the degenerate case, a poor hash function will turn a hash table into a linked list. Traversing a long list and calling <code class="literal">equals</code> on some or all of the elements can take a long time, and during that time no other thread can access the collection.</p>
<p><code class="literal">ConcurrentHashMap</code> is a hash-based <code class="literal">Map</code> like <code class="literal">HashMap</code>, but it uses an entirely different locking strategy that offers better concurrency and scalability. Instead of synchronizing every method on a common lock, restricting access to a single thread at a time, it uses a finer-grained locking mechanism called <span class="emphasis"><em>lock striping</em></span> (see <a class="link" href="ch11s04.html#ch11lev2sec10" title="Lock Striping">Section 11.4.3</a>) to allow a greater degree of shared access. Arbitrarily many reading threads can access the map concurrently, readers can access the map concurrently with writers, and a limited number of writers can modify the map concurrently. The result is far higher throughput under concurrent access, with little performance penalty for single-threaded access.</p>
<p><code class="literal">ConcurrentHashMap</code>, along with the other concurrent collections, further improve on the synchronized collection classes by providing iterators that do not throw <code class="literal">ConcurrentModificationException</code>, thus eliminating the need to lock the collection during iteration. The iterators returned by <code class="literal">ConcurrentHashMap</code> are <span class="emphasis"><em>weakly consistent</em></span> instead of fail-fast. A weakly consistent iterator can tolerate concurrent modification, traverses elements as they existed when the iterator was constructed, and may (but is not guaranteed to) reflect modifications to the collection after the construction of the iterator.</p>
<p>As with all improvements, there are still a few tradeoffs. The semantics of methods that operate on the entire <code class="literal">Map</code>, such as <code class="literal">size</code> and <code class="literal">isEmpty</code>, have been <a id="iddle1020" class="indexterm"/><a id="iddle1021" class="indexterm"/><a id="iddle1163" class="indexterm"/><a id="iddle1665" class="indexterm"/><a id="iddle1671" class="indexterm"/><a id="iddle1724" class="indexterm"/><a id="iddle1725" class="indexterm"/><a id="iddle2995" class="indexterm"/><a id="iddle3008" class="indexterm"/><a id="iddle3097" class="indexterm"/><a id="iddle3181" class="indexterm"/><a id="iddle3845" class="indexterm"/><a id="iddle3846" class="indexterm"/><a id="iddle3858" class="indexterm"/><a id="iddle3859" class="indexterm"/><a id="iddle4214" class="indexterm"/><a id="iddle4215" class="indexterm"/><a id="iddle4276" class="indexterm"/><a id="iddle4277" class="indexterm"/><a id="iddle4928" class="indexterm"/>slightly weakened to reflect the concurrent nature of the collection. Since the result of <code class="literal">size</code> could be out of date by the time it is computed, it is really only an estimate, so <code class="literal">size</code> is allowed to return an approximation instead of an exact count. While at first this may seem disturbing, in reality methods like <code class="literal">size</code> and <code class="literal">isEmpty</code> are far less useful in concurrent environments because these quantities are moving targets. So the requirements for these operations were weakened to enable performance optimizations for the most important operations, primarily <code class="literal">get</code>, <code class="literal">put</code>, <code class="literal">containsKey</code>, and <code class="literal">remove</code>.</p>
<p>The one feature offered by the synchronized <code class="literal">Map</code> implementations but not by <code class="literal">ConcurrentHashMap</code> is the ability to lock the map for exclusive access. With <code class="literal">Hashtable</code> and <code class="literal">synchronizedMap</code>, acquiring the <code class="literal">Map</code> lock prevents any other thread from accessing it. This might be necessary in unusual cases such as adding several mappings atomically, or iterating the <code class="literal">Map</code> several times and needing to see the same elements in the same order. On the whole, though, this is a reasonable tradeoff: concurrent collections should be expected to change their contents continuously.</p>
<p>Because it has so many advantages and so few disadvantages compared to <code class="literal">Hashtable</code> or <code class="literal">synchronizedMap</code>, replacing synchronized <code class="literal">Map</code> implementations with <code class="literal">ConcurrentHashMap</code> in most cases results only in better scalability. Only if your application needs to lock the map for exclusive access <sup>[<a id="ch05fn03" href="#ftn.ch05fn03" class="footnote">3</a>]</sup> is <code class="literal">ConcurrentHashMap</code> not an appropriate drop-in replacement.</p>
</div>
<div class="section" title="Additional Atomic Map Operations"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lev2sec5"/>Additional Atomic Map Operations</h3></div></div></div>

<p>Since a <code class="literal">ConcurrentHashMap</code> cannot be locked for exclusive access, we cannot use client-side locking to create new atomic operations such as put-if-absent, as we did for <code class="literal">Vector</code> in <a class="link" href="ch04s04.html#ch04lev2sec11" title="Client-side Locking">Section 4.4.1</a>. Instead, a number of common compound operations such as put-if-absent, remove-if-equal, and replace-if-equal are implemented as atomic operations and specified by the <code class="literal">ConcurrentMap</code> interface, shown in <a class="link" href="ch05s02.html#ch05list07" title="Example 5.7. ConcurrentMap Interface.">Listing 5.7</a>. If you find yourself adding such functionality to an existing synchronized <code class="literal">Map</code> implementation, it is probably a sign that you should consider using a <code class="literal">ConcurrentMap</code> instead.</p>
</div>
<div class="section" title="CopyOnWriteArrayList"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lev2sec6"/>CopyOnWriteArrayList</h3></div></div></div>

<p><code class="literal">CopyOnWriteArrayList</code> is a concurrent replacement for a synchronized <code class="literal">List</code> that offers better concurrency in some common situations and eliminates the need to lock or copy the collection during iteration. (Similarly, <code class="literal">CopyOnWriteArraySet</code> is a concurrent replacement for a synchronized <code class="literal">Set</code>.)</p>
<p>The copy-on-write collections derive their thread safety from the fact that as long as an effectively immutable object is properly published, no further synchronization is required when accessing it. They implement mutability by creating and republishing a new copy of the collection every time it is modified. Iterators for the copy-on-write collections retain a reference to the backing array that was current at the start of iteration, and since this will never change, they need to <a id="iddle1221" class="indexterm"/><a id="iddle1226" class="indexterm"/><a id="iddle1439" class="indexterm"/><a id="iddle1488" class="indexterm"/><a id="iddle1579" class="indexterm"/><a id="iddle1580" class="indexterm"/><a id="iddle1844" class="indexterm"/><a id="iddle1845" class="indexterm"/><a id="iddle1846" class="indexterm"/><a id="iddle1869" class="indexterm"/><a id="iddle1870" class="indexterm"/><a id="iddle1938" class="indexterm"/><a id="iddle2006" class="indexterm"/><a id="iddle2007" class="indexterm"/><a id="iddle2070" class="indexterm"/><a id="iddle2071" class="indexterm"/><a id="iddle3242" class="indexterm"/><a id="iddle3243" class="indexterm"/><a id="iddle3326" class="indexterm"/><a id="iddle3327" class="indexterm"/><a id="iddle3681" class="indexterm"/><a id="iddle3750" class="indexterm"/><a id="iddle3754" class="indexterm"/><a id="iddle4993" class="indexterm"/><a id="iddle4994" class="indexterm"/>synchronize only briefly to ensure visibility of the array contents. As a result, multiple threads can iterate the collection without interference from one another or from threads wanting to modify the collection. The iterators returned by the copy-on-write collections do not throw <code class="literal">ConcurrentModificationException</code> and return the elements exactly as they were at the time the iterator was created, regardless of subsequent modifications.</p>
<div class="example"><a id="ch05list07"/><p class="title"><b>Example 5.7. <code class="literal">ConcurrentMap</code> Interface.</b></p><div class="example-contents">

<pre class="programlisting">public interface ConcurrentMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
    <span class="emphasis"><em>// Insert into map only if no value is mapped from K</em></span>
    V putIfAbsent(K key, V value);

    <span class="emphasis"><em>// Remove only if K is mapped to V</em></span>
    boolean remove(K key, V value);

    <span class="emphasis"><em>// Replace value only if K is mapped to oldValue</em></span>
    boolean replace(K key, V oldValue, V newValue);

    <span class="emphasis"><em>// Replace value only if K is mapped to some value</em></span>
    V replace(K key, V newValue);
}
</pre>
</div></div><br class="example-break"/>
<p>Obviously, there is some cost to copying the backing array every time the collection is modified, especially if the collection is large; the copy-on-write collections are reasonable to use only when iteration is far more common than modification. This criterion exactly describes many event-notification systems: delivering a notification requires iterating the list of registered listeners and calling each one of them, and in most cases registering or unregistering an event listener is far less common than receiving an event notification. (See [CPJ 2.4.4] for more information on copy-on-write.)</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch05fn03" href="#ch05fn03" class="para">3</a>] </sup>Or if you are relying on the synchronization side effects of the synchronized <code class="literal">Map</code> implementations.</p></div></div></div></body></html>
