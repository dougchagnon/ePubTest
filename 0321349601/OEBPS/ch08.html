<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 8. Applying Thread Pools</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="chapter" title="Chapter 8. Applying Thread Pools"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Applying Thread Pools</h1></div></div></div>




<p><a id="iddle1540" class="indexterm"/><a id="iddle1707" class="indexterm"/><a id="iddle1708" class="indexterm"/><a id="iddle1881" class="indexterm"/><a id="iddle1882" class="indexterm"/><a id="iddle1905" class="indexterm"/><a id="iddle1906" class="indexterm"/><a id="iddle2243" class="indexterm"/><a id="iddle2244" class="indexterm"/><a id="iddle2245" class="indexterm"/><a id="iddle2247" class="indexterm"/><a id="iddle2260" class="indexterm"/><a id="iddle2717" class="indexterm"/><a id="iddle3577" class="indexterm"/><a id="iddle3578" class="indexterm"/><a id="iddle3580" class="indexterm"/><a id="iddle3621" class="indexterm"/><a id="iddle4615" class="indexterm"/><a id="iddle4616" class="indexterm"/><a id="iddle4621" class="indexterm"/><a id="iddle4752" class="indexterm"/><a id="iddle4795" class="indexterm"/><a class="link" href="ch06.html" title="Chapter 6. Task Execution">Chapter 6</a> introduced the task execution framework, which simplifies management of task and thread lifecycles and provides a simple and flexible means for decoupling task submission from execution policy. <a class="link" href="ch07.html" title="Chapter 7. Cancellation and Shutdown">Chapter 7</a> covered some of the messy details of service lifecycle that arise from using the task execution framework in real applications. This chapter looks at advanced options for configuring and tuning thread pools, describes hazards to watch for when using the task execution framework, and offers some more advanced examples of using <code class="literal">Executor</code>.</p>



<div class="section" title="Implicit Couplings Between Tasks and Execution Policies"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lev1sec1"/>Implicit Couplings Between Tasks and Execution Policies</h2></div></div></div>

<p>We claimed earlier that the <code class="literal">Executor</code> framework decouples task submission from task execution. Like many attempts at decoupling complex processes, this was a bit of an overstatement. While the <code class="literal">Executor</code> framework offers substantial flexibility in specifying and modifying execution policies, not all tasks are compatible with all execution policies. Types of tasks that require specific execution policies include:</p>
<p title="Dependent tasks."><b><span class="strong"><strong>Dependent tasks.</strong></span> </b>The most well behaved tasks are <span class="emphasis"><em>independent</em></span>: those that do not depend on the timing, results, or side effects of other tasks. When executing independent tasks in a thread pool, you can freely vary the pool size and configuration without affecting anything but performance. On the other hand, when you submit tasks that depend on other tasks to a thread pool, you implicitly create constraints on the execution policy that must be carefully managed to avoid liveness problems (see <a class="link" href="ch08.html#ch08lev2sec1" title="Thread Starvation Deadlock">Section 8.1.1</a>).</p>
<p title="Tasks that exploit thread confinement."><b><span class="strong"><strong>Tasks that exploit thread confinement.</strong></span> </b>Single-threaded executors make stronger promises about concurrency than do arbitrary thread pools. They guarantee that tasks are not executed concurrently, which allows you to relax the thread safety of task code. Objects can be confined to the task thread, thus enabling tasks designed to run in that thread to access those objects without synchronization, even if those resources are not thread-safe. This forms an implicit coupling between the task and the execution policy—the tasks require <a id="iddle1818" class="indexterm"/><a id="iddle1883" class="indexterm"/><a id="iddle1963" class="indexterm"/><a id="iddle1964" class="indexterm"/><a id="iddle2493" class="indexterm"/><a id="iddle2494" class="indexterm"/><a id="iddle2526" class="indexterm"/><a id="iddle3942" class="indexterm"/><a id="iddle3943" class="indexterm"/><a id="iddle4375" class="indexterm"/><a id="iddle4608" class="indexterm"/><a id="iddle4617" class="indexterm"/><a id="iddle4648" class="indexterm"/><a id="iddle4649" class="indexterm"/><a id="iddle4824" class="indexterm"/><a id="iddle4850" class="indexterm"/><a id="iddle4922" class="indexterm"/><a id="iddle4923" class="indexterm"/>their executor to be single-threaded.<sup>[<a id="ch08fn01" href="#ftn.ch08fn01" class="footnote">1</a>]</sup> In this case, if you changed the <code class="literal">Executor</code> from a single-threaded one to a thread pool, thread safety could be lost.</p>
<p title="Response-time-sensitive tasks."><b><span class="strong"><strong>Response-time-sensitive tasks.</strong></span> </b>GUI applications are sensitive to response time: users are annoyed at long delays between a button click and the corresponding visual feedback. Submitting a long-running task to a single-threaded executor, or submitting several long-running tasks to a thread pool with a small number of threads, may impair the responsiveness of the service managed by that <code class="literal">Executor</code>.</p>
<p title="Tasks that use ThreadLocal."><b><span class="strong"><strong>Tasks that use <code class="literal">ThreadLocal</code>.</strong></span> </b><code class="literal">ThreadLocal</code> allows each thread to have its own private “version” of a variable. However, executors are free to reuse threads as they see fit. The standard <code class="literal">Executor</code> implementations may reap idle threads when demand is low and add new ones when demand is high, and also replace a worker thread with a fresh one if an unchecked exception is thrown from a task. <code class="literal">ThreadLocal</code> makes sense to use in pool threads only if the thread-local value has a lifetime that is bounded by that of a task; <code class="literal">Thread-Local</code> should not be used in pool threads to communicate values between tasks.</p>
<p class="continued">Thread pools work best when tasks are <span class="emphasis"><em>homogeneous</em></span> and <span class="emphasis"><em>independent</em></span>. Mixing long-running and short-running tasks risks “clogging” the pool unless it is very large; submitting tasks that depend on other tasks risks deadlock unless the pool is unbounded. Fortunately, requests in typical network-based server applications—web servers, mail servers, file servers—usually meet these guidelines.</p>
<div class="sidebar"><a id="ch08sb01"/><p class="title"><b/></p>
<p>Some tasks have characteristics that require or preclude a specific execution policy. Tasks that depend on other tasks require that the thread pool be large enough that tasks are never queued or rejected; tasks that exploit thread confinement require sequential execution. Document these requirements so that future maintainers do not undermine safety or liveness by substituting an incompatible execution policy.</p>
</div>
<div class="section" title="Thread Starvation Deadlock"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lev2sec1"/>Thread Starvation Deadlock</h3></div></div></div>

<p>If tasks that depend on other tasks execute in a thread pool, they can deadlock. In a single-threaded executor, a task that submits another task to the same executor and waits for its result will always deadlock. The second task sits on the work queue until the first task completes, but the first will not complete because it is <a id="iddle1475" class="indexterm"/><a id="iddle1817" class="indexterm"/><a id="iddle2200" class="indexterm"/><a id="iddle2263" class="indexterm"/><a id="iddle2264" class="indexterm"/><a id="iddle2517" class="indexterm"/><a id="iddle4374" class="indexterm"/><a id="iddle4823" class="indexterm"/>waiting for the result of the second task. The same thing can happen in larger thread pools if all threads are executing tasks that are blocked waiting for other tasks still on the work queue. This is called <span class="emphasis"><em>thread starvation deadlock</em></span>, and can occur whenever a pool task initiates an unbounded blocking wait for some resource or condition that can succeed only through the action of another pool task, such as waiting for the return value or side effect of another task, unless you can guarantee that the pool is large enough.</p>
<p><code class="literal">ThreadDeadlock</code> in <a class="link" href="ch08.html#ch08list01" title="Example 8.1. Task that Deadlocks in a Single-threaded Executor. Don’t Do this.">Listing 8.1</a> illustrates thread starvation deadlock. <code class="literal">Render-PageTask</code> submits two additional tasks to the <code class="literal">Executor</code> to fetch the page header and footer, renders the page body, waits for the results of the header and footer tasks, and then combines the header, body, and footer into the finished page. With a single-threaded executor, <code class="literal">ThreadDeadlock</code> will always deadlock. Similarly, tasks coordinating amongst themselves with a barrier could also cause thread starvation deadlock if the pool is not big enough.</p>
<div class="sidebar"><a id="ch08sb02"/><p class="title"><b/></p>
<p>Whenever you submit to an <code class="literal">Executor</code> tasks that are not independent, be aware of the possibility of thread starvation deadlock, and document any pool sizing or configuration constraints in the code or configuration file where the <code class="literal">Executor</code> is configured.</p>
</div>
<p>In addition to any explicit bounds on the size of a thread pool, there may also be implicit limits because of constraints on other resources. If your application uses a JDBC connection pool with ten connections and each task needs a database connection, it is as if your thread pool only has ten threads because tasks in excess of ten will block waiting for a connection.</p>
<div class="example"><a id="ch08list01"/><p class="title"><b>Example 8.1. Task that Deadlocks in a Single-threaded <code class="literal">Executor</code>. <span class="emphasis"><em>Don’t Do this.</em></span></b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face.jpg" width="52" alt="Task that Deadlocks in a Single-threaded Executor. Don’t Do this."/></div>
<pre class="programlisting">public class ThreadDeadlock {
    ExecutorService exec = Executors.newSingleThreadExecutor();

    public class RenderPageTask implements Callable&lt;String&gt; {
        public String call() throws Exception {
            Future&lt;String&gt; header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();
            // <span class="emphasis"><em>Will deadlock -- task waiting for result of subtask</em></span>
            return <span class="strong"><strong>header.get()</strong></span> + page + <span class="strong"><strong>footer.get();</strong></span>
        }
    }
}
</pre>
</div></div><br class="example-break"/>
</div>
<div class="section" title="Long-running Tasks"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lev2sec2"/>Long-running Tasks</h3></div></div></div>


<p><a id="iddle1220" class="indexterm"/><a id="iddle1234" class="indexterm"/><a id="iddle1235" class="indexterm"/><a id="iddle1431" class="indexterm"/><a id="iddle1932" class="indexterm"/><a id="iddle1933" class="indexterm"/><a id="iddle2676" class="indexterm"/><a id="iddle2677" class="indexterm"/><a id="iddle2763" class="indexterm"/><a id="iddle3540" class="indexterm"/><a id="iddle3541" class="indexterm"/><a id="iddle3631" class="indexterm"/><a id="iddle3897" class="indexterm"/><a id="iddle3924" class="indexterm"/><a id="iddle3955" class="indexterm"/><a id="iddle3956" class="indexterm"/><a id="iddle4319" class="indexterm"/><a id="iddle4637" class="indexterm"/><a id="iddle4638" class="indexterm"/><a id="iddle4803" class="indexterm"/><a id="iddle4910" class="indexterm"/><a id="iddle4911" class="indexterm"/><a id="iddle4991" class="indexterm"/><a id="iddle4992" class="indexterm"/><a id="iddle5129" class="indexterm"/><a id="iddle5130" class="indexterm"/><a id="iddle5131" class="indexterm"/>Thread pools can have responsiveness problems if tasks can block for extended periods of time, even if deadlock is not a possibility. A thread pool can become clogged with long-running tasks, increasing the service time even for short tasks. If the pool size is too small relative to the expected steady-state number of longrunning tasks, eventually all the pool threads will be running long-running tasks and responsiveness will suffer.</p>
<p>One technique that can mitigate the ill effects of long-running tasks is for tasks to use timed resource waits instead of unbounded waits. Most blocking methods in the plaform libraries come in both untimed and timed versions, such as <code class="literal">Thread.join</code>, <code class="literal">BlockingQueue.put</code>, <code class="literal">CountDownLatch.await</code>, and <code class="literal">Selector.select</code>. If the wait times out, you can mark the task as failed and abort it or requeue it for execution later. This guarantees that each task eventually makes progress towards either successful or failed completion, freeing up threads for tasks that might complete more quickly. If a thread pool is frequently full of blocked tasks, this may also be a sign that the pool is too small.</p>
</div>
</div>









<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch08fn01" href="#ch08fn01" class="para">1</a>] </sup>The requirement is not quite this strong; it would be enough to ensure only that tasks not execute concurrently and provide enough synchronization so that the memory effects of one task are guaranteed to be visible to the next task—which is precisely the guarantee offered by <code class="literal">newSingle-ThreadExecutor</code>.</p></div></div></div></body></html>
