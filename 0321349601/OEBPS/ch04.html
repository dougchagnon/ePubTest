<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. Composing Objects</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="chapter" title="Chapter 4. Composing Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Composing Objects</h1></div></div></div>




<p><a id="iddle1349" class="indexterm"/><a id="iddle1350" class="indexterm"/><a id="iddle1410" class="indexterm"/><a id="iddle1911" class="indexterm"/><a id="iddle1912" class="indexterm"/><a id="iddle2031" class="indexterm"/><a id="iddle2609" class="indexterm"/><a id="iddle2862" class="indexterm"/><a id="iddle3345" class="indexterm"/><a id="iddle3363" class="indexterm"/><a id="iddle3364" class="indexterm"/><a id="iddle3592" class="indexterm"/><a id="iddle3636" class="indexterm"/><a id="iddle3637" class="indexterm"/><a id="iddle4412" class="indexterm"/><a id="iddle4413" class="indexterm"/><a id="iddle4503" class="indexterm"/><a id="iddle4504" class="indexterm"/><a id="iddle4505" class="indexterm"/><a id="iddle4563" class="indexterm"/>So far, we’ve covered the low-level basics of thread safety and synchronization. But we don’t want to have to analyze each memory access to ensure that our program is thread-safe; we want to be able to take thread-safe components and safely compose them into larger components or programs. This chapter covers patterns for structuring classes that can make it easier to make them thread-safe and to maintain them without accidentally undermining their safety guarantees.</p>



<div class="section" title="Designing a Thread-safe Class"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lev1sec1"/>Designing a Thread-safe Class</h2></div></div></div>

<p>While it is possible to write a thread-safe program that stores all its state in public static fields, it is a lot harder to verify its thread safety or to modify it so that it remains thread-safe than one that uses encapsulation appropriately. Encapsulation makes it possible to determine that a class is thread-safe without having to examine the entire program.</p>
<div class="sidebar"><a id="ch04sb01"/><p class="title"><b/></p>
<p>The design process for a thread-safe class should include these three basic elements:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Identify the variables that form the object’s state;</p></li><li class="listitem"><p>Identify the invariants that constrain the state variables;</p></li><li class="listitem"><p>Establish a policy for managing concurrent access to the object’s state.</p></li></ul></div>
</div>
<p class="continued">An object’s state starts with its fields. If they are all of primitive type, the fields comprise the entire state. <code class="literal">Counter</code> in <a class="link" href="ch04.html#ch04list01" title="Example 4.1. Simple Thread-safe Counter Using the Java Monitor Pattern.">Listing 4.1</a> has only one field, so the <code class="literal">value</code> field comprises its entire state. The state of an object with <span class="emphasis"><em>n</em></span> primitive fields is just the <span class="emphasis"><em>n</em></span>-tuple of its field values; the state of a 2D <code class="literal">Point</code> is its (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) value. If the object has fields that are references to other objects, its state will encompass fields from the referenced objects as well. For example, the state of a <code class="literal">LinkedList</code> includes the state of all the link node objects belonging to the list.</p>
<p>The <span class="emphasis"><em>synchronization policy</em></span> defines how an object coordinates access to its state without violating its invariants or postconditions. It specifies what combination of <a id="iddle1154" class="indexterm"/><a id="iddle1542" class="indexterm"/><a id="iddle1562" class="indexterm"/><a id="iddle2104" class="indexterm"/><a id="iddle2714" class="indexterm"/><a id="iddle3142" class="indexterm"/><a id="iddle3143" class="indexterm"/><a id="iddle3890" class="indexterm"/><a id="iddle3891" class="indexterm"/><a id="iddle4335" class="indexterm"/><a id="iddle4336" class="indexterm"/><a id="iddle4421" class="indexterm"/><a id="iddle4429" class="indexterm"/><a id="iddle4571" class="indexterm"/><a id="iddle4572" class="indexterm"/><a id="iddle4755" class="indexterm"/><a id="iddle4960" class="indexterm"/>immutability, thread confinement, and locking is used to maintain thread safety, and which variables are guarded by which locks. To ensure that the class can be analyzed and maintained, document the synchronization policy.</p>
<div class="example"><a id="ch04list01"/><p class="title"><b>Example 4.1. Simple Thread-safe Counter Using the Java Monitor Pattern.</b></p><div class="example-contents">

<pre class="programlisting">@ThreadSafe
public final class Counter {
    <span class="strong"><strong>@GuardedBy("this")</strong></span>  private long value = 0;

    public <span class="strong"><strong>synchronized</strong></span>  long getValue() {
        return value;
    }
    public  <span class="strong"><strong>synchronized</strong></span>  long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("counter overflow");
        return ++value;
    }
}
</pre>
</div></div><br class="example-break"/>
<div class="section" title="Gathering Synchronization Requirements"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lev2sec1"/>Gathering Synchronization Requirements</h3></div></div></div>

<p>Making a class thread-safe means ensuring that its invariants hold under concurrent access; this requires reasoning about its state. Objects and variables have a <span class="emphasis"><em>state space</em></span>: the range of possible states they can take on. The smaller this state space, the easier it is to reason about. By using final fields wherever practical, you make it simpler to analyze the possible states an object can be in. (In the extreme case, immutable objects can only be in a single state.)</p>
<p>Many classes have invariants that identify certain states as <span class="emphasis"><em>valid</em></span> or <span class="emphasis"><em>invalid</em></span>. The <code class="literal">value</code> field in <code class="literal">Counter</code> is a <code class="literal">long</code>. The state space of a <code class="literal">long</code> ranges from <code class="literal">Long.MIN_VALUE</code> to <code class="literal">Long.MAX_VALUE</code>, but <code class="literal">Counter</code> places constraints on <code class="literal">value</code>; negative values are not allowed.</p>
<p>Similarly, operations may have postconditions that identify certain <span class="emphasis"><em>state transitions</em></span> as invalid. If the current state of a <code class="literal">Counter</code> is 17, the <span class="emphasis"><em>only</em></span> valid next state is 18. When the next state is derived from the current state, the operation is necessarily a compound action. Not all operations impose state transition constraints; when updating a variable that holds the current temperature, its previous state does not affect the computation.</p>
<p>Constraints placed on states or state transitions by invariants and postconditions create additional synchronization or encapsulation requirements. If certain states are invalid, then the underlying state variables must be encapsulated, otherwise client code could put the object into an invalid state. If an operation has invalid state transitions, it must be made atomic. On the other hand, if the class does not impose any such constraints, we may be able to relax encapsulation or serialization requirements to obtain greater flexibility or better performance.</p>
<p><a id="iddle1150" class="indexterm"/><a id="iddle1237" class="indexterm"/><a id="iddle1437" class="indexterm"/><a id="iddle1727" class="indexterm"/><a id="iddle1878" class="indexterm"/><a id="iddle1896" class="indexterm"/><a id="iddle1897" class="indexterm"/><a id="iddle2546" class="indexterm"/><a id="iddle2567" class="indexterm"/><a id="iddle2855" class="indexterm"/><a id="iddle3273" class="indexterm"/><a id="iddle3376" class="indexterm"/><a id="iddle3441" class="indexterm"/><a id="iddle3442" class="indexterm"/><a id="iddle3647" class="indexterm"/><a id="iddle4144" class="indexterm"/><a id="iddle4390" class="indexterm"/><a id="iddle4415" class="indexterm"/><a id="iddle4416" class="indexterm"/><a id="iddle5054" class="indexterm"/>A class can also have invariants that constrain multiple state variables. A number range class, like <code class="literal">NumberRange</code> in <a class="link" href="ch04s03.html#ch04list10" title="Example 4.10. Number Range Class that does Not Sufficiently Protect Its Invariants. Don’t Do this.">Listing 4.10</a>, typically maintains state variables for the lower and upper bounds of the range. These variables must obey the constraint that the lower bound be less than or equal to the upper bound. Multivariable invariants like this one create atomicity requirements: related variables must be fetched or updated in a single atomic operation. You cannot update one, release and reacquire the lock, and then update the others, since this could involve leaving the object in an invalid state when the lock was released. When multiple variables participate in an invariant, the lock that guards them must be held for the duration of any operation that accesses the related variables.</p>
<div class="sidebar"><a id="ch04sb02"/><p class="title"><b/></p>
<p>You cannot ensure thread safety without understanding an object’s invariants and postconditions. Constraints on the valid values or state transitions for state variables can create atomicity and encapsulation requirements.</p>
</div>
</div>
<div class="section" title="State-dependent Operations"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lev2sec2"/>State-dependent Operations</h3></div></div></div>

<p>Class invariants and method postconditions constrain the valid states and state transitions for an object. Some objects also have methods with state-based <span class="emphasis"><em>preconditions</em></span>. For example, you cannot remove an item from an empty queue; a queue must be in the “nonempty” state before you can remove an element. Operations with state-based preconditions are called <span class="emphasis"><em>state-dependent</em></span> [CPJ 3].</p>
<p>In a single-threaded program, if a precondition does not hold, the operation has no choice but to fail. But in a concurrent program, the precondition may become true later due to the action of another thread. Concurrent programs add the possibility of waiting until the precondition becomes true, and then proceeding with the operation.</p>
<p>The built-in mechanisms for efficiently waiting for a condition to become true—<code class="literal">wait</code> and <code class="literal">notify</code>—are tightly bound to intrinsic locking, and can be difficult to use correctly. To create operations that wait for a precondition to become true before proceeding, it is often easier to use existing library classes, such as blocking queues or semaphores, to provide the desired state-dependent behavior. Blocking library classes such as <code class="literal">BlockingQueue</code>, <code class="literal">Semaphore</code>, and other <span class="emphasis"><em>synchronizers</em></span> are covered in <a class="link" href="ch05.html" title="Chapter 5. Building Blocks">Chapter 5</a>; creating state-dependent classes using the low-level mechanisms provided by the platform and class library is covered in <a class="link" href="ch14.html" title="Chapter 14. Building Custom Synchronizers">Chapter 14</a>.</p>
</div>
<div class="section" title="State Ownership"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lev2sec3"/>State Ownership</h3></div></div></div>

<p>We implied in <a class="link" href="ch04.html#ch04lev1sec1" title="Designing a Thread-safe Class">Section 4.1</a> that an object’s state could be a subset of the fields in the object graph rooted at that object. Why might it be a subset? Under what conditions are fields reachable from a given object <span class="emphasis"><em>not</em></span> part of that object’s state?</p>
<p>When defining which variables form an object’s state, we want to consider only the data that object <span class="emphasis"><em>owns</em></span>. Ownership is not embodied explicitly in the language, but is instead an element of class design. If you allocate and populate <a id="iddle1534" class="indexterm"/><a id="iddle2012" class="indexterm"/><a id="iddle2025" class="indexterm"/><a id="iddle2669" class="indexterm"/><a id="iddle2670" class="indexterm"/><a id="iddle2749" class="indexterm"/><a id="iddle3173" class="indexterm"/><a id="iddle3438" class="indexterm"/><a id="iddle3439" class="indexterm"/><a id="iddle3440" class="indexterm"/><a id="iddle3467" class="indexterm"/><a id="iddle3468" class="indexterm"/><a id="iddle4044" class="indexterm"/><a id="iddle4179" class="indexterm"/><a id="iddle4352" class="indexterm"/><a id="iddle4403" class="indexterm"/><a id="iddle4490" class="indexterm"/>a <code class="literal">HashMap</code>, you are creating multiple objects: the <code class="literal">HashMap</code> object, a number of <code class="literal">Map.Entry</code> objects used by the implementation of <code class="literal">HashMap</code>, and perhaps other internal objects as well. The logical state of a <code class="literal">HashMap</code> includes the state of all its <code class="literal">Map.Entry</code> and internal objects, even though they are implemented as separate objects.</p>
<p>For better or worse, garbage collection lets us avoid thinking carefully about ownership. When passing an object to a method in C++, you have to think fairly carefully about whether you are transferring ownership, engaging in a short-term loan, or envisioning long-term joint ownership. In Java, all these same ownership models are possible, but the garbage collector reduces the cost of many of the common errors in reference sharing, enabling less-than-precise thinking about ownership.</p>
<p>In many cases, ownership and encapsulation go together—the object encapsulates the state it owns and owns the state it encapsulates. It is the owner of a given state variable that gets to decide on the locking protocol used to maintain the integrity of that variable’s state. Ownership implies control, but once you publish a reference to a mutable object, you no longer have exclusive control; at best, you might have “shared ownership”. A class usually does not own the objects passed to its methods or constructors, unless the method is designed to explicitly transfer ownership of objects passed in (such as the synchronized collection wrapper factory methods).</p>
<p>Collection classes often exhibit a form of “split ownership”, in which the collection owns the state of the collection infrastructure, but client code owns the objects stored in the collection. An example is <code class="literal">ServletContext</code> from the servlet framework. <code class="literal">ServletContext</code> provides a <code class="literal">Map</code>-like object container service to servlets where they can register and retrieve application objects by name with <code class="literal">setAttribute</code> and <code class="literal">getAttribute</code>. The <code class="literal">ServletContext</code> object implemented by the servlet container must be thread-safe, because it will necessarily be accessed by multiple threads. Servlets need not use synchronization when calling <code class="literal">set-Attribute</code> and <code class="literal">getAttribute</code>, but they may have to use synchronization when <span class="emphasis"><em>using</em></span> the objects stored in the <code class="literal">ServletContext</code>. These objects are owned by the application; they are being stored for safekeeping by the servlet container on the application’s behalf. Like all shared objects, they must be shared safely; in order to prevent interference from multiple threads accessing the same object concurrently, they should either be thread-safe, effectively immutable, or explicitly guarded by a lock.<sup>[<a id="ch04fn1" href="#ftn.ch04fn1" class="footnote">1</a>]</sup>
</p>
</div>
</div>





<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch04fn1" href="#ch04fn1" class="para">1</a>] </sup>Interestingly, the <code class="literal">HttpSession</code> object, which performs a similar function in the servlet framework, may have stricter requirements. Because the servlet container may access the objects in the <code class="literal">HttpSession</code> so they can be serialized for replication or passivation, they must be thread-safe because the container will be accessing them as well as the web application. (We say “may have” since replication and passivation is outside of the servlet specification but is a common feature of servlet containers.)</p></div></div></div></body></html>
