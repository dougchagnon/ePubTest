<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Thread Confinement</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Thread Confinement"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lev1sec3"/>Thread Confinement</h2></div></div></div>

<p>Accessing shared, mutable data requires using synchronization; one way to avoid this requirement is to <span class="emphasis"><em>not share</em></span>. If data is only accessed from a single thread, no synchronization is needed. This technique, <span class="emphasis"><em>thread confinement</em></span>, is one of the simplest ways to achieve thread safety. When an object is confined to a thread, such usage is automatically thread-safe even if the confined object itself is not [CPJ 2.3.2].</p>
<p>Swing uses thread confinement extensively. The Swing visual components and data model objects are not thread safe; instead, safety is achieved by confining them to the Swing event dispatch thread. To use Swing properly, code running in threads other than the event thread should not access these objects. (To make this easier, Swing provides the <code class="literal">invokeLater</code> mechanism to schedule a <code class="literal">Runnable</code> for <a id="iddle1046" class="indexterm"/><a id="iddle1539" class="indexterm"/><a id="iddle1547" class="indexterm"/><a id="iddle1548" class="indexterm"/><a id="iddle1782" class="indexterm"/><a id="iddle1783" class="indexterm"/><a id="iddle1798" class="indexterm"/><a id="iddle1799" class="indexterm"/><a id="iddle1931" class="indexterm"/><a id="iddle2395" class="indexterm"/><a id="iddle2905" class="indexterm"/><a id="iddle2906" class="indexterm"/><a id="iddle2907" class="indexterm"/><a id="iddle3035" class="indexterm"/><a id="iddle3601" class="indexterm"/><a id="iddle4298" class="indexterm"/><a id="iddle4751" class="indexterm"/><a id="iddle4851" class="indexterm"/><a id="iddle5128" class="indexterm"/>execution in the event thread.) Many concurrency errors in Swing applications stem from improper use of these confined objects from another thread.</p>
<p>Another common application of thread confinement is the use of pooled JDBC (Java Database Connectivity) <code class="literal">Connection</code> objects. The JDBC specification does not require that <code class="literal">Connection</code> objects be thread-safe.<sup>[<a id="ch03fn09" href="#ftn.ch03fn09" class="footnote">9</a>]</sup> In typical server applications, a thread acquires a connection from the pool, uses it for processing a single request, and returns it. Since most requests, such as servlet requests or EJB (Enterprise JavaBeans) calls, are processed synchronously by a single thread, and the pool will not dispense the same connection to another thread until it has been returned, this pattern of connection management implicitly confines the <code class="literal">Connection</code> to that thread for the duration of the request.</p>
<p>Just as the language has no mechanism for enforcing that a variable is guarded by a lock, it has no means of confining an object to a thread. Thread confinement is an element of your program’s design that must be enforced by its implementation. The language and core libraries provide mechanisms that can help in maintaining thread confinement—local variables and the <code class="literal">ThreadLocal</code> class—but even with these, it is still the programmer’s responsibility to ensure that thread-confined objects do not escape from their intended thread.</p>
<div class="section" title="Ad-hoc Thread Confinement"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lev2sec6"/>Ad-hoc Thread Confinement</h3></div></div></div>

<p><span class="emphasis"><em>Ad-hoc thread confinement</em></span> describes when the responsibility for maintaining thread confinement falls entirely on the implementation. Ad-hoc thread confinement can be fragile because none of the language features, such as visibility modifiers or local variables, helps confine the object to the target thread. In fact, references to thread-confined objects such as visual components or data models in GUI applications are often held in public fields.</p>
<p>The decision to use thread confinement is often a consequence of the decision to implement a particular subsystem, such as the GUI, as a single-threaded subsystem. Single-threaded subsystems can sometimes offer a simplicity benefit that outweighs the fragility of ad-hoc thread confinement.<sup>[<a id="ch03fn10" href="#ftn.ch03fn10" class="footnote">10</a>]</sup></p>
<p>A special case of thread confinement applies to volatile variables. It is safe to perform read-modify-write operations on shared volatile variables as long as you ensure that the volatile variable is only written from a single thread. In this case, you are confining the <span class="emphasis"><em>modification</em></span> to a single thread to prevent race conditions, and the visibility guarantees for volatile variables ensure that other threads see the most up-to-date value.</p>
<p>Because of its fragility, ad-hoc thread confinement should be used sparingly; if possible, use one of the stronger forms of thread confinment (stack confinement or <code class="literal">ThreadLocal</code>) instead.</p>
</div>
<div class="section" title="Stack Confinement"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lev2sec7"/>Stack Confinement</h3></div></div></div>


<p><a id="iddle1535" class="indexterm"/><a id="iddle1536" class="indexterm"/><a id="iddle2013" class="indexterm"/><a id="iddle2402" class="indexterm"/><a id="iddle2850" class="indexterm"/><a id="iddle3036" class="indexterm"/><a id="iddle3360" class="indexterm"/><a id="iddle3361" class="indexterm"/><a id="iddle3653" class="indexterm"/><a id="iddle3654" class="indexterm"/><a id="iddle3821" class="indexterm"/><a id="iddle3822" class="indexterm"/><a id="iddle4356" class="indexterm"/><a id="iddle4357" class="indexterm"/><a id="iddle4358" class="indexterm"/><a id="iddle4756" class="indexterm"/><a id="iddle4757" class="indexterm"/><a id="iddle5052" class="indexterm"/><a id="iddle5053" class="indexterm"/><span class="emphasis"><em>Stack confinement</em></span> is a special case of thread confinement in which an object can only be reached through local variables. Just as encapsulation can make it easier to preserve invariants, local variables can make it easier to confine objects to a thread. Local variables are intrinsically confined to the executing thread; they exist on the executing thread’s stack, which is not accessible to other threads. Stack confinement (also called <span class="emphasis"><em>within-thread</em></span> or <span class="emphasis"><em>thread-local</em></span> usage, but not to be confused with the <code class="literal">ThreadLocal</code> library class) is simpler to maintain and less fragile than ad-hoc thread confinement.</p>
<p>For primitively typed local variables, such as <code class="literal">numPairs</code> in <code class="literal">loadTheArk</code> in <a class="link" href="ch03s03.html#ch03list09" title="Example 3.9. Thread Confinement of Local Primitive and Reference Variables.">Listing 3.9</a>, you cannot violate stack confinement even if you tried. There is no way to obtain a reference to a primitive variable, so the language semantics ensure that primitive local variables are always stack confined.</p>
<div class="example"><a id="ch03list09"/><p class="title"><b>Example 3.9. Thread Confinement of Local Primitive and Reference Variables.</b></p><div class="example-contents">

<pre class="programlisting">public int loadTheArk(Collection&lt;Animal&gt; candidates) {
    SortedSet&lt;Animal&gt; animals;
    int numPairs = 0;
    Animal candidate = null;

    <span class="emphasis"><em>// animals confined to method, don't let them escape!</em></span>
    animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for (Animal a : animals) {
        if (candidate == null || !candidate.isPotentialMate(a))
            candidate = a;
        else {
            ark.load(new AnimalPair(candidate, a));
            ++numPairs;
            candidate = null;
        }
    }
    return numPairs;
}
</pre>
</div></div><br class="example-break"/>
<p>Maintaining stack confinement for object references requires a little more assistance from the programmer to ensure that the referent does not escape. In <code class="literal">loadTheArk</code>, we instantiate a <code class="literal">TreeSet</code> and store a reference to it in <code class="literal">animals</code>. At this point, there is exactly one reference to the <code class="literal">Set</code>, held in a local variable and therefore confined to the executing thread. However, if we were to publish a reference to the <code class="literal">Set</code> (or any of its internals), the confinement would be violated and the animals would escape.</p>
<p>Using a non-thread-safe object in a within-thread context is still thread-safe. However, be careful: the design requirement that the object be confined to the executing thread, or the awareness that the confined object is not thread-safe, <a id="iddle1546" class="indexterm"/><a id="iddle1549" class="indexterm"/><a id="iddle1965" class="indexterm"/><a id="iddle2448" class="indexterm"/><a id="iddle2449" class="indexterm"/><a id="iddle4305" class="indexterm"/><a id="iddle4306" class="indexterm"/><a id="iddle4670" class="indexterm"/><a id="iddle4671" class="indexterm"/><a id="iddle4758" class="indexterm"/><a id="iddle4849" class="indexterm"/><a id="iddle5062" class="indexterm"/>often exists only in the head of the developer when the code is written. If the assumption of within-thread usage is not clearly documented, future maintainers might mistakenly allow the object to escape.</p>
</div>
<div class="section" title="ThreadLocal"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lev2sec8"/>ThreadLocal</h3></div></div></div>

<p>A more formal means of maintaining thread confinement is <code class="literal">ThreadLocal</code>, which allows you to associate a per-thread value with a value-holding object. <code class="literal">Thread-Local</code> provides <code class="literal">get</code> and <code class="literal">set</code> accessormethods that maintain a separate copy of the value for each thread that uses it, so a <code class="literal">get</code> returns the most recent value passed to <code class="literal">set</code> <span class="emphasis"><em>from the currently executing thread</em></span>.</p>
<p>Thread-local variables are often used to prevent sharing in designs based on mutable Singletons or global variables. For example, a single-threaded application might maintain a global database connection that is initialized at startup to avoid having to pass a <code class="literal">Connection</code> to every method. Since JDBC connections may not be thread-safe, a multithreaded application that uses a global connection without additional coordination is not thread-safe either. By using a <code class="literal">ThreadLocal</code> to store the JDBC connection, as in <code class="literal">ConnectionHolder</code> in <a class="link" href="ch03s03.html#ch03list10" title="Example 3.10. Using ThreadLocal to Ensure thread Confinement.">Listing 3.10</a>, each thread will have its own connection.</p>
<div class="example"><a id="ch03list10"/><p class="title"><b>Example 3.10. Using <code class="literal">ThreadLocal</code> to Ensure thread Confinement.</b></p><div class="example-contents">

<pre class="programlisting">private static ThreadLocal&lt;Connection&gt; connectionHolder
    = new ThreadLocal&lt;Connection&gt;() {
        public Connection initialValue() {
            return DriverManager.getConnection(DB_URL);
        }
    };

public static Connection getConnection() {
    return connectionHolder.get();
}
</pre>
</div></div><br class="example-break"/>
<p>This technique can also be used when a frequently used operation requires a temporary object such as a buffer and wants to avoid reallocating the temporary object on each invocation. For example, before Java 5.0, <code class="literal">Integer.toString</code> used a <code class="literal">ThreadLocal</code> to store the 12-byte buffer used for formatting its result, rather than using a shared static buffer (which would require locking) or allocating a new buffer for each invocation.<sup>[<a id="ch03fn11" href="#ftn.ch03fn11" class="footnote">11</a>]</sup></p>
<p>When a thread calls <code class="literal">ThreadLocal.get</code> for the first time, <code class="literal">initialValue</code> is consulted to provide the initial value for that thread. Conceptually, you can think of a <code class="literal">ThreadLocal&lt;T&gt;</code> as holding a <code class="literal">Map&lt;Thread,T&gt;</code> that stores the thread-specific <a id="iddle1109" class="indexterm"/><a id="iddle1983" class="indexterm"/><a id="iddle2408" class="indexterm"/><a id="iddle2409" class="indexterm"/><a id="iddle2532" class="indexterm"/><a id="iddle2705" class="indexterm"/><a id="iddle2706" class="indexterm"/><a id="iddle2711" class="indexterm"/><a id="iddle2860" class="indexterm"/><a id="iddle2861" class="indexterm"/><a id="iddle3350" class="indexterm"/><a id="iddle4126" class="indexterm"/><a id="iddle4127" class="indexterm"/><a id="iddle4852" class="indexterm"/>values, though this is not how it is actually implemented. The thread-specific values are stored in the <code class="literal">Thread</code> object itself; when the thread terminates, the thread-specific values can be garbage collected.</p>
<p>If you are porting a single-threaded application to a multithreaded environment, you can preserve thread safety by converting shared global variables into <code class="literal">ThreadLocal</code>s, if the semantics of the shared globals permits this; an applicationwide cache would not be as useful if it were turned into a number of thread-local caches.</p>
<p><code class="literal">ThreadLocal</code> is widely used in implementing application frameworks. For example, J2EE containers associate a transaction context with an executing thread for the duration of an EJB call. This is easily implemented using a static <code class="literal">Thread-Local</code> holding the transaction context: when framework code needs to determine what transaction is currently running, it fetches the transaction context from this <code class="literal">ThreadLocal</code>. This is convenient in that it reduces the need to pass execution context information into every method, but couples any code that uses this mechanism to the framework.</p>
<p>It is easy to abuse <code class="literal">ThreadLocal</code> by treating its thread confinement property as a license to use global variables or as a means of creating “hidden” method arguments. Like global variables, thread-local variables can detract from reusability and introduce hidden couplings among classes, and should therefore be used with care.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch03fn09" href="#ch03fn09" class="para">9</a>] </sup>The connection <span class="emphasis"><em>pool</em></span> implementations provided by application servers are thread-safe; connection pools are necessarily accessed from multiple threads, so a non-thread-safe implementation would not make sense.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn10" href="#ch03fn10" class="para">10</a>] </sup>Another reason to make a subsystem single-threaded is deadlock avoidance; this is one of the primary reasons most GUI frameworks are single-threaded. Single-threaded subsystems are covered in <a class="link" href="ch09.html" title="Chapter 9. GUI Applications">Chapter 9</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn11" href="#ch03fn11" class="para">11</a>] </sup>This technique is unlikely to be a performance win unless the operation is performed very frequently or the allocation is unusually expensive. In Java 5.0, it was replaced with the more straightforward approach of allocating a new buffer for every invocation, suggesting that for something as mundane as a temporary buffer, it is not a performance win.</p></div></div></div></body></html>
