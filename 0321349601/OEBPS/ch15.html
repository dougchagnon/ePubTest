<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 15. Atomic Variables and Nonblocking Synchronization</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="chapter" title="Chapter 15. Atomic Variables and Nonblocking Synchronization"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Atomic Variables and Nonblocking Synchronization</h1></div></div></div>




<p><a id="iddle1022" class="indexterm"/><a id="iddle1023" class="indexterm"/><a id="iddle1054" class="indexterm"/><a id="iddle1058" class="indexterm"/><a id="iddle1137" class="indexterm"/><a id="iddle1170" class="indexterm"/><a id="iddle1174" class="indexterm"/><a id="iddle1324" class="indexterm"/><a id="iddle1484" class="indexterm"/><a id="iddle1755" class="indexterm"/><a id="iddle1800" class="indexterm"/><a id="iddle2470" class="indexterm"/><a id="iddle2918" class="indexterm"/><a id="iddle3024" class="indexterm"/><a id="iddle3087" class="indexterm"/><a id="iddle3121" class="indexterm"/><a id="iddle3301" class="indexterm"/><a id="iddle3305" class="indexterm"/><a id="iddle3377" class="indexterm"/><a id="iddle3378" class="indexterm"/><a id="iddle3379" class="indexterm"/><a id="iddle3394" class="indexterm"/><a id="iddle3395" class="indexterm"/><a id="iddle3427" class="indexterm"/><a id="iddle3428" class="indexterm"/><a id="iddle3429" class="indexterm"/><a id="iddle3533" class="indexterm"/><a id="iddle3534" class="indexterm"/><a id="iddle3535" class="indexterm"/><a id="iddle4083" class="indexterm"/><a id="iddle4084" class="indexterm"/><a id="iddle4085" class="indexterm"/><a id="iddle5045" class="indexterm"/><a id="iddle5065" class="indexterm"/><a id="iddle5123" class="indexterm"/>Many of the classes in <code class="literal">java.util.concurrent</code>, such as <code class="literal">Semaphore</code> and <code class="literal">ConcurrentLinkedQueue</code>, provide better performance and scalability than alternatives using <code class="literal">synchronized</code>. In this chapter, we take a look at the primary source of this performance boost: atomic variables and nonblocking synchronization.</p>
<p>Much of the recent research on concurrent algorithms has focused on <span class="emphasis"><em>nonblocking algorithms</em></span>, which use low-level atomic machine instructions such as <span class="emphasis"><em>compare-and-swap</em></span> instead of locks to ensure data integrity under concurrent access. Nonblocking algorithms are used extensively in operating systems and JVMs for thread and process scheduling, garbage collection, and to implement locks and other concurrent data structures.</p>
<p>Nonblocking algorithms are considerably more complicated to design and implement than lock-based alternatives, but they can offer significant scalability and liveness advantages. They coordinate at a finer level of granularity and can greatly reduce scheduling overhead because they don’t block when multiple threads contend for the same data. Further, they are immune to deadlock and other liveness problems. In lock-based algorithms, other threads cannot make progress if a thread goes to sleep or spins while holding a lock, whereas nonblocking algorithms are impervious to individual thread failures. As of Java 5.0, it is possible to build efficient nonblocking algorithms in Java using the <span class="emphasis"><em>atomic variable classes</em></span> such as <code class="literal">AtomicInteger</code> and <code class="literal">AtomicReference</code>.</p>
<p>Atomic variables can also be used as “better volatile variables” even if you are not developing nonblocking algorithms. Atomic variables offer the same memory semantics as volatile variables, but with additional support for atomic updates—making them ideal for counters, sequence generators, and statistics gathering while offering better scalability than lock-based alternatives.</p>



<div class="section" title="Disadvantages of Locking"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lev1sec1"/>Disadvantages of Locking</h2></div></div></div>

<p>Coordinating access to shared state using a consistent locking protocol ensures that whichever thread holds the lock guarding a set of variables has exclusive <a id="iddle1589" class="indexterm"/><a id="iddle1590" class="indexterm"/><a id="iddle2917" class="indexterm"/><a id="iddle3657" class="indexterm"/><a id="iddle3658" class="indexterm"/><a id="iddle3691" class="indexterm"/><a id="iddle4512" class="indexterm"/><a id="iddle4827" class="indexterm"/><a id="iddle5126" class="indexterm"/>access to those variables, and that any changes made to those variables are visible to other threads that subsequently acquire the lock.</p>
<p>Modern JVMs can optimize uncontended lock acquisition and release fairly effectively, but if multiple threads request the lock at the same time the JVM enlists the help of the operating system. If it gets to this point, some unfortunate thread will be suspended and have to be resumed later.<sup>[<a id="ch15fn01" href="#ftn.ch15fn01" class="footnote">1</a>]</sup> When that thread is resumed, it may have to wait for other threads to finish their scheduling quanta before it is actually scheduled. Suspending and resuming a thread has a lot of overhead and generally entails a lengthy interruption. For lock-based classes with fine-grained operations (such as the synchronized collections classes, where most methods contain only a few operations), the ratio of scheduling overhead to useful work can be quite high <span class="emphasis"><em>when the lock is frequently contended</em></span>.</p>
<p>Volatile variables are a lighter-weight synchronization mechanism than locking because they do not involve context switches or thread scheduling. However, volatile variables have some limitations compared to locking: while they provide similar visibility guarantees, they cannot be used to construct atomic compound actions. This means that volatile variables cannot be used when one variable depends on another, or when the new value of a variable depends on its old value. This limits when volatile variables are appropriate, since they cannot be used to reliably implement common tools such as counters or mutexes.<sup>[<a id="ch15fn02" href="#ftn.ch15fn02" class="footnote">2</a>]</sup></p>
<p>For example, while the increment operation (<code class="literal">++i</code>) may <span class="emphasis"><em>look</em></span> like an atomic operation, it is actually three distinct operations—fetch the current value of the variable, add one to it, and then write the updated value back. In order to not lose an update, the entire read-modify-write operation must be atomic. So far, the only way we’ve seen to do this is with locking, as in <code class="literal">Counter</code> on page <a class="link" href="ch04.html#ch04list01" title="Example 4.1. Simple Thread-safe Counter Using the Java Monitor Pattern.">56</a>.</p>
<p><code class="literal">Counter</code> is thread-safe, and in the presence of little or no contention performs just fine. But under contention, performance suffers because of context-switch overhead and scheduling delays. When locks are held so briefly, being put to sleep is a harsh penalty for asking for the lock at the wrong time.</p>
<p>Locking has a few other disadvantages. When a thread is waiting for a lock, it cannot do anything else. If a thread holding a lock is delayed (due to a page fault, scheduling delay, or the like), then no thread that needs that lock can make progress. This can be a serious problem if the blocked thread is a high-priority thread but the thread holding the lock is a lower-priority thread—a performance hazard known as <span class="emphasis"><em>priority inversion</em></span>. Even though the higher-priority thread should have precedence, it must wait until the lock is released, and this effectively downgrades its priority to that of the lower-priority thread. If a thread holding a lock is permanently blocked (due to an infinite loop, deadlock, livelock, or other liveness failure), any threads waiting for that lock can never make progress.</p>
<p>Even ignoring these hazards, locking is simply a heavyweight mechanism for fine-grained operations such as incrementing a counter. It would be nice to have a finer-grained technique for managing contention between threads—something <a id="iddle1321" class="indexterm"/><a id="iddle1389" class="indexterm"/><a id="iddle1605" class="indexterm"/><a id="iddle1606" class="indexterm"/><a id="iddle2617" class="indexterm"/><a id="iddle3096" class="indexterm"/><a id="iddle4513" class="indexterm"/>like volatile variables, but offering the possibility of atomic updates as well. Happily, modern processors offer us precisely such a mechanism.</p>
</div>








<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch15fn01" href="#ch15fn01" class="para">1</a>] </sup>A smart JVM need not necessarily suspend a thread if it contends for a lock; it could use profiling data to decide adaptively between suspension and spin locking based on how long the lock has been held during previous acquisitions.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch15fn02" href="#ch15fn02" class="para">2</a>] </sup>It is theoretically possible, though wholly impractical, to use the semantics of <code class="literal">volatile</code> to construct mutexes and other synchronizers; see (<a class="link" href="bi01.html#biblio01_029">Raynal, 1986</a>).</p></div></div></div></body></html>
