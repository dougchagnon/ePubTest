<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Using Condition Queues</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Using Condition Queues"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lev1sec2"/>Using Condition Queues</h2></div></div></div>

<p>Condition queues make it easier to build efficient and responsive state-dependent classes, but they are still easy to use incorrectly; there are a lot of rules regarding their proper use that are not enforced by the compiler or platform. (This is one of the reasons to build on top of classes like <code class="literal">LinkedBlockingQueue</code>, <code class="literal">CountDown-Latch</code>, <code class="literal">Semaphore</code>, and <code class="literal">FutureTask</code> when you can; if you can get away with it, it is a lot easier.)</p>
<div class="section" title="The Condition Predicate"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec4"/>The Condition Predicate</h3></div></div></div>


<p><a id="iddle1499" class="indexterm"/><a id="iddle15001" class="indexterm"/><a id="iddle1500" class="indexterm"/><a id="iddle1501" class="indexterm"/><a id="iddle1512" class="indexterm"/><a id="iddle1513" class="indexterm"/><a id="iddle1901" class="indexterm"/><a id="iddle1902" class="indexterm"/><a id="iddle2508" class="indexterm"/><a id="iddle2509" class="indexterm"/><a id="iddle3163" class="indexterm"/><a id="iddle3164" class="indexterm"/><a id="iddle3641" class="indexterm"/><a id="iddle4430" class="indexterm"/><a id="iddle4431" class="indexterm"/><a id="iddle5055" class="indexterm"/><a id="iddle5056" class="indexterm"/><a id="iddle5133" class="indexterm"/><a id="iddle5134" class="indexterm"/>The key to using condition queues correctly is identifying the <span class="emphasis"><em>condition predicates</em></span> that the object may wait for. It is the condition predicate that causes much of the confusion surrounding <code class="literal">wait</code> and <code class="literal">notify</code>, because it has no instantiation in the API and nothing in either the language specification or the JVM implementation ensures its correct use. In fact, it is not mentioned directly at all in the language specification or the Javadoc. But without it, condition waits would not work.</p>
<p><span class="emphasis"><em>The condition predicate is the precondition that makes an operation state-dependent in the first place.</em></span> In a bounded buffer, <code class="literal">take</code> can proceed only if the buffer is not empty; otherwise it must wait. For <code class="literal">take</code>, the condition predicate is “the buffer is not empty”, which <code class="literal">take</code> must test for before proceeding. Similarly, the condition predicate for <code class="literal">put</code> is “the buffer is not full”. Condition predicates are expressions constructed from the state variables of the class; <code class="literal">BaseBoundedBuffer</code> tests for “buffer not empty” by comparing <code class="literal">count</code> to zero, and tests for “buffer not full” by comparing <code class="literal">count</code> to the buffer size.</p>
<div class="sidebar"><a id="ch14sb01"/><p class="title"><b/></p>
<p>Document the condition predicate(s) associated with a condition queue and the operations that wait on them.</p>
</div>
<p>There is an important three-way relationship in a condition wait involving locking, the <code class="literal">wait</code> method, and a condition predicate. The condition predicate involves state variables, and the state variables are guarded by a lock, so before testing the condition predicate, we must hold that lock. The lock object and the condition queue object (the object on which <code class="literal">wait</code> and <code class="literal">notify</code> are invoked) must also be the same object.</p>
<p>In <code class="literal">BoundedBuffer</code>, the buffer state is guarded by the buffer lock and the buffer object is used as the condition queue. The <code class="literal">take</code> method acquires the buffer lock and then tests the condition predicate (that the buffer is nonempty). If the buffer is indeed nonempty, it removes the first element, which it can do because it still holds the lock guarding the buffer state.</p>
<p>If the condition predicate is not true (the buffer is empty), <code class="literal">take</code> must wait until another thread puts an object in the buffer. It does this by calling <code class="literal">wait</code> on the buffer’s intrinsic condition queue, which requires holding the lock on the condition queue object. As careful design would have it, <code class="literal">take</code> already holds that lock, which it needed to test the condition predicate (and if the condition predicate was true, to modify the buffer state in the same atomic operation). The <code class="literal">wait</code> method releases the lock, blocks the current thread, and waits until the specified timeout expires, the thread is interrupted, or the thread is awakened by a notification. After the thread wakes up, <code class="literal">wait</code> reacquires the lock before returning. A thread waking up from <code class="literal">wait</code> gets no special priority in reacquiring the lock; it contends for the lock just like any other thread attempting to enter a <code class="literal">synchronized</code> block.</p>
<div class="sidebar"><a id="ch14sb02"/><p class="title"><b/></p>
<p><a id="iddle1517" class="indexterm"/><a id="iddle2510" class="indexterm"/><a id="iddle3686" class="indexterm"/><a id="iddle5139" class="indexterm"/><a id="iddle5151" class="indexterm"/>Every call to <code class="literal">wait</code> is implicitly associated with a specific <span class="emphasis"><em>condition predicate</em></span>. When calling <code class="literal">wait</code> regarding a particular condition predicate, the caller must already hold the lock associated with the condition queue, and that lock must also guard the state variables from which the condition predicate is composed.</p>
</div>
</div>
<div class="section" title="Waking Up Too Soon"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec5"/>Waking Up Too Soon</h3></div></div></div>

<p>As if the three-way relationship among the lock, the condition predicate, and the condition queue were not complicated enough, that <code class="literal">wait</code> returns does not necessarily mean that the condition predicate the thread is waiting for has become true.</p>
<p><span class="emphasis"><em>A single intrinsic condition queue may be used with more than one condition predicate.</em></span> When your thread is awakened because someone called <code class="literal">notifyAll</code>, that doesn’t mean that the condition predicate <span class="emphasis"><em>you</em></span> were waiting for is now true. (This is like having your toaster and coffee maker share a single bell; when it rings, you still have to look to see which device raised the signal.)<sup>[<a id="ch14fn07" href="#ftn.ch14fn07" class="footnote">7</a>]</sup> Additionally, <code class="literal">wait</code> is even allowed to return “spuriously”—not in response to any thread calling <code class="literal">notify</code>.<sup>[<a id="ch14fn08" href="#ftn.ch14fn08" class="footnote">8</a>]</sup></p>
<p>When control re-enters the code calling <code class="literal">wait</code>, it has reacquired the lock associated with the condition queue. Is the condition predicate now true? Maybe. It might have been true at the time the notifying thread called <code class="literal">notifyAll</code>, but could have become false again by the time <span class="emphasis"><em>you</em></span> reacquire the lock. Other threads may have acquired the lock and changed the object’s state between when your thread was awakened and when <code class="literal">wait</code> reacquired the lock. Or maybe it hasn’t been true at all since you called <code class="literal">wait</code>. You don’t know why another thread called <code class="literal">notify</code> or <code class="literal">notifyAll</code>; maybe it was because <span class="emphasis"><em>another</em></span> condition predicate associated with the same condition queue became true. Multiple condition predicates per condition queue are quite common—<code class="literal">BoundedBuffer</code> uses the same condition queue for both the “not full” and “not empty” predicates.<sup>[<a id="ch14fn09" href="#ftn.ch14fn09" class="footnote">9</a>]</sup></p>
<p>For all these reasons, when you wake up from <code class="literal">wait</code> you must test the condition predicate <span class="emphasis"><em>again</em></span>, and go back to waiting (or fail) if it is not yet true. Since you can wake up repeatedly without your condition predicate being true, you must therefore always call <code class="literal">wait</code> from within a loop, testing the condition predicate in each iteration. The canonical form for a condition wait is shown in <a class="link" href="ch14s02.html#ch14list07" title="Example 14.7. Canonical Form for State-dependent Methods.">Listing 14.7</a>.</p>

<p/><div class="example"><a id="ch14list07"/><p class="title"><b>Example 14.7. Canonical Form for State-dependent Methods.</b></p><div class="example-contents">


<pre class="programlisting">void stateDependentMethod() throws InterruptedException {
    <span class="emphasis"><em>// condition predicate must be guarded by lock</em></span>
    synchronized(lock) {
        while (!conditionPredicate())
            lock.wait();
        <span class="emphasis"><em>// object is now in desired state</em></span>
    }
}
</pre>
</div></div><br class="example-break"/>
<div class="sidebar"><a id="ch14sb03"/><p class="title"><b/></p>
<p><a id="iddle1514" class="indexterm"/><a id="iddle2511" class="indexterm"/><a id="iddle2637" class="indexterm"/><a id="iddle3213" class="indexterm"/><a id="iddle3214" class="indexterm"/><a id="iddle4436" class="indexterm"/><a id="iddle5135" class="indexterm"/>When using condition waits (<code class="literal">Object.wait</code> or <code class="literal">Condition.await</code>):</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Always have a condition predicate—some test of object state that must hold before proceeding;</p></li><li class="listitem"><p>Always test the condition predicate before calling <code class="literal">wait</code>, and again after returning from <code class="literal">wait</code>;</p></li><li class="listitem"><p>Always call <code class="literal">wait</code> in a loop;</p></li><li class="listitem"><p>Ensure that the state variables making up the condition predicate are guarded by the lock associated with the condition queue;</p></li><li class="listitem"><p>Hold the lock associated with the the condition queue when calling <code class="literal">wait</code>, <code class="literal">notify</code>, or <code class="literal">notifyAll</code>; and</p></li><li class="listitem"><p>Do not release the lock after checking the condition predicate but before acting on it.</p></li></ul></div>
</div>
</div>
<div class="section" title="Missed Signals"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec6"/>Missed Signals</h3></div></div></div>

<p><a class="link" href="ch10.html" title="Chapter 10. Avoiding Liveness Hazards">Chapter 10</a> discussed liveness failures such as deadlock and livelock. Another form of liveness failure is <span class="emphasis"><em>missed signals</em></span>. A missed signal occurs when a thread must wait for a specific condition that is already true, but fails to check the condition predicate before waiting. Now the thread is waiting to be notified of an event that has already occurred. This is like starting the toast, going out to get the newspaper, having the bell go off while you are outside, and then sitting down at the kitchen table waiting for the toast bell. You could wait a long time—potentially forever.<sup>[<a id="ch14fn10" href="#ftn.ch14fn10" class="footnote">10</a>]</sup> Unlike the marmalade for your toast, notification is not “sticky”—if thread <span class="emphasis"><em>A</em></span> notifies on a condition queue and thread <span class="emphasis"><em>B</em></span> subsequently waits on that same condition queue, <span class="emphasis"><em>B</em></span> does <span class="emphasis"><em>not</em></span> immediately wake up—another notification is required to wake <span class="emphasis"><em>B</em></span>. Missed signals are the result of coding errors like those warned against in the list above, such as failing to test the condition predicate before calling <code class="literal">wait</code>. If you structure your condition waits as in <a class="link" href="ch14s02.html#ch14list07" title="Example 14.7. Canonical Form for State-dependent Methods.">Listing 14.7</a>, you will not have problems with missed signals.</p>
</div>
<div class="section" title="Notification"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec7"/>Notification</h3></div></div></div>


<p><a id="iddle3215" class="indexterm"/><a id="iddle3310" class="indexterm"/><a id="iddle3311" class="indexterm"/><a id="iddle3312" class="indexterm"/><a id="iddle3313" class="indexterm"/><a id="iddle3314" class="indexterm"/><a id="iddle3315" class="indexterm"/><a id="iddle3316" class="indexterm"/><a id="iddle3317" class="indexterm"/><a id="iddle3318" class="indexterm"/><a id="iddle3331" class="indexterm"/><a id="iddle3332" class="indexterm"/><a id="iddle3336" class="indexterm"/><a id="iddle3337" class="indexterm"/>So far, we’ve described half of what goes on in a condition wait: waiting. The other half is notification. In a bounded buffer, <code class="literal">take</code> blocks if called when the buffer is empty. In order for <code class="literal">take</code> to <span class="emphasis"><em>unblock</em></span> when the buffer becomes nonempty, we must ensure that <span class="emphasis"><em>every</em></span> code path in which the buffer could become nonempty performs a notification. In <code class="literal">BoundedBuffer</code>, there is only one such place—after a <code class="literal">put</code>. So <code class="literal">put</code> calls <code class="literal">notifyAll</code> after successfully adding an object to the buffer. Similarly, <code class="literal">take</code> calls <code class="literal">notifyAll</code> after removing an element to indicate that the buffer may no longer be full, in case any threads are waiting on the “not full” condition.</p>
<div class="sidebar"><a id="ch14sb04"/><p class="title"><b/></p>
<p>Whenever you wait on a condition, make sure that someone will perform a notification whenever the condition predicate becomes true.</p>
</div>
<p>There are two notification methods in the condition queue API—<code class="literal">notify</code> and <code class="literal">notifyAll</code>. To call either, you must hold the lock associated with the condition queue object. Calling <code class="literal">notify</code> causes the JVM to select one thread waiting on that condition queue to wake up; calling <code class="literal">notifyAll</code> wakes up <span class="emphasis"><em>all</em></span> the threads waiting on that condition queue. Because you must hold the lock on the condition queue object when calling <code class="literal">notify</code> or <code class="literal">notifyAll</code>, and waiting threads cannot return from <code class="literal">wait</code> without reacquiring the lock, the notifying thread should release the lock quickly to ensure that the waiting threads are unblocked as soon as possible.</p>
<p>Because multiple threads could be waiting on the same condition queue for different condition predicates, using <code class="literal">notify</code> instead of <code class="literal">notifyAll</code> can be dangerous, primarily because single notification is prone to a problem akin to missed signals.</p>
<p><code class="literal">BoundedBuffer</code> provides a good illustration of why <code class="literal">notifyAll</code> should be preferred to single <code class="literal">notify</code> in most cases. The condition queue is used for two different condition predicates: “not full” and “not empty”. Suppose thread <span class="emphasis"><em>A</em></span> waits on a condition queue for predicate <span class="emphasis"><em>PA</em></span>, while thread <span class="emphasis"><em>B</em></span> waits on the same condition queue for predicate <span class="emphasis"><em>PB</em></span>. Now, suppose <span class="emphasis"><em>PB</em></span> becomes true and thread <span class="emphasis"><em>C</em></span> performs a single <code class="literal">notify</code>: the JVM will wake up one thread of its own choosing. If <span class="emphasis"><em>A</em></span> is chosen, it will wake up, see that <span class="emphasis"><em>PA</em></span> is not yet true, and go back to waiting. Meanwhile, <span class="emphasis"><em>B</em></span>, which could now make progress, does not wake up. This is not exactly a missed signal—it’s more of a “hijacked signal”—but the problem is the same: a thread is waiting for a signal that has (or should have) already occurred.</p>
<div class="sidebar"><a id="ch14sb05"/><p class="title"><b/></p>
<p><a id="iddle1519" class="indexterm"/><a id="iddle1520" class="indexterm"/><a id="iddle2555" class="indexterm"/><a id="iddle3321" class="indexterm"/><a id="iddle3322" class="indexterm"/><a id="iddle3328" class="indexterm"/><a id="iddle3329" class="indexterm"/><a id="iddle3335" class="indexterm"/><a id="iddle3397" class="indexterm"/><a id="iddle3510" class="indexterm"/><a id="iddle4290" class="indexterm"/><a id="iddle4291" class="indexterm"/>Single <code class="literal">notify</code> can be used instead of <code class="literal">notifyAll</code> only when both of the following conditions hold:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="Uniform waiters."><b><span class="strong"><strong>Uniform waiters.</strong></span> </b>Only one condition predicate is associated with the condition queue, and each thread executes the same logic upon returning from <code class="literal">wait</code>; and</p></li><li class="listitem"><p title="One-in, one-out."><b><span class="strong"><strong>One-in, one-out.</strong></span> </b>A notification on the condition variable enables at most one thread to proceed.</p></li></ul></div>
</div>
<p class="continued"><code class="literal">BoundedBuffer</code> meets the one-in, one-out requirement, but does not meet the uniform waiters requirement because waiting threads might be waiting for either the “not full” and “not empty” condition. A “starting gate” latch like that used in <code class="literal">TestHarness</code> on page <a class="link" href="ch05s05.html#ch05list11" title="Example 5.11. Using CountDownLatch for Starting and Stopping Threads in Timing Tests.">96</a>, in which a single event releases a set of threads, does not meet the one-in, one-out requirement because opening the starting gate lets multiple threads proceed.</p>
<p>Most classes don’t meet these requirements, so the prevailing wisdom is to use <code class="literal">notifyAll</code> in preference to single <code class="literal">notify</code>. While this may be inefficient, it is much easier to ensure that your classes behave correctly when using <code class="literal">notifyAll</code> instead of <code class="literal">notify</code>.</p>
<p>This “prevailing wisdom” makes some people uncomfortable, and for good reason. Using <code class="literal">notifyAll</code> when only one thread can make progress is inefficient—sometimes a little, sometimes grossly so. If ten threads are waiting on a condition queue, calling <code class="literal">notifyAll</code> causes each of them to wake up and contend for the lock; then most or all of them will go right back to sleep. This means a lot of context switches and a lot of contended lock acquisitions for each event that enables (maybe) a single thread to make progress. (In the worst case, using <code class="literal">notify-All</code> results in <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>) wakeups where <span class="emphasis"><em>n</em></span> would suffice.) This is another situation where performance concerns support one approach and safety concerns support the other.</p>
<p>The notification done by <code class="literal">put</code> and <code class="literal">take</code> in <code class="literal">BoundedBuffer</code> is conservative: a notification is performed every time an object is put into or removed from the buffer. This could be optimized by observing that a thread can be released from a wait only if the buffer goes from empty to not empty or from full to not full, and notifying only if a <code class="literal">put</code> or <code class="literal">take</code> effected one of these state transitions. This is called <span class="emphasis"><em>conditional notification.</em></span> While conditional notification can improve performance, it is tricky to get right (and also complicates the implementation of subclasses) and so should be used carefully. <a class="link" href="ch14s02.html#ch14list08" title="Example 14.8. Using Conditional Notification in BoundedBuffer.put.">Listing 14.8</a> illustrates using conditional notification in <code class="literal">BoundedBuffer</code>.<code class="literal">put</code>.</p>
<p>Single notification and conditional notification are optimizations. As always, follow the principle “First make it right, and then make it fast—<span class="emphasis"><em>if</em></span> it is not already fast enough” when using these optimizations; it is easy to introduce strange liveness failures by applying them incorrectly.</p>

<p/><div class="example"><a id="ch14list08"/><p class="title"><b>Example 14.8. Using Conditional Notification in <code class="literal">BoundedBuffer.put</code>.</b></p><div class="example-contents">


<pre class="programlisting">public synchronized void put(V v) throws InterruptedException {
    while (isFull())
        wait();
    <span class="strong"><strong>boolean wasEmpty = isEmpty();</strong></span>
    doPut(v);
    <span class="strong"><strong>if (wasEmpty)</strong></span>
        <span class="strong"><strong>notifyAll();</strong></span>
}
</pre>
</div></div><br class="example-break"/>
</div>
<div class="section" title="Example: A Gate Class"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec8"/>Example: A Gate Class</h3></div></div></div>

<p><a id="iddle1202" class="indexterm"/><a id="iddle1450" class="indexterm"/><a id="iddle1521" class="indexterm"/><a id="iddle1522" class="indexterm"/><a id="iddle1962" class="indexterm"/><a id="iddle2397" class="indexterm"/><a id="iddle2447" class="indexterm"/><a id="iddle2938" class="indexterm"/><a id="iddle2942" class="indexterm"/><a id="iddle3323" class="indexterm"/><a id="iddle3333" class="indexterm"/><a id="iddle3334" class="indexterm"/><a id="iddle3799" class="indexterm"/><a id="iddle4045" class="indexterm"/><a id="iddle4506" class="indexterm"/><a id="iddle4507" class="indexterm"/>The starting gate latch in <code class="literal">TestHarness</code> on page <a class="link" href="ch05s05.html#ch05list11" title="Example 5.11. Using CountDownLatch for Starting and Stopping Threads in Timing Tests.">96</a> was constructed with an initial count of one, creating a <span class="emphasis"><em>binary latch</em></span>: one with two states, the initial state and the terminal state. The latch prevents threads from passing the starting gate until it is opened, at which point all the threads can pass through. While this latching mechanism is often exactly what is needed, sometimes it is a drawback that a gate constructed in this manner cannot be reclosed once opened.</p>
<p>It is easy to develop a recloseable <code class="literal">ThreadGate</code> class using condition waits, as shown in <a class="link" href="ch14s02.html#ch14list09" title="Example 14.9. Recloseable Gate Using Wait and Notifyall.">Listing 14.9</a>. <code class="literal">ThreadGate</code> lets the gate be opened and closed, providing an <code class="literal">await</code> method that blocks until the gate is opened. The <code class="literal">open</code> method uses <code class="literal">notifyAll</code> because the semantics of this class fail the “one-in, one-out” test for single notification.</p>
<p>The condition predicate used by <code class="literal">await</code> is more complicated than simply testing <code class="literal">isOpen</code>. This is needed because if <span class="emphasis"><em>N</em></span> threads are waiting at the gate at the time it is opened, they should all be allowed to proceed. But, if the gate is opened and closed in rapid succession, all threads might not be released if <code class="literal">await</code> examines only <code class="literal">isOpen</code>: by the time all the threads receive the notification, reacquire the lock, and emerge from <code class="literal">wait</code>, the gate may have closed again. So <code class="literal">ThreadGate</code> uses a somewhat more complicated condition predicate: every time the gate is closed, a “generation” counter is incremented, and a thread may pass <code class="literal">await</code> if the gate is open now or if the gate has opened since this thread arrived at the gate.</p>
<p>Since <code class="literal">ThreadGate</code> only supports waiting for the gate to open, it performs notification only in <code class="literal">open</code>; to support both “wait for open” and “wait for close” operations, it would have to notify in both <code class="literal">open</code> and <code class="literal">close</code>. This illustrates why state-dependent classes can be fragile to maintain—the addition of a new statedependent operation may require modifying many code paths that modify the object state so that the appropriate notifications can be performed.</p>
</div>
<div class="section" title="Subclass Safety Issues"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec9"/>Subclass Safety Issues</h3></div></div></div>

<p>Using conditional or single notification introduces constraints that can complicate subclassing [CPJ 3.3.3.3]. If you want to support subclassing at all, you must structure your class so subclasses can add the appropriate notification on behalf <a id="iddle1988" class="indexterm"/><a id="iddle2201" class="indexterm"/>of the base class if it is subclassed in a way that violates one of the requirements for single or conditional notification.</p>
<div class="example"><a id="ch14list09"/><p class="title"><b>Example 14.9. Recloseable Gate Using <code class="literal">Wait</code> and <code class="literal">Notifyall</code>.</b></p><div class="example-contents">

<pre class="programlisting">@ThreadSafe
public class ThreadGate {
    <span class="emphasis"><em>// CONDITION-PREDICATE: opened-since(n) (isOpen || generation&gt;n)</em></span>
    @GuardedBy("this") private boolean isOpen;
    @GuardedBy("this") private int generation;

    public synchronized void close() {
        isOpen = false;
    }

    public synchronized void open() {
        ++generation;
        isOpen = true;
        notifyAll();
    }

    <span class="emphasis"><em>// BLOCKS-UNTIL: opened-since(generation on entry)</em></span>
    public synchronized void await() throws InterruptedException {
        int arrivalGeneration = generation;
        while (!isOpen &amp;&amp; arrivalGeneration == generation)
            wait();
    }
}
</pre>
</div></div><br class="example-break"/>
<p><span class="emphasis"><em>A state-dependent class should either fully expose (and document) its waiting and notification protocols to subclasses, or prevent subclasses from participating in them at all.</em></span> (This is an extension of “design and document for inheritance, or else prohibit it” [EJ Item 15].) At the very least, designing a state-dependent class for inheritance requires exposing the condition queues and locks and documenting the condition predicates and synchronization policy; it may also require exposing the underlying state variables. (The worst thing a state-dependent class can do is expose its state to subclasses but <span class="emphasis"><em>not</em></span> document its protocols for waiting and notification; this is like a class exposing its state variables but not documenting its invariants.)</p>
<p>One option for doing this is to effectively prohibit subclassing, either by making the class <code class="literal">final</code> or by hiding the condition queues, locks, and state variables from subclasses. Otherwise, if the subclass does something to undermine the way the base class uses <code class="literal">notify</code>, it needs to be able to repair the damage. Consider an unbounded blocking stack in which the pop operation blocks if the stack is empty but the push operation can always proceed. This meets the requirements for single notification. If this class uses single notification and a subclass adds a blocking “pop two consecutive elements” method, there are now two classes of <a id="iddle1118" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1496" class="indexterm"/><a id="iddle1506" class="indexterm"/><a id="iddle1508" class="indexterm"/><a id="iddle1510" class="indexterm"/><a id="iddle1511" class="indexterm"/><a id="iddle1900" class="indexterm"/><a id="iddle2017" class="indexterm"/><a id="iddle2037" class="indexterm"/><a id="iddle2038" class="indexterm"/><a id="iddle2279" class="indexterm"/><a id="iddle2280" class="indexterm"/><a id="iddle2825" class="indexterm"/><a id="iddle3068" class="indexterm"/><a id="iddle3346" class="indexterm"/><a id="iddle3347" class="indexterm"/><a id="iddle3706" class="indexterm"/><a id="iddle3707" class="indexterm"/><a id="iddle3760" class="indexterm"/><a id="iddle5048" class="indexterm"/><a id="iddle5049" class="indexterm"/><a id="iddle5100" class="indexterm"/><a id="iddle5101" class="indexterm"/>waiters: those waiting to pop one element and those waiting to pop two. But if the base class exposes the condition queue and documents its protocols for using it, the subclass can override the push method to perform a <code class="literal">notifyAll</code>, restoring safety.</p>
</div>
<div class="section" title="Encapsulating Condition Queues"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec10"/>Encapsulating Condition Queues</h3></div></div></div>

<p>It is generally best to encapsulate the condition queue so that it is not accessible outside the class hierarchy in which it is used. Otherwise, callers might be tempted to think they understand your protocols for waiting and notification and use them in a manner inconsistent with your design. (It is impossible to enforce the uniform waiters requirement for single notification unless the condition queue object is inaccessible to code you do not control; if alien code mistakenly waits on your condition queue, this could subvert your notification protocol and cause a hijacked signal.)</p>
<p>Unfortunately, this advice—to encapsulate objects used as condition queues—is not consistent with the most common design pattern for thread-safe classes, in which an object’s intrinsic lock is used to guard its state. <code class="literal">BoundedBuffer</code> illustrates this common idiom, where the buffer object itself is the lock and condition queue. However, <code class="literal">BoundedBuffer</code> could be easily restructured to use a private lock object and condition queue; the only difference would be that it would no longer support any form of client-side locking.</p>
</div>
<div class="section" title="Entry and Exit Protocols"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lev2sec11"/>Entry and Exit Protocols</h3></div></div></div>

<p>Wellings (<a class="link" href="bi01.html#biblio01_032">Wellings, 2004</a>) characterizes the proper use of <code class="literal">wait</code> and <code class="literal">notify</code> in terms of <span class="emphasis"><em>entry</em></span> and <span class="emphasis"><em>exit protocols</em></span>. For each state-dependent operation and for each operation that modifies state on which another operation has a state dependency, you should define and document an entry and exit protocol. The entry protocol is the operation’s condition predicate; the exit protocol involves examining any state variables that have been changed by the operation to see if they might have caused some other condition predicate to become true, and if so, notifying on the associated condition queue.</p>
<p><code class="literal">AbstractQueuedSynchronizer</code>, upon which most of the state-dependent classes in <code class="literal">java.util.concurrent</code> are built (see <a class="link" href="ch14s04.html" title="Anatomy of a Synchronizer">Section 14.4</a>), exploits the concept of exit protocol. Rather than letting synchronizer classes perform their own notification, it instead requires synchronizer methods to return a value indicating whether its action might have unblocked one or more waiting threads. This explicit API requirement makes it harder to “forget” to notify on some state transitions.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch14fn07" href="#ch14fn07" class="para">7</a>] </sup>This situation actually describes Tim’s kitchen pretty well; so many devices beep that when you hear one, you have to inspect the toaster, the microwave, the coffee maker, and several others to determine the cause of the signal.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch14fn08" href="#ch14fn08" class="para">8</a>] </sup>To push the breakfast analogy way too far, this is like a toaster with a loose connection that makes the bell go off when the toast is ready but also sometimes when it is not ready.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch14fn09" href="#ch14fn09" class="para">9</a>] </sup>It is actually possible for threads to be waiting for both “not full” and “not empty” at the same time! This can happen when the number of producers/consumers exceeds the buffer capacity.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch14fn10" href="#ch14fn10" class="para">10</a>] </sup>In order to emerge from this wait, someone else would have to make toast, but this will just make matters worse; when the bell rings, you will then have a disagreement about toast ownership.</p></div></div></div></body></html>
