<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Summary</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Summary"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lev1sec7"/>Summary</h2></div></div></div>

<p>If you need to implement a state-dependent class—one whose methods must block if a state-based precondition does not hold—the best strategy is usually to build upon an existing library class such as <code class="literal">Semaphore</code>, <code class="literal">BlockingQueue</code>, or <code class="literal">CountDownLatch</code>, as in <code class="literal">ValueLatch</code> on page <a class="link" href="ch08s05.html#ch08list15" title="Example 8.15. Sequential Puzzle Solver.">187</a>. However, sometimes existing library classes do not provide a sufficient foundation; in these cases, you can build your own synchronizers using intrinsic condition queues, explicit <code class="literal">Condition</code> objects, or <code class="literal">AbstractQueuedSynchronizer</code>. Intrinsic condition queues are tightly bound to intrinsic locking, since the mechanism for managing state dependence is necessarily tied to the mechanism for ensuring state consistency. Similarly, explicit <code class="literal">Condition</code>s are tightly bound to explicit <code class="literal">Lock</code>s, and offer an extended feature set compared to intrinsic condition queues, including multiple wait sets per lock, interruptible or uninterruptible condition waits, fair or nonfair queuing, and deadline-based waiting.</p>
</div></body></html>
