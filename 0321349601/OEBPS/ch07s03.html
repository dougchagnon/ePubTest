<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Handling Abnormal Thread Termination</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Handling Abnormal Thread Termination"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lev1sec3"/>Handling Abnormal Thread Termination</h2></div></div></div>

<p>It is obvious when a single-threaded console application terminates due to an uncaught exception—the program stops running and produces a stack trace that is very different from typical program output. Failure of a thread in a concurrent application is not always so obvious. The stack trace may be printed on the console, but no one may be watching the console. Also, when a thread fails, the application may appear to continue to work, so its failure could go unnoticed. Fortunately, there are means of both detecting and preventing threads from “leaking” from an application.</p>
<p>The leading cause of premature thread death is <code class="literal">RuntimeException</code>. Because these exceptions indicate a programming error or other unrecoverable problem, they are generally not caught. Instead they propagate all the way up the stack, at which point the default behavior is to print a stack trace on the console and let the thread terminate.</p>
<p>The consequences of abnormal thread death range from benign to disastrous, depending on the thread’s role in the application. Losing a thread from a thread pool can have performance consequences, but an application that runs well with a 50-thread pool will probably run fine with a 49-thread pool too. But losing the event dispatch thread in a GUI application would be quite noticeable—the application would stop processing events and the GUI would freeze. <code class="literal">OutOfTime</code> on <a class="link" href="ch06s03.html#ch06list09" title="Example 6.9. Class Illustrating Confusing Timer Behavior.">124</a> showed a serious consequence of thread leakage: the service represented by the <code class="literal">Timer</code> is permanently out of commission.</p>
<p>Just about any code can throw a <code class="literal">RuntimeException</code>. Whenever you call another method, you are taking a leap of faith that it will return normally or throw one of the checked exceptions its signature declares. The less familiar you are with the code being called, the more skeptical you should be about its behavior.</p>
<p>Task-processing threads such as the worker threads in a thread pool or the Swing event dispatch thread spend their whole life calling unknown code through an abstraction barrier like <code class="literal">Runnable</code>, and these threads should be very skeptical that the code they call will be well behaved. It would be very bad if a service like the Swing event thread failed just because some poorly written event handler threw a <code class="literal">NullPointerException</code>. Accordingly, these facilities should call tasks within a <code class="literal">try-catch</code> block that catches unchecked exceptions, or within a <code class="literal">try-finally</code> block to ensure that if the thread exits abnormally the framework is informed of this and can take corrective action. This is one of the few times when you might want to consider catching <code class="literal">RuntimeException</code>—when you are calling unknown, untrusted code through an abstraction such as <code class="literal">Runnable</code>.<sup>[<a id="ch07fn07" href="#ftn.ch07fn07" class="footnote">7</a>]</sup></p>
<p><a class="link" href="ch07s03.html#ch07list23" title="Example 7.23. Typical Thread-pool Worker Thread Structure.">Listing 7.23</a> illustrates a way to structure a worker thread within a thread pool. If a task throws an unchecked exception, it allows the thread to die, but not before notifying the framework that the thread has died. The framework may then replace the worker thread with a new thread, or may choose not to because the thread pool is being shut down or there are already enough worker threads to meet current demand. <code class="literal">ThreadPoolExecutor</code> and Swing use this technique to ensure that a poorly behaved task doesn’t prevent subsequent tasks from executing. If you are writing a worker thread class that executes submitted tasks, or calling untrusted external code (such as dynamically loaded plugins), use one of these approaches to prevent a poorly written task or plugin from taking down the thread that happens to call it.</p>
<div class="example"><a id="ch07list23"/><p class="title"><b>Example 7.23. Typical Thread-pool Worker Thread Structure.</b></p><div class="example-contents">

<pre class="programlisting">public void run() {
    Throwable thrown = null;
    try {
        while (!isInterrupted())
            runTask(getTaskFromWorkQueue());
    } catch (Throwable e) {
        thrown = e;
    } finally {
        threadExited(this, thrown);
    }
}
</pre>
</div></div><br class="example-break"/>
<div class="section" title="Uncaught Exception Handlers"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lev2sec13"/>Uncaught Exception Handlers</h3></div></div></div>

<p>The previous section offered a proactive approach to the problem of unchecked exceptions. The Thread API also provides the <code class="literal">UncaughtExceptionHandler</code> facility, which lets you detect when a thread dies due to an uncaught exception. The two approaches are complementary: taken together, they provide defense-indepth against thread leakage.</p>
<p>When a thread exits due to an uncaught exception, the JVM reports this event to an application-provided <code class="literal">UncaughtExceptionHandler</code> (see <a class="link" href="ch07s03.html#ch07list24" title="Example 7.24. UncaughtExceptionHandler Interface.">Listing 7.24</a>); if no handler exists, the default behavior is to print the stack trace to <code class="literal">System.err</code>.<sup>[<a id="ch07fn08" href="#ftn.ch07fn08" class="footnote">8</a>]</sup></p>

<p/><div class="example"><a id="ch07list24"/><p class="title"><b>Example 7.24. <code class="literal">UncaughtExceptionHandler</code> Interface.</b></p><div class="example-contents">


<pre class="programlisting">public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
}
</pre>
</div></div><br class="example-break"/>
<p><a id="iddle2208" class="indexterm"/><a id="iddle2231" class="indexterm"/><a id="iddle2232" class="indexterm"/><a id="iddle2241" class="indexterm"/><a id="iddle2242" class="indexterm"/><a id="iddle2523" class="indexterm"/><a id="iddle3167" class="indexterm"/><a id="iddle3168" class="indexterm"/><a id="iddle3632" class="indexterm"/><a id="iddle4508" class="indexterm"/><a id="iddle4509" class="indexterm"/><a id="iddle4980" class="indexterm"/><a id="iddle5000" class="indexterm"/>What the handler should do with an uncaught exception depends on your quality-of-service requirements. The most common response is to write an error message and stack trace to the application log, as shown in <a class="link" href="ch07s03.html#ch07list25" title="Example 7.25. UncaughtExceptionHandler that Logs the Exception.">Listing 7.25</a>. Handlers can also take more direct action, such as trying to restart the thread, shutting down the application, paging an operator, or other corrective or diagnostic action.</p>
<div class="example"><a id="ch07list25"/><p class="title"><b>Example 7.25. <code class="literal">UncaughtExceptionHandler</code> that Logs the Exception.</b></p><div class="example-contents">

<pre class="programlisting">public class UEHLogger implements Thread.UncaughtExceptionHandler {
    public void uncaughtException(Thread t, Throwable e) {
        Logger logger = Logger.getAnonymousLogger();
        logger.log(Level.SEVERE,
              "Thread terminated with exception: " + t.getName(),
              e);
    }
}
</pre>
</div></div><br class="example-break"/>
<div class="sidebar"><a id="ch07sb08"/><p class="title"><b/></p>
<p>In long-running applications, always use uncaught exception handlers for all threads that at least log the exception.</p>
</div>
<p>To set an <code class="literal">UncaughtExceptionHandler</code> for pool threads, provide a <code class="literal">ThreadFactory</code> to the <code class="literal">ThreadPoolExecutor</code> constructor. (As with all thread manipulation, only the thread’s owner should change its <code class="literal">UncaughtExceptionHandler</code>.) The standard thread pools allow an uncaught task exception to terminate the pool thread, but use a <code class="literal">try-finally</code> block to be notified when this happens so the thread can be replaced. Without an uncaught exception handler or other failure notification mechanism, tasks can appear to fail silently, which can be very confusing. If you want to be notified when a task fails due to an exception so that you can take some task-specific recovery action, either wrap the task with a <code class="literal">Runnable</code> or <code class="literal">Callable</code> that catches the exception or override the <code class="literal">afterExecute</code> hook in <code class="literal">ThreadPoolExecutor</code>.</p>
<p>Somewhat confusingly, exceptions thrown from tasks make it to the uncaught exception handler only for tasks submitted with <code class="literal">execute</code>; for tasks submitted with <code class="literal">submit</code>, <span class="emphasis"><em>any</em></span> thrown exception, checked or not, is considered to be part of the task’s return status. If a task submitted with <code class="literal">submit</code> terminates with an exception, it is rethrown by <code class="literal">Future.get</code>, wrapped in an <code class="literal">ExecutionException</code>.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch07fn07" href="#ch07fn07" class="para">7</a>] </sup>There is some controversy over the safety of this technique; when a thread throws an unchecked <a id="iddle2235" class="indexterm"/><a id="iddle2315" class="indexterm"/><a id="iddle2316" class="indexterm"/><a id="iddle2929" class="indexterm"/><a id="iddle2955" class="indexterm"/><a id="iddle4529" class="indexterm"/><a id="iddle4773" class="indexterm"/><a id="iddle4774" class="indexterm"/><a id="iddle4785" class="indexterm"/><a id="iddle4853" class="indexterm"/><a id="iddle4854" class="indexterm"/><a id="iddle4999" class="indexterm"/><a id="iddle5002" class="indexterm"/>exception, the entire application may possibly be compromised. But the alternative—shutting down the entire application—is usually not practical.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch07fn08" href="#ch07fn08" class="para">8</a>] </sup>Before Java 5.0, the only way to control the <code class="literal">UncaughtExceptionHandler</code> was by subclassing <code class="literal">ThreadGroup</code>. In Java 5.0 and later, you can set an <code class="literal">UncaughtExceptionHandler</code> on a per-thread basis with <code class="literal">Thread.setUncaughtExceptionHandler</code>, and can also set the default <code class="literal">UncaughtExceptionHandler</code> with <code class="literal">Thread.setDefaultUncaughtExceptionHandler</code>. However, only one of these handlers is called—first the JVM looks for a per-thread handler, then for a <code class="literal">ThreadGroup</code> handler. The default handler implementation in <code class="literal">ThreadGroup</code> delegates to its parent thread group, and so on up the chain until one of the <code class="literal">ThreadGroup</code> handlers deals with the uncaught exception or it bubbles up to the toplevel thread group. The top-level thread group handler delegates to the default system handler (if one exists; the default is none) and otherwise prints the stack trace to the console.</p></div></div></div></body></html>
