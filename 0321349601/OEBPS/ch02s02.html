<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Atomicity</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Atomicity"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lev1sec2"/>Atomicity</h2></div></div></div>

<p>What happens when we add one element of state to what was a stateless object? Suppose we want to add a “hit counter” that measures the number of requests processed. The obvious approach is to add a <code class="literal">long</code> field to the servlet and increment it on each request, as shown in <code class="literal">UnsafeCountingFactorizer</code> in <a class="link" href="ch02s02.html#ch02list02" title="Example 2.2. Servlet that Counts Requests without the Necessary Synchronization. Don’t Do this.">Listing 2.2</a>.</p>
<div class="example"><a id="ch02list02"/><p class="title"><b>Example 2.2. Servlet that Counts Requests without the Necessary Synchronization. <span class="emphasis"><em>Don’t Do this.</em></span></b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face.jpg" width="52" alt="Servlet that Counts Requests without the Necessary Synchronization. Don’t Do this."/></div>
<pre class="programlisting">@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private long count = 0;

    public long getCount() { return count; }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        <span class="strong"><strong>++count;</strong></span>
        encodeIntoResponse(resp, factors);
    }

}
</pre>
</div></div><br class="example-break"/>
<p>Unfortunately, <code class="literal">UnsafeCountingFactorizer</code> is not thread-safe, even though it would work just fine in a single-threaded environment. Just like <code class="literal">UnsafeSequence</code> on page <a class="link" href="ch01s03.html#ch01list01" title="Example 1.1. Non-thread-safe Sequence Generator.">6</a>, it is susceptible to <span class="emphasis"><em>lost updates</em></span>. While the increment operation, <code class="literal">++count</code>, <a id="iddle17641" class="indexterm"/><a id="iddle1764" class="indexterm"/><a id="iddle2778" class="indexterm"/><a id="iddle3779" class="indexterm"/><a id="iddle3794" class="indexterm"/><a id="iddle4366" class="indexterm"/>may look like a single action because of its compact syntax, it is not <span class="emphasis"><em>atomic</em></span>, which means that it does not execute as a single, indivisible operation. Instead, it is a shorthand for a sequence of three discrete operations: fetch the current value, add one to it, and write the new value back. This is an example of a <span class="emphasis"><em>read-modify-write</em></span> operation, in which the resulting state is derived from the previous state.</p>
<p><a class="link" href="ch01s03.html#ch01fig01" title="Figure 1.1. Unlucky Execution of UnsafeSequence.getNext.">Figure 1.1</a> on page <a class="link" href="ch01s03.html#ch01list01" title="Example 1.1. Non-thread-safe Sequence Generator.">6</a> shows what can happen if two threads try to increment a counter simultaneously without synchronization. If the counter is initially 9, with some unlucky timing each thread could read the value, see that it is 9, add one to it, and each set the counter to 10. This is clearly not what is supposed to happen; an increment got lost along the way, and the hit counter is now permanently off by one.</p>
<p>You might think that having a slightly inaccurate count of hits in a web-based service is an acceptable loss of accuracy, and sometimes it is. But if the counter is being used to generate sequences or unique object identifiers, returning the same value from multiple invocations could cause serious data integrity problems.<sup>[<a id="ch02fn03" href="#ftn.ch02fn03" class="footnote">3</a>]</sup> The possibility of incorrect results in the presence of unlucky timing is so important in concurrent programming that it has a name: a <span class="emphasis"><em>race condition</em></span>.</p>
<div class="section" title="Race Conditions"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lev2sec2"/>Race Conditions</h3></div></div></div>

<p><code class="literal">UnsafeCountingFactorizer</code> has several <span class="emphasis"><em>race conditions</em></span> that make its results unreliable. A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime; in other words, when getting the right answer relies on lucky timing. <sup>[<a id="ch02fn04" href="#ftn.ch02fn04" class="footnote">4</a>]</sup> The most common type of race condition is <span class="emphasis"><em>check-then-act</em></span>, where a potentially stale observation is used to make a decision on what to do next.</p>
<p>We often encounter race conditions in real life. Let’s say you planned to meet a friend at noon at the Starbucks on University Avenue. But when you get there, you realize there are <span class="emphasis"><em>two</em></span> Starbucks on University Avenue, and you’re not sure which one you agreed to meet at. At 12:10, you don’t see your friend at Starbucks <span class="emphasis"><em>A</em></span>, so you walk over to Starbucks <span class="emphasis"><em>B</em></span> to see if he’s there, but he isn’t there either. There are a few possibilities: your friend is late and not at either Starbucks; your friend arrived at Starbucks <span class="emphasis"><em>A</em></span> after you left; or your friend <span class="emphasis"><em>was</em></span> at Starbucks <span class="emphasis"><em>B</em></span>, but went to look for you, and is now en route to Starbucks <span class="emphasis"><em>A</em></span>. Let’s assume the worst and say it was the last possibility. Now it’s 12:15, you’ve both been to both Starbucks, and you’re both wondering if you’ve been stood up. What do you do now? Go back to the other Starbucks? How many times are you going to go back <a id="iddle1331" class="indexterm"/><a id="iddle2126" class="indexterm"/><a id="iddle2736" class="indexterm"/><a id="iddle2737" class="indexterm"/><a id="iddle2946" class="indexterm"/><a id="iddle2947" class="indexterm"/><a id="iddle3712" class="indexterm"/>and forth? Unless you have agreed on a protocol, you could both spend the day walking up and down University Avenue, frustrated and undercaffeinated.</p>
<p>The problem with the “I’ll just nip up the street and see if he’s at the other one” approach is that while you’re walking up the street, your friend might have moved. You look around Starbucks <span class="emphasis"><em>A</em></span>, observe “he’s not here”, and go looking for him. And you can do the same for Starbucks <span class="emphasis"><em>B</em></span>, but <span class="emphasis"><em>not at the same time</em></span>. It takes a few minutes to walk up the street, and during those few minutes, <span class="emphasis"><em>the state of the system may have changed</em></span>.</p>
<p>The Starbucks example illustrates a race condition because reaching the desired outcome (meeting your friend) depends on the relative timing of events (when each of you arrives at one Starbucks or the other, how long you wait there before switching, etc). The observation that he is not at Starbucks <span class="emphasis"><em>A</em></span> becomes potentially invalid as soon as you walk out the front door; he could have come in through the back door and you wouldn’t know. It is this invalidation of observations that characterizes most race conditions—using a potentially stale observation to make a decision or perform a computation. This type of race condition is called <span class="emphasis"><em>check-then-act</em></span>: you observe something to be true (file <span class="emphasis"><em>X</em></span> doesn’t exist) and then take action based on that observation (create <span class="emphasis"><em>X</em></span>); but in fact the observation could have become invalid between the time you observed it and the time you acted on it (someone else created <span class="emphasis"><em>X</em></span> in the meantime), causing a problem (unexpected exception, overwritten data, file corruption).</p>
</div>
<div class="section" title="Example: Race Conditions in Lazy Initialization"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lev2sec3"/>Example: Race Conditions in Lazy Initialization</h3></div></div></div>

<p>A common idiom that uses check-then-act is <span class="emphasis"><em>lazy initialization</em></span>. The goal of lazy initialization is to defer initializing an object until it is actually needed while at the same time ensuring that it is initialized only once. <code class="literal">LazyInitRace</code> in <a class="link" href="ch02s02.html#ch02list03" title="Example 2.3. Race Condition in Lazy Initialization. Don’t Do this.">Listing 2.3</a> illustrates the lazy initialization idiom. The <code class="literal">getInstance</code> method first checks whether the <code class="literal">ExpensiveObject</code> has already been initialized, in which case it returns the existing instance; otherwise it creates a new instance and returns it after retaining a reference to it so that future invocations can avoid the more expensive code path.</p>
<div class="example"><a id="ch02list03"/><p class="title"><b>Example 2.3. Race Condition in Lazy Initialization. <span class="emphasis"><em>Don’t Do this.</em></span></b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face.jpg" width="52" alt="Race Condition in Lazy Initialization. Don’t Do this."/></div>
<pre class="programlisting">@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null)
            instance = new ExpensiveObject();
        return instance;
    }
}
</pre>
</div></div><br class="example-break"/>
<p><a id="iddle1035" class="indexterm"/><a id="iddle1036" class="indexterm"/><a id="iddle1037" class="indexterm"/><a id="iddle1038" class="indexterm"/><a id="iddle1144" class="indexterm"/><a id="iddle1145" class="indexterm"/><a id="iddle1146" class="indexterm"/><a id="iddle1149" class="indexterm"/><a id="iddle1240" class="indexterm"/><a id="iddle1241" class="indexterm"/><a id="iddle1330" class="indexterm"/><a id="iddle1411" class="indexterm"/><a id="iddle1412" class="indexterm"/><a id="iddle1413" class="indexterm"/><a id="iddle1414" class="indexterm"/><a id="iddle1417" class="indexterm"/><a id="iddle1418" class="indexterm"/><a id="iddle1419" class="indexterm"/><a id="iddle1420" class="indexterm"/><a id="iddle1421" class="indexterm"/><a id="iddle1422" class="indexterm"/><a id="iddle1423" class="indexterm"/><a id="iddle1559" class="indexterm"/><a id="iddle1560" class="indexterm"/><a id="iddle1561" class="indexterm"/><a id="iddle1680" class="indexterm"/><a id="iddle1681" class="indexterm"/><a id="iddle1682" class="indexterm"/><a id="iddle1683" class="indexterm"/><a id="iddle1704" class="indexterm"/><a id="iddle1770" class="indexterm"/><a id="iddle1771" class="indexterm"/><a id="iddle1772" class="indexterm"/><a id="iddle1773" class="indexterm"/><a id="iddle1774" class="indexterm"/><a id="iddle1864" class="indexterm"/><a id="iddle1865" class="indexterm"/><a id="iddle1866" class="indexterm"/><a id="iddle1867" class="indexterm"/><a id="iddle1868" class="indexterm"/><a id="iddle2464" class="indexterm"/><a id="iddle2465" class="indexterm"/><a id="iddle2503" class="indexterm"/><a id="iddle2504" class="indexterm"/><a id="iddle2716" class="indexterm"/><a id="iddle2840" class="indexterm"/><a id="iddle2841" class="indexterm"/><a id="iddle2842" class="indexterm"/><a id="iddle2843" class="indexterm"/><a id="iddle3635" class="indexterm"/><a id="iddle3639" class="indexterm"/><a id="iddle3640" class="indexterm"/><a id="iddle3736" class="indexterm"/><a id="iddle3793" class="indexterm"/><a id="iddle3876" class="indexterm"/><a id="iddle3877" class="indexterm"/><a id="iddle3878" class="indexterm"/><a id="iddle3879" class="indexterm"/><a id="iddle4102" class="indexterm"/><a id="iddle4988" class="indexterm"/><a id="iddle4989" class="indexterm"/><a id="iddle4990" class="indexterm"/><code class="literal">LazyInitRace</code> has race conditions that can undermine its correctness. Say that threads <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span> execute <code class="literal">getInstance</code> at the same time. <span class="emphasis"><em>A</em></span> sees that <code class="literal">instance</code> is <code class="literal">null</code>, and instantiates a new <code class="literal">ExpensiveObject</code>. <span class="emphasis"><em>B</em></span> also checks if <code class="literal">instance</code> is <code class="literal">null</code>. Whether <code class="literal">instance</code> is <code class="literal">null</code> at this point depends unpredictably on timing, including the vagaries of scheduling and how long <span class="emphasis"><em>A</em></span> takes to instantiate the <code class="literal">ExpensiveObject</code> and set the <code class="literal">instance</code> field. If <code class="literal">instance</code> is <code class="literal">null</code> when <span class="emphasis"><em>B</em></span> examines it, the two callers to <code class="literal">getInstance</code> may receive two different results, even though <code class="literal">getInstance</code> is always supposed to return the same instance.</p>
<p>The hit-counting operation in <code class="literal">UnsafeCountingFactorizer</code> has another sort of race condition. Read-modify-write operations, like incrementing a counter, define a transformation of an object’s state in terms of its previous state. To increment a counter, you have to know its previous value <span class="emphasis"><em>and</em></span> make sure no one else changes or uses that value while you are in mid-update.</p>
<p>Like most concurrency errors, race conditions don’t <span class="emphasis"><em>always</em></span> result in failure: some unlucky timing is also required. But race conditions can cause serious problems. If <code class="literal">LazyInitRace</code> is used to instantiate an application-wide registry, having it return different instances from multiple invocations could cause registrations to be lost or multiple activities to have inconsistent views of the set of registered objects. If <code class="literal">UnsafeSequence</code> is used to generate entity identifiers in a persistence framework, two distinct objects could end up with the same ID, violating identity integrity constraints.</p>
</div>
<div class="section" title="Compound Actions"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lev2sec4"/>Compound Actions</h3></div></div></div>

<p>Both <code class="literal">LazyInitRace</code> and <code class="literal">UnsafeCountingFactorizer</code> contained a sequence of operations that needed to be <span class="emphasis"><em>atomic</em></span>, or indivisible, relative to other operations on the same state. To avoid race conditions, there must be a way to prevent other threads from using a variable while we’re in the middle of modifying it, so we can ensure that other threads can observe or modify the state only before we start or after we finish, but not in the middle.</p>
<div class="sidebar"><a id="ch02sb06"/><p class="title"><b/></p>
<p>Operations <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span> are <span class="emphasis"><em>atomic</em></span> with respect to each other if, from the perspective of a thread executing <span class="emphasis"><em>A</em></span>, when another thread executes <span class="emphasis"><em>B</em></span>, either all of <span class="emphasis"><em>B</em></span> has executed or none of it has. An <span class="emphasis"><em>atomic operation</em></span> is one that is atomic with respect to all operations, including itself, that operate on the same state.</p>
</div>
<p>If the increment operation in <code class="literal">UnsafeSequence</code> were atomic, the race condition illustrated in <a class="link" href="ch01s03.html#ch01fig01" title="Figure 1.1. Unlucky Execution of UnsafeSequence.getNext.">Figure 1.1</a> on page <a class="link" href="ch01s03.html#ch01list01" title="Example 1.1. Non-thread-safe Sequence Generator.">6</a> could not occur, and each execution of the increment operation would have the desired effect of incrementing the counter by exactly one. To ensure thread safety, check-then-act operations (like lazy initialization) and read-modify-write operations (like increment) must always be atomic. We refer collectively to check-then-act and read-modify-write sequences as <span class="emphasis"><em>compound actions</em></span>: sequences of operations that must be executed atomically in order to remain thread-safe. In the next section, we’ll consider <span class="emphasis"><em>locking</em></span>, Java’s builtin mechanism for ensuring atomicity. For now, we’re going to fix the problem <a id="iddle2027" class="indexterm"/><a id="iddle2105" class="indexterm"/><a id="iddle2589" class="indexterm"/><a id="iddle3156" class="indexterm"/><a id="iddle3157" class="indexterm"/><a id="iddle4207" class="indexterm"/><a id="iddle4399" class="indexterm"/><a id="iddle4420" class="indexterm"/><a id="iddle4739" class="indexterm"/>another way, by using an existing thread-safe class, as shown in <code class="literal">CountingFactorizer</code> in <a class="link" href="ch02s02.html#ch02list04" title="Example 2.4. Servlet that Counts Requests Using AtomicLong.">Listing 2.4</a>.</p>
<div class="example"><a id="ch02list04"/><p class="title"><b>Example 2.4. Servlet that Counts Requests Using <code class="literal">AtomicLong</code>.</b></p><div class="example-contents">

<pre class="programlisting">@ThreadSafe
public class CountingFactorizer implements Servlet {
    private final <span class="strong"><strong>AtomicLong count = new AtomicLong(0);</strong></span>

    public long getCount() { return <span class="strong"><strong>count.get();</strong></span> }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        <span class="strong"><strong>count.incrementAndGet();</strong></span>
        encodeIntoResponse(resp, factors);
    }
}
</pre>
</div></div><br class="example-break"/>
<p>The <code class="literal">java.util.concurrent.atomic</code> package contains <span class="emphasis"><em>atomic variable</em></span> classes for effecting atomic state transitions on numbers and object references. By replacing the <code class="literal">long</code> counter with an <code class="literal">AtomicLong</code>, we ensure that all actions that access the counter state are atomic. <sup>[<a id="ch02fn05" href="#ftn.ch02fn05" class="footnote">5</a>]</sup> Because the state of the servlet <span class="emphasis"><em>is</em></span> the state of the counter and the counter is thread-safe, our servlet is once again thread-safe.</p>
<p>We were able to add a counter to our factoring servlet and maintain thread safety by using an existing thread-safe class to manage the counter state, <code class="literal">AtomicLong</code>. When a <span class="emphasis"><em>single</em></span> element of state is added to a stateless class, the resulting class will be thread-safe if the state is entirely managed by a thread-safe object. But, as we’ll see in the next section, going from one state variable to more than one is not necessarily as simple as going from zero to one.</p>
<div class="sidebar"><a id="ch02sb07"/><p class="title"><b/></p>
<p>Where practical, use existing thread-safe objects, like <code class="literal">AtomicLong</code>, to manage your class’s state. It is simpler to reason about the possible states and state transitions for existing thread-safe objects than it is for arbitrary state variables, and this makes it easier to maintain and verify thread safety.</p>
</div>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch02fn03" href="#ch02fn03" class="para">3</a>] </sup>The approach taken by <code class="literal">UnsafeSequence</code> and <code class="literal">UnsafeCountingFactorizer</code> has other serious problems, including the possibility of stale data (<a class="link" href="ch03.html#ch03lev2sec1" title="Stale Data">Section 3.1.1</a>).</p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn04" href="#ch02fn04" class="para">4</a>] </sup>The term <span class="emphasis"><em>race condition</em></span> is often confused with the related term <span class="emphasis"><em>data race</em></span>, which arises when synchronization is not used to coordinate all access to a shared nonfinal field. You risk a data race whenever a thread writes a variable that might next be read by another thread or reads a variable that might have last been written by another thread if both threads do not use synchronization; code with data races has no useful defined semantics under the Java Memory Model. Not all race conditions are data races, and not all data races are race conditions, but they both can cause concurrent programs to fail in unpredictable ways. <code class="literal">UnsafeCountingFactorizer</code> has both race conditions and data races. See <a class="link" href="ch16.html" title="Chapter 16. The Java Memory Model">Chapter 16</a> for more on data races.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn05" href="#ch02fn05" class="para">5</a>] </sup><code class="literal">CountingFactorizer</code> calls <code class="literal">incrementAndGet</code> to increment the counter, which also returns the incremented value; in this case the return value is ignored.</p></div></div></div></body></html>
