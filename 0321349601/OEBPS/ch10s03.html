<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Other Liveness Hazards</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Other Liveness Hazards"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lev1sec3"/>Other Liveness Hazards</h2></div></div></div>


<p><a id="iddle1649" class="indexterm"/><a id="iddle2330" class="indexterm"/><a id="iddle2331" class="indexterm"/><a id="iddle2585" class="indexterm"/><a id="iddle2586" class="indexterm"/><a id="iddle2889" class="indexterm"/><a id="iddle3660" class="indexterm"/><a id="iddle3661" class="indexterm"/><a id="iddle4095" class="indexterm"/><a id="iddle4131" class="indexterm"/><a id="iddle4132" class="indexterm"/><a id="iddle4367" class="indexterm"/><a id="iddle4368" class="indexterm"/><a id="iddle4369" class="indexterm"/><a id="iddle4370" class="indexterm"/><a id="iddle4371" class="indexterm"/><a id="iddle4806" class="indexterm"/><a id="iddle4807" class="indexterm"/>While deadlock is the most widely encountered liveness hazard, there are several other liveness hazards you may encounter in concurrent programs including starvation, missed signals, and livelock. (Missed signals are covered in <a class="link" href="ch14s02.html#ch14lev2sec4" title="The Condition Predicate">Section 14.2.3</a>.)</p>
<div class="section" title="Starvation"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lev2sec8"/>Starvation</h3></div></div></div>

<p><span class="emphasis"><em>Starvation</em></span> occurs when a thread is perpetually denied access to resources it needs in order to make progress; the most commonly starved resource is CPU cycles. Starvation in Java applications can be caused by inappropriate use of thread priorities. It can also be caused by executing nonterminating constructs (infinite loops or resource waits that do not terminate) with a lock held, since other threads that need that lock will never be able to acquire it.</p>
<p>The thread priorities defined in the Thread API are merely scheduling hints. The Thread API defines ten priority levels that the JVM can map to operating system scheduling priorities as it sees fit. This mapping is platform-specific, so two Java priorities can map to the same OS priority on one system and different OS priorities on another. Some operating systems have fewer than ten priority levels, in which case multiple Java priorities map to the same OS priority.</p>
<p>Operating system schedulers go to great lengths to provide scheduling fairness and liveness beyond that required by the Java Language Specification. In most Java applications, all application threads have the same priority, <code class="literal">Thread. NORM_PRIORITY</code>. The thread priority mechanism is a blunt instrument, and it’s not always obvious what effect changing priorities will have; boosting a thread’s priority might do nothing or might always cause one thread to be scheduled in preference to the other, causing starvation.</p>
<p>It is generally wise to resist the temptation to tweak thread priorities. As soon as you start modifying priorities, the behavior of your application becomes platform-specific and you introduce the risk of starvation. You can often spot a program that is trying to recover from priority tweaking or other responsiveness problems by the presence of <code class="literal">Thread.sleep</code> or <code class="literal">Thread.yield</code> calls in odd places, in an attempt to give more time to lower-priority threads.<sup>[<a id="ch10fn05" href="#ftn.ch10fn05" class="footnote">5</a>]</sup></p>
<div class="sidebar"><a id="ch10sb04"/><p class="title"><b/></p>
<p>Avoid the temptation to use thread priorities, since they increase platform dependence and can cause liveness problems. Most concurrent applications can use the default priority for all threads.</p>
</div>
</div>
<div class="section" title="Poor Responsiveness"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lev2sec9"/>Poor Responsiveness</h3></div></div></div>


<p><a id="iddle2053" class="indexterm"/><a id="iddle2054" class="indexterm"/><a id="iddle2283" class="indexterm"/><a id="iddle2284" class="indexterm"/><a id="iddle3011" class="indexterm"/><a id="iddle3012" class="indexterm"/><a id="iddle3013" class="indexterm"/><a id="iddle3558" class="indexterm"/><a id="iddle3559" class="indexterm"/><a id="iddle3662" class="indexterm"/><a id="iddle3786" class="indexterm"/><a id="iddle3787" class="indexterm"/><a id="iddle3962" class="indexterm"/><a id="iddle3963" class="indexterm"/><a id="iddle3993" class="indexterm"/><a id="iddle3994" class="indexterm"/><a id="iddle4808" class="indexterm"/><a id="iddle4809" class="indexterm"/>One step removed from starvation is poor responsiveness, which is not uncommon in GUI applications using background threads. <a class="link" href="ch09.html" title="Chapter 9. GUI Applications">Chapter 9</a> developed a framework for offloading long-running tasks onto background threads so as not to freeze the user interface. CPU-intensive background tasks can still affect responsiveness because they can compete for CPU cycles with the event thread. This is one case where altering thread priorities makes sense; when computeintensive background computations would affect responsiveness. If the work done by other threads are truly background tasks, lowering their priority can make the foreground tasks more responsive.</p>
<p>Poor responsiveness can also be caused by poor lock management. If a thread holds a lock for a long time (perhaps while iterating a large collection and performing substantial work for each element), other threads that need to access that collection may have to wait a very long time.</p>
</div>
<div class="section" title="Livelock"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lev2sec10"/>Livelock</h3></div></div></div>

<p><span class="emphasis"><em>Livelock</em></span> is a form of liveness failure in which a thread, while not blocked, still cannot make progress because it keeps retrying an operation that will always fail. Livelock often occurs in transactional messaging applications, where the messaging infrastructure rolls back a transaction if a message cannot be processed successfully, and puts it back at the head of the queue. If a bug in the message handler for a particular type of message causes it to fail, every time the message is dequeued and passed to the buggy handler, the transaction is rolled back. Since the message is now back at the head of the queue, the handler is called over and over with the same result. (This is sometimes called the <span class="emphasis"><em>poison message</em></span> problem.) The message handling thread is not blocked, but it will never make progress either. This form of livelock often comes from overeager error-recovery code that mistakenly treats an unrecoverable error as a recoverable one.</p>
<p>Livelock can also occur when multiple cooperating threads change their state in response to the others in such a way that no thread can ever make progress. This is similar to what happens when two overly polite people are walking in opposite directions in a hallway: each steps out of the other’s way, and now they are again in each other’s way. So they both step aside again, and again, and again. . .</p>
<p>The solution for this variety of livelock is to introduce some randomness into the retry mechanism. For example, when two stations in an ethernet network try to send a packet on the shared carrier at the same time, the packets collide. The stations detect the collision, and each tries to send their packet again later. If they each retry <span class="emphasis"><em>exactly</em></span> one second later, they collide over and over, and neither packet ever goes out, even if there is plenty of available bandwidth. To avoid this, we make each wait an amount of time that includes a random component. (The ethernet protocol also includes exponential backoff after repeated collisions, reducing both congestion and the risk of repeated failure with multiple colliding stations.) Retrying with random waits and backoffs can be equally effective for avoiding livelock in concurrent applications.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch10fn05" href="#ch10fn05" class="para">5</a>] </sup>The semantics of <code class="literal">Thread.yield</code> (and <code class="literal">Thread.sleep(0)</code>) are undefined [JLS 17.9]; the JVM is free to implement them as no-ops or treat them as scheduling hints. In particular, they are <span class="emphasis"><em>not</em></span> required to have the semantics of <code class="literal">sleep(0)</code> on Unix systems—put the current thread at the end of the run queue for that priority, yielding to other threads of the same priority—though some JVMs implement <code class="literal">yield</code> in this way.</p></div></div></div></body></html>
