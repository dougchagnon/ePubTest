<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Guarding State with Locks</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Guarding State with Locks"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lev1sec4"/>Guarding State with Locks</h2></div></div></div>

<p>Because locks enable serialized <sup>[<a id="ch02fn08" href="#ftn.ch02fn08" class="footnote">8</a>]</sup> access to the code paths they guard, we can use them to construct protocols for guaranteeing exclusive access to shared state. Following these protocols consistently can ensure state consistency.</p>
<p>Compound actions on shared state, such as incrementing a hit counter (read-modify-write) or lazy initialization (check-then-act), must be made atomic to avoid race conditions. Holding a lock for the <span class="emphasis"><em>entire duration</em></span> of a compound action can make that compound action atomic. However, just wrapping the compound action with a <code class="literal">synchronized</code> block is not sufficient; if synchronization is used to coordinate access to a variable, it is needed <span class="emphasis"><em>everywhere that variable is accessed</em></span>. Further, when using locks to coordinate access to a variable, the <span class="emphasis"><em>same</em></span> lock must be used wherever that variable is accessed.</p>
<p><a id="iddle1095" class="indexterm"/><a id="iddle1178" class="indexterm"/><a id="iddle1326" class="indexterm"/><a id="iddle1327" class="indexterm"/><a id="iddle2035" class="indexterm"/><a id="iddle2036" class="indexterm"/><a id="iddle2364" class="indexterm"/><a id="iddle2475" class="indexterm"/><a id="iddle2476" class="indexterm"/><a id="iddle2595" class="indexterm"/><a id="iddle2836" class="indexterm"/><a id="iddle3112" class="indexterm"/><a id="iddle3130" class="indexterm"/><a id="iddle3131" class="indexterm"/><a id="iddle3367" class="indexterm"/><a id="iddle3368" class="indexterm"/><a id="iddle3595" class="indexterm"/><a id="iddle3710" class="indexterm"/><a id="iddle3711" class="indexterm"/><a id="iddle4569" class="indexterm"/><a id="iddle4940" class="indexterm"/><a id="iddle4941" class="indexterm"/>It is a common mistake to assume that synchronization needs to be used only when <span class="emphasis"><em>writing</em></span> to shared variables; <span class="emphasis"><em>this is simply not true</em></span>. (The reasons for this will become clearer in <a class="link" href="ch03.html#ch03lev1sec1" title="Visibility">Section 3.1</a>.)</p>
<div class="sidebar"><a id="ch02sb09"/><p class="title"><b/></p>
<p>For each mutable state variable that may be accessed by more than one thread, <span class="emphasis"><em>all</em></span> accesses to that variable must be performed with the <span class="emphasis"><em>same</em></span> lock held. In this case, we say that the variable is <span class="emphasis"><em>guarded by</em></span> that lock.</p>
</div>
<p>In <code class="literal">SynchronizedFactorizer</code> in <a class="link" href="ch02s03.html#ch02list06" title="Example 2.6. Servlet that Caches Last Result, But with Unnacceptably Poor Concurrency. Don’t Do this.">Listing 2.6</a>, <code class="literal">lastNumber</code> and <code class="literal">lastFactors</code> are guarded by the servlet object’s intrinsic lock; this is documented by the <code class="literal">@GuardedBy</code> annotation.</p>
<p>There is no inherent relationship between an object’s intrinsic lock and its state; an object’s fields need not be guarded by its intrinsic lock, though this is a perfectly valid locking convention that is used by many classes. Acquiring the lock associated with an object does <span class="emphasis"><em>not</em></span> prevent other threads from accessing that object—the only thing that acquiring a lock prevents any other thread from doing is acquiring that same lock. The fact that every object has a built-in lock is just a convenience so that you needn’t explicitly create lock objects. <sup>[<a id="ch02fn09" href="#ftn.ch02fn09" class="footnote">9</a>]</sup> It is up to you to construct <span class="emphasis"><em>locking protocols</em></span> or <span class="emphasis"><em>synchronization policies</em></span> that let you access shared state safely, and to use them consistently throughout your program.</p>
<div class="sidebar"><a id="ch02sb10"/><p class="title"><b/></p>
<p>Every shared, mutable variable should be guarded by exactly one lock. Make it clear to maintainers which lock that is.</p>
</div>
<p>A common locking convention is to encapsulate all mutable state within an object and to protect it from concurrent access by synchronizing any code path that accesses mutable state using the object’s intrinsic lock. This pattern is used by many thread-safe classes, such as <code class="literal">Vector</code> and other synchronized collection classes. In such cases, all the variables in an object’s state are guarded by the object’s intrinsic lock. However, there is nothing special about this pattern, and neither the compiler nor the runtime enforces this (or any other) pattern of locking. <sup>[<a id="ch02fn10" href="#ftn.ch02fn10" class="footnote">10</a>]</sup> It is also easy to subvert this locking protocol accidentally by adding a new method or code path and forgetting to use synchronization.</p>
<p>Not all data needs to be guarded by locks—only mutable data that will be accessed from multiple threads. In <a class="link" href="ch01.html" title="Chapter 1. Introduction">Chapter 1</a>, we described how adding a simple asynchronous event such as a <code class="literal">TimerTask</code> can create thread safety requirements that ripple throughout your program, especially if your program state is poorly encapsulated. Consider a single-threaded program that processes a large amount of data. Single-threaded programs require no synchronization, because no data is shared across threads. Now imagine you want to add a feature to create periodic <a id="iddle1427" class="indexterm"/><a id="iddle2544" class="indexterm"/><a id="iddle2545" class="indexterm"/><a id="iddle2857" class="indexterm"/><a id="iddle3025" class="indexterm"/><a id="iddle3026" class="indexterm"/><a id="iddle3276" class="indexterm"/><a id="iddle3497" class="indexterm"/><a id="iddle3498" class="indexterm"/><a id="iddle4206" class="indexterm"/><a id="iddle4419" class="indexterm"/><a id="iddle4738" class="indexterm"/>snapshots of its progress, so that it does not have to start again from the beginning if it crashes or must be stopped. You might choose to do this with a <code class="literal">TimerTask</code> that goes off every ten minutes, saving the program state to a file.</p>
<p>Since the <code class="literal">TimerTask</code> will be called from another thread (one managed by <code class="literal">Timer</code>), any data involved in the snapshot is now accessed by two threads: the main program thread and the <code class="literal">Timer</code> thread. This means that not only must the <code class="literal">TimerTask</code> code use synchronization when accessing the program state, but so must any code path in the rest of the program that touches that same data. What used to require no synchronization now requires synchronization throughout the program.</p>
<p>When a variable is guarded by a lock—meaning that <span class="emphasis"><em>every</em></span> access to that variable is performed with that lock held—you’ve ensured that only one thread at a time can access that variable. When a class has invariants that involve more than one state variable, there is an additional requirement: each variable participating in the invariant must be guarded by the <span class="emphasis"><em>same</em></span> lock. This allows you to access or update them in a single atomic operation, preserving the invariant. <code class="literal">SynchronizedFactorizer</code> demonstrates this rule: both the cached number and the cached factors are guarded by the servlet object’s intrinsic lock.</p>
<div class="sidebar"><a id="ch02sb11"/><p class="title"><b/></p>
<p>For every invariant that involves more than one variable, <span class="emphasis"><em>all</em></span> the variables involved in that invariant must be guarded by the <span class="emphasis"><em>same</em></span> lock.</p>
</div>
<p>If synchronization is the cure for race conditions, why not just declare every method <code class="literal">synchronized</code>? It turns out that such indiscriminate application of <code class="literal">synchronized</code> might be either too much or too little synchronization. Merely synchronizing every method, as <code class="literal">Vector</code> does, is not enough to render compound actions on a <code class="literal">Vector</code> atomic:</p>
<div class="informalexample">
<pre class="programlisting">if (!vector.contains(element))
    vector.add(element);
</pre>
</div>
<p class="continued">This attempt at a put-if-absent operation has a race condition, even though both <code class="literal">contains</code> and <code class="literal">add</code> are atomic. While synchronized methods can make individual operations atomic, additional locking is requiredwhen multiple operations are combined into a compound action. (See <a class="link" href="ch04s04.html" title="Adding Functionality to Existing Thread-safe Classes">Section 4.4</a> for some techniques for safely adding additional atomic operations to thread-safe objects.) At the same time, synchronizing every method can lead to liveness or performance problems, as we saw in <code class="literal">SynchronizedFactorizer</code>.</p>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch02fn08" href="#ch02fn08" class="para">8</a>] </sup>Serializing access to an object has nothing to do with object serialization (turning an object into a byte stream); serializing access means that threads take turns accessing the object exclusively, rather than doing so concurrently.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn09" href="#ch02fn09" class="para">9</a>] </sup>In retrospect, this design decision was probably a bad one: not only can it be confusing, but it forces JVM implementors to make tradeoffs between object size and locking performance.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn10" href="#ch02fn10" class="para">10</a>] </sup>Code auditing tools like FindBugs can identify when a variable is frequently but not always accessed with a lock held, which may indicate a bug.</p></div></div></div></body></html>
