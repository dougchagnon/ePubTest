<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 6. Task Execution</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="chapter" title="Chapter 6. Task Execution"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Task Execution</h1></div></div></div>




<p><a id="iddle1042" class="indexterm"/><a id="iddle1045" class="indexterm"/><a id="iddle1112" class="indexterm"/><a id="iddle1113" class="indexterm"/><a id="iddle1198" class="indexterm"/><a id="iddle1199" class="indexterm"/><a id="iddle1255" class="indexterm"/><a id="iddle1357" class="indexterm"/><a id="iddle1358" class="indexterm"/><a id="iddle1455" class="indexterm"/><a id="iddle1841" class="indexterm"/><a id="iddle1847" class="indexterm"/><a id="iddle1880" class="indexterm"/><a id="iddle1884" class="indexterm"/><a id="iddle1885" class="indexterm"/><a id="iddle1925" class="indexterm"/><a id="iddle1926" class="indexterm"/><a id="iddle2249" class="indexterm"/><a id="iddle2307" class="indexterm"/><a id="iddle2308" class="indexterm"/><a id="iddle2381" class="indexterm"/><a id="iddle2382" class="indexterm"/><a id="iddle2461" class="indexterm"/><a id="iddle2731" class="indexterm"/><a id="iddle2732" class="indexterm"/><a id="iddle3458" class="indexterm"/><a id="iddle3583" class="indexterm"/><a id="iddle3864" class="indexterm"/><a id="iddle3865" class="indexterm"/><a id="iddle3967" class="indexterm"/><a id="iddle3968" class="indexterm"/><a id="iddle3983" class="indexterm"/><a id="iddle3984" class="indexterm"/><a id="iddle4191" class="indexterm"/><a id="iddle4274" class="indexterm"/><a id="iddle4275" class="indexterm"/><a id="iddle4317" class="indexterm"/><a id="iddle4318" class="indexterm"/><a id="iddle4394" class="indexterm"/><a id="iddle4601" class="indexterm"/><a id="iddle4602" class="indexterm"/><a id="iddle4603" class="indexterm"/><a id="iddle4606" class="indexterm"/><a id="iddle4618" class="indexterm"/><a id="iddle4619" class="indexterm"/><a id="iddle4622" class="indexterm"/><a id="iddle4829" class="indexterm"/><a id="iddle4830" class="indexterm"/><a id="iddle4874" class="indexterm"/><a id="iddle4875" class="indexterm"/><a id="iddle5165" class="indexterm"/>Most concurrent applications are organized around the execution of <span class="emphasis"><em>tasks</em></span>: abstract, discrete units of work. Dividing the work of an application into tasks simplifies program organization, facilitates error recovery by providing natural transaction boundaries, and promotes concurrency by providing a natural structure for parallelizing work.</p>



<div class="section" title="Executing Tasks in Threads"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lev1sec1"/>Executing Tasks in Threads</h2></div></div></div>

<p>The first step in organizing a program around task execution is identifying sensible <span class="emphasis"><em>task boundaries</em></span>. Ideally, tasks are <span class="emphasis"><em>independent</em></span> activities: work that doesn’t depend on the state, result, or side effects of other tasks. Independence facilitates concurrency, as independent tasks can be executed in parallel if there are adequate processing resources. For greater flexibility in scheduling and load balancing tasks, each task should also represent a small fraction of your application’s processing capacity.</p>
<p>Server applications should exhibit both <span class="emphasis"><em>good throughput</em></span> and <span class="emphasis"><em>good responsiveness</em></span> under normal load. Application providers want applications to support as many users as possible, so as to reduce provisioning costs per user; users want to get their response quickly. Further, applications should exhibit <span class="emphasis"><em>graceful degradation</em></span> as they become overloaded, rather than simply falling over under heavy load. Choosing good task boundaries, coupled with a sensible <span class="emphasis"><em>task execution policy</em></span> (see <a class="link" href="ch06s02.html#ch06lev2sec5" title="Execution Policies">Section 6.2.2</a>), can help achieve these goals.</p>
<p>Most server applications offer a natural choice of task boundary: individual client requests. Web servers, mail servers, file servers, EJB containers, and database servers all accept requests via network connections from remote clients. Using individual requests as task boundaries usually offers both independence and appropriate task sizing. For example, the result of submitting a message to a mail server is not affected by the other messages being processed at the same time, and handling a single message usually requires a very small percentage of the server’s total capacity.</p>
<div class="section" title="Executing Tasks Sequentially"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lev2sec1"/>Executing Tasks Sequentially</h3></div></div></div>


<p><a id="iddle2180" class="indexterm"/><a id="iddle2251" class="indexterm"/><a id="iddle2488" class="indexterm"/><a id="iddle2489" class="indexterm"/><a id="iddle2679" class="indexterm"/><a id="iddle2680" class="indexterm"/><a id="iddle3589" class="indexterm"/><a id="iddle3590" class="indexterm"/><a id="iddle3596" class="indexterm"/><a id="iddle3597" class="indexterm"/><a id="iddle3926" class="indexterm"/><a id="iddle3969" class="indexterm"/><a id="iddle4096" class="indexterm"/><a id="iddle4097" class="indexterm"/><a id="iddle4163" class="indexterm"/><a id="iddle4164" class="indexterm"/><a id="iddle4169" class="indexterm"/><a id="iddle4301" class="indexterm"/><a id="iddle4302" class="indexterm"/><a id="iddle4623" class="indexterm"/><a id="iddle4820" class="indexterm"/><a id="iddle4821" class="indexterm"/><a id="iddle4876" class="indexterm"/><a id="iddle4877" class="indexterm"/>There are a number of possible policies for scheduling tasks within an application, some of which exploit the potential for concurrency better than others. The simplest is to execute tasks sequentially in a single thread. <code class="literal">SingleThreadWeb-Server</code> in <a class="link" href="ch06.html#ch06list01" title="Example 6.1. Sequential Web Server.">Listing 6.1</a> processes its tasks—HTTP requests arriving on port 80—sequentially. The details of the request processing aren’t important; we’re interested in characterizing the concurrency of various scheduling policies.</p>
<div class="example"><a id="ch06list01"/><p class="title"><b>Example 6.1. Sequential Web Server.</b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face1.jpg" width="45" alt="Sequential Web Server."/></div>
<pre class="programlisting">class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }
}
</pre>
</div></div><br class="example-break"/>
<p><code class="literal">SingleThreadedWebServer</code> is simple and theoretically correct, but would perform poorly in production because it can handle only one request at a time. The main thread alternates between accepting connections and processing the associated request. While the server is handling a request, new connections must wait until it finishes the current request and calls <code class="literal">accept</code> again. This might work if request processing were so fast that <code class="literal">handleRequest</code> effectively returned immediately, but this doesn’t describe any web server in the real world.</p>
<p>Processing a web request involves a mix of computation and I/O. The server must perform socket I/O to read the request and write the response, which can block due to network congestion or connectivity problems. It may also perform file I/O or make database requests, which can also block. In a single-threaded server, blocking not only delays completing the current request, but prevents pending requests from being processed at all. If one request blocks for an unusually long time, users might think the server is unavailable because it appears unresponsive. At the same time, resource utilization is poor, since the CPU sits idle while the single thread waits for its I/O to complete.</p>
<p>In server applications, sequential processing rarely provides either good throughput or good responsiveness. There are exceptions—such as when tasks are few and long-lived, or when the server serves a single client that makes only a single request at a time—but most server applications do not work this way.<sup>[<a id="ch06fn01" href="#ftn.ch06fn01" class="footnote">1</a>]</sup></p>
</div>
<div class="section" title="Explicitly Creating Threads for Tasks"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lev2sec2"/>Explicitly Creating Threads for Tasks</h3></div></div></div>


<p><a id="iddle1730" class="indexterm"/><a id="iddle2203" class="indexterm"/><a id="iddle3459" class="indexterm"/><a id="iddle3600" class="indexterm"/><a id="iddle4098" class="indexterm"/><a id="iddle4624" class="indexterm"/><a id="iddle4650" class="indexterm"/><a id="iddle4651" class="indexterm"/><a id="iddle4764" class="indexterm"/><a id="iddle4831" class="indexterm"/>A more responsive approach is to create a new thread for servicing each request, as shown in <code class="literal">ThreadPerTaskWebServer</code> in <a class="link" href="ch06.html#ch06list02" title="Example 6.2. Web Server that Starts a New Thread for Each Request.">Listing 6.2</a>.</p>
<div class="example"><a id="ch06list02"/><p class="title"><b>Example 6.2. Web Server that Starts a New Thread for Each Request.</b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face1.jpg" width="45" alt="Web Server that Starts a New Thread for Each Request."/></div>
<pre class="programlisting">class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            <span class="strong"><strong>final</strong></span>  Socket connection = socket.accept();
            Runnable task = new Runnable() {
                    public void run() {
                        <span class="strong"><strong>handleRequest(connection);</strong></span>
                    }
                };
            <span class="strong"><strong>new Thread(task).start();</strong></span>
        }
    }
}
</pre>
</div></div><br class="example-break"/>
<p><code class="literal">ThreadPerTaskWebServer</code> is similar in structure to the single-threaded version—the main thread still alternates between accepting an incoming connection and dispatching the request. The difference is that for each connection, the main loop creates a new thread to process the request instead of processing it within the main thread. This has three main consequences:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Task processing is offloaded from the main thread, enabling the main loop to resume waiting for the next incoming connection more quickly. This enables new connections to be accepted before previous requests complete, improving responsiveness.</p></li><li class="listitem"><p>Tasks can be processed in parallel, enabling multiple requests to be serviced simultaneously. This may improve throughput if there are multiple processors, or if tasks need to block for any reason such as I/O completion, lock acquisition, or resource availability.</p></li><li class="listitem"><p>Task-handling code must be thread-safe, because it may be invoked concurrently for multiple tasks.</p></li></ul></div>
<p>Under light to moderate load, the thread-per-task approach is an improvement over sequential execution. As long as the request arrival rate does not exceed the server’s capacity to handle requests, this approach offers better responsiveness and throughput.</p>
</div>
<div class="section" title="Disadvantages of Unbounded Thread Creation"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lev2sec3"/>Disadvantages of Unbounded Thread Creation</h3></div></div></div>


<p><a id="iddle1125" class="indexterm"/><a id="iddle1126" class="indexterm"/><a id="iddle1563" class="indexterm"/><a id="iddle1564" class="indexterm"/><a id="iddle1732" class="indexterm"/><a id="iddle1765" class="indexterm"/><a id="iddle1766" class="indexterm"/><a id="iddle1767" class="indexterm"/><a id="iddle1768" class="indexterm"/><a id="iddle1769" class="indexterm"/><a id="iddle1836" class="indexterm"/><a id="iddle2981" class="indexterm"/><a id="iddle2982" class="indexterm"/><a id="iddle3199" class="indexterm"/><a id="iddle3420" class="indexterm"/><a id="iddle3421" class="indexterm"/><a id="iddle3491" class="indexterm"/><a id="iddle3492" class="indexterm"/><a id="iddle3749" class="indexterm"/><a id="iddle3910" class="indexterm"/><a id="iddle3911" class="indexterm"/><a id="iddle3931" class="indexterm"/><a id="iddle4353" class="indexterm"/><a id="iddle4354" class="indexterm"/><a id="iddle4355" class="indexterm"/><a id="iddle4765" class="indexterm"/><a id="iddle47861" class="indexterm"/><a id="iddle4786" class="indexterm"/><a id="iddle4787" class="indexterm"/><a id="iddle4832" class="indexterm"/><a id="iddle4838" class="indexterm"/><a id="iddle4997" class="indexterm"/><a id="iddle4998" class="indexterm"/><a id="iddle5154" class="indexterm"/>For production use, however, the thread-per-task approach has some practical drawbacks, especially when a large number of threads may be created:</p>
<p title="Thread lifecycle overhead."><b><span class="strong"><strong>Thread lifecycle overhead.</strong></span> </b>Thread creation and teardown are not free. The actual overhead varies across platforms, but thread creation takes time, introducing latency into request processing, and requires some processing activity by the JVM and OS. If requests are frequent and lightweight, as in most server applications, creating a new thread for each request can consume significant computing resources.</p>
<p title="Resource consumption."><b><span class="strong"><strong>Resource consumption.</strong></span> </b>Active threads consume system resources, especially memory. When there are more runnable threads than available processors, threads sit idle. Having many idle threads can tie up a lot of memory, putting pressure on the garbage collector, and having many threads competing for the CPUs can impose other performance costs as well. If you have enough threads to keep all the CPUs busy, creating more threads won’t help and may even hurt.</p>
<p title="Stability."><b><span class="strong"><strong>Stability.</strong></span> </b>There is a limit on how many threads can be created. The limit varies by platform and is affected by factors including JVM invocation parameters, the requested stack size in the <code class="literal">Thread</code> constructor, and limits on threads placed by the underlying operating system.<sup>[<a id="ch06fn02" href="#ftn.ch06fn02" class="footnote">2</a>]</sup> When you hit this limit, the most likely result is an <code class="literal">OutOfMemoryError</code>. Trying to recover from such an error is very risky; it is far easier to structure your program to avoid hitting this limit.</p>
<p>Up to a certain point, more threads can improve throughput, but beyond that point creating more threads just slows down your application, and creating one thread too many can cause your entire application to crash horribly. The way to stay out of danger is to place some bound on how many threads your application creates, and to test your application thoroughly to ensure that, even when this bound is reached, it does not run out of resources.</p>
<p>The problem with the thread-per-task approach is that nothing places any limit on the number of threads created except the rate at which remote users can throw HTTP requests at it. Like other concurrency hazards, unbounded thread creation may <span class="emphasis"><em>appear</em></span> to work just fine during prototyping and development, with problems surfacing only when the application is deployed and under heavy load. So a malicious user, or enough ordinary users, can make your web server crash if the traffic load ever reaches a certain threshold. For a server application that is supposed to provide high availability and graceful degradation under load, this is a serious failing.</p>
</div>
</div>







<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch06fn01" href="#ch06fn01" class="para">1</a>] </sup>In some situations, sequential processing may offer a simplicity or safety advantage; most GUI frameworks process tasks sequentially using a single thread. We return to the sequential model in <a class="link" href="ch09.html" title="Chapter 9. GUI Applications">Chapter 9</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch06fn02" href="#ch06fn02" class="para">2</a>] </sup>On 32-bit machines, a major limiting factor is address space for thread stacks. Each thread maintains two execution stacks, one for Java code and one for native code. Typical JVM defaults yield a combined stack size of around half a megabyte. (You can change this with the <code class="literal">-Xss</code> JVM flag or through the <code class="literal">Thread</code> constructor.) If you divide the per-thread stack size into 2<sup>32</sup>, you get a limit of a few thousands or tens of thousands of threads. Other factors, such as OS limitations, may impose stricter limits.</p></div></div></div></body></html>
