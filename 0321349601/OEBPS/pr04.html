<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Preface</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="preface" title="Preface"><div class="titlepage"><div><div><h1 class="title"><a id="pref03"/>Preface</h1></div></div></div>


<p>At this writing, multicore processors are just now becoming inexpensive enough for midrange desktop systems. Not coincidentally, many development teams are noticing more and more threading-related bug reports in their projects. In a recent post on the NetBeans developer site, one of the core maintainers observed that a single class had been patched over 14 times to fix threading-related problems. Dion Almaer, former editor of TheServerSide, recently blogged (after a painful debugging session that ultimately revealed a threading bug) that most Java programs are so rife with concurrency bugs that they work only “by accident”.</p>
<p>Indeed, developing, testing and debugging multithreaded programs can be extremely difficult because concurrency bugs do not manifest themselves predictably. And when they do surface, it is often at the worst possible time—in production, under heavy load.</p>
<p>One of the challenges of developing concurrent programs in Java is the mismatch between the concurrency features offered by the platform and how developers need to think about concurrency in their programs. The language provides low-level <span class="emphasis"><em>mechanisms</em></span> such as synchronization and condition waits, but these mechanisms must be used consistently to implement application-level protocols or <span class="emphasis"><em>policies</em></span>. Without such policies, it is all too easy to create programs that compile and appear to work but are nevertheless broken. Many otherwise excellent books on concurrency fall short of their goal by focusing excessively on low-level mechanisms and APIs rather than design-level policies and patterns.</p>
<p>Java 5.0 is a huge step forward for the development of concurrent applications in Java, providing new higher-level components and additional low-level mechanisms that make it easier for novices and experts alike to build concurrent applications. The authors are the primary members of the JCP Expert Group that created these facilities; in addition to describing their behavior and features, we present the underlying design patterns and anticipated usage scenarios that motivated their inclusion in the platform libraries.</p>
<p>Our goal is to give readers a set of design rules and mental models that make it easier—and more fun—to build correct, performant concurrent classes and applications in Java.</p>
<p>We hope you enjoy <span class="emphasis"><em>Java Concurrency in Practice</em></span>.</p>
<p>Brian GoetzWilliston, VT<span class="emphasis"><em>March 2006</em></span></p>
<div class="section" title="How to Use this Book"><div class="titlepage"><div><div><h2 class="title"><a id="pref03lev1sec1"/>How to Use this Book</h2></div></div></div>


<p>To address the abstraction mismatch between Java’s low-level mechanisms and the necessary design-level policies, we present a <span class="emphasis"><em>simplified</em></span> set of rules for writing concurrent programs. Experts may look at these rules and say “Hmm, that’s not entirely true: class <span class="emphasis"><em>C</em></span> is thread-safe even though it violates rule <span class="emphasis"><em>R</em></span>.” While it is possible to write correct programs that break our rules, doing so requires a deep understanding of the low-level details of the Java Memory Model, and we want developers to be able to write correct concurrent programs <span class="emphasis"><em>without</em></span> having to master these details. Consistently following our simplified rules will produce correct and maintainable concurrent programs.</p>
<p>We assume the reader already has some familiarity with the basic mechanisms for concurrency in Java. <span class="emphasis"><em>Java Concurrency in Practice</em></span> is not an introduction to concurrency—for that, see the threading chapter of any decent introductory volume, such as <span class="emphasis"><em>The Java Programming Language</em></span> (<a class="link" href="bi01.html#biblio01_001">Arnold et al., 2005</a>). Nor is it an encyclopedic reference for All Things Concurrency—for that, see <span class="emphasis"><em>Concurrent Programming in Java</em></span> (<a class="link" href="bi01.html#biblio01_021">Lea, 2000</a>). Rather, it offers practical design rules to assist developers in the difficult process of creating safe and performant concurrent classes. Where appropriate, we cross-reference relevant sections of <span class="emphasis"><em>The Java Programming Language</em></span>, <span class="emphasis"><em>Concurrent Programming in Java</em></span>, <span class="emphasis"><em>The Java Language Specification</em></span> (<a class="link" href="bi01.html#biblio01_001">Gosling et al., 2005</a>), and <span class="emphasis"><em>Effective Java</em></span> (<a class="link" href="bi01.html#biblio01_003">Bloch, 2001</a>) using the conventions [JPL n.m], [CPJ n.m], [JLS n.m], and [EJ Item n].</p>
<p>After the introduction (<a class="link" href="ch01.html" title="Chapter 1. Introduction">Chapter 1</a>), the book is divided into four parts:</p>
<p title="Fundamentals."><b><span class="strong"><strong>Fundamentals.</strong></span> </b><a class="link" href="pt01.html" title="Part I. Fundamentals">Part I</a> (<a class="link" href="ch02.html" title="Chapter 2. Thread Safety">Chapters 2</a>-<a class="link" href="ch05.html" title="Chapter 5. Building Blocks">5</a>) focuses on the basic concepts of concurrency and thread safety, and how to compose thread-safe classes out of the concurrent building blocks provided by the class library. A “cheat sheet” summarizing the most important of the rules presented in <a class="link" href="pt01.html" title="Part I. Fundamentals">Part I</a> appears on page 110.</p>
<p><a class="link" href="ch02.html" title="Chapter 2. Thread Safety">Chapters 2</a> (Thread Safety) and <a class="link" href="ch03.html" title="Chapter 3. Sharing Objects">3</a> (Sharing Objects) form the foundation for the book. Nearly all of the rules on avoiding concurrency hazards, constructing thread-safe classes, and verifying thread safety are here. Readers who prefer “practice” to “theory” may be tempted to skip ahead to <a class="link" href="pt02.html" title="Part II. Structuring Concurrent Applications">Part II</a>, but make sure to come back and read <a class="link" href="ch02.html" title="Chapter 2. Thread Safety">Chapters 2</a> and <a class="link" href="ch03.html" title="Chapter 3. Sharing Objects">3</a> before writing any concurrent code!</p>
<p><a class="link" href="ch04.html" title="Chapter 4. Composing Objects">Chapter 4</a> (Composing Objects) covers techniques for composing thread-safe classes into larger thread-safe classes. <a class="link" href="ch05.html" title="Chapter 5. Building Blocks">Chapter 5</a> (Building Blocks) covers the concurrent building blocks—thread-safe collections and synchronizers—provided by the platform libraries.</p>
<p title="Structuring Concurrent Applications."><b><span class="strong"><strong>Structuring Concurrent Applications.</strong></span> </b><a class="link" href="pt02.html" title="Part II. Structuring Concurrent Applications">Part II</a> (<a class="link" href="ch06.html" title="Chapter 6. Task Execution">Chapters 6</a>-<a class="link" href="ch09.html" title="Chapter 9. GUI Applications">9</a>) describes how to exploit threads to improve the throughput or responsiveness of concurrent applications. <a class="link" href="ch06.html" title="Chapter 6. Task Execution">Chapter 6</a> (Task Execution) covers identifying parallelizable tasks and executing them within the task-execution framework. <a class="link" href="ch07.html" title="Chapter 7. Cancellation and Shutdown">Chapter 7</a> (Cancellation and Shutdown) deals with techniques for convincing tasks and threads to terminate before they would normally do so; how programs deal with cancellation and shutdown is often one of the factors that separates truly robust concurrent applications from those that merely work. <a class="link" href="ch08.html" title="Chapter 8. Applying Thread Pools">Chapter 8</a> (Applying Thread Pools) addresses some of the more advanced features of the task-execution framework.</p>
<p><a class="link" href="ch09.html" title="Chapter 9. GUI Applications">Chapter 9</a> (GUI Applications) focuses on techniques for improving responsiveness in single-threaded subsystems.</p>
<p title="Liveness, Performance, and Testing."><b><span class="strong"><strong>Liveness, Performance, and Testing.</strong></span> </b><a class="link" href="pt03.html" title="Part III. Liveness, Performance, and Testing">Part III</a> (<a class="link" href="ch10.html" title="Chapter 10. Avoiding Liveness Hazards">Chapters 10</a>-<a class="link" href="ch12.html" title="Chapter 12. Testing Concurrent Programs">12</a>) concerns itself with ensuring that concurrent programs actually do what you want them to do and do so with acceptable performance. <a class="link" href="ch10.html" title="Chapter 10. Avoiding Liveness Hazards">Chapter 10</a> (Avoiding Liveness Hazards) describes how to avoid liveness failures that can prevent programs from making forward progress. <a class="link" href="ch11.html" title="Chapter 11. Performance and Scalability">Chapter 11</a> (Performance and Scalability) covers techniques for improving the performance and scalability of concurrent code. <a class="link" href="ch12.html" title="Chapter 12. Testing Concurrent Programs">Chapter 12</a> (Testing Concurrent Programs) covers techniques for testing concurrent code for both correctness and performance.</p>
<p title="Advanced Topics."><b><span class="strong"><strong>Advanced Topics.</strong></span> </b><a class="link" href="pt04.html" title="Part IV. Advanced Topics">Part IV</a> (<a class="link" href="ch13.html" title="Chapter 13. Explicit Locks">Chapters 13</a>-<a class="link" href="ch16.html" title="Chapter 16. The Java Memory Model">16</a>) covers topics that are likely to be of interest only to experienced developers: explicit locks, atomic variables, nonblocking algorithms, and developing custom synchronizers.</p>
</div>


</div></body></html>
