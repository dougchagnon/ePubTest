<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Documenting Synchronization Policies</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Documenting Synchronization Policies"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lev1sec5"/>Documenting Synchronization Policies</h2></div></div></div>

<p>Documentation is one of the most powerful (and, sadly, most underutilized) tools for managing thread safety. Users look to the documentation to find out if a class is thread-safe, and maintainers look to the documentation to understand the implementation strategy so they can maintain it without inadvertently compromising safety. Unfortunately, both of these constituencies usually find less information in the documentation than they’d like.</p>
<div class="sidebar"><a id="ch04sb07"/><p class="title"><b/></p>
<p>Document a class’s thread safety guarantees for its clients; document its synchronization policy for its maintainers.</p>
</div>
<p><a id="iddle1097" class="indexterm"/><a id="iddle2482" class="indexterm"/>Each use of <code class="literal">synchronized</code>, <code class="literal">volatile</code>, or any thread-safe class reflects a <span class="emphasis"><em>synchronization policy</em></span> defining a strategy for ensuring the integrity of data in the face of concurrent access. That policy is an element of your program’s design, and should be documented. Of course, the best time to document design decisions is at design time. Weeks or months later, the details may be a blur—so write it down before you forget.</p>
<p>Crafting a synchronization policy requires a number of decisions: which variables to make <code class="literal">volatile</code>, which variables to guard with locks, which lock(s) guard which variables, which variables to make immutable or confine to a thread, which operations must be atomic, etc. Some of these are strictly implementation details and should be documented for the sake of future maintainers, but some affect the publicly observable locking behavior of your class and should be documented as part of its specification.</p>
<p>At the very least, document the thread safety guarantees made by a class. Is it thread-safe? Does it make callbacks with a lock held? Are there any specific locks that affect its behavior? Don’t force clients to make risky guesses. If you don’t want to commit to supporting client-side locking, that’s fine, but say so. If you want clients to be able to create new atomic operations on your class, as we did in <a class="link" href="ch04s04.html" title="Adding Functionality to Existing Thread-safe Classes">Section 4.4</a>, you need to document which locks they should acquire to do so safely. If you use locks to guard state, document this for future maintainers, because it’s so easy—the <code class="literal">@GuardedBy</code> annotation will do the trick. If you use more subtle means to maintain thread safety, document them because they may not be obvious to maintainers.</p>
<p>The current state of affairs in thread safety documentation, even in the platform library classes, is not encouraging. How many times have you looked at the Javadoc for a class and wondered whether it was thread-safe?<sup>[<a id="ch04fn08" href="#ftn.ch04fn08" class="footnote">8</a>]</sup> Most classes don’t offer any clue either way. Many official Java technology specifications, such as servlets and JDBC, woefully underdocument their thread safety promises and requirements.</p>
<p>While prudence suggests that we not assume behaviors that aren’t part of the specification, we have work to get done, and we are often faced with a choice of bad assumptions. Should we assume an object is thread-safe because it seems that it ought to be? Should we assume that access to an object can be made thread-safe by acquiring its lock first? (This risky technique works only if we control <span class="emphasis"><em>all</em></span> the code that accesses that object; otherwise, it provides only the illusion of thread safety.) Neither choice is very satisfying.</p>
<p>To make matters worse, our intuition may often be wrong on which classes are “probably thread-safe” and which are not. As an example, <code class="literal">java.text.SimpleDateFormat</code> isn’t thread-safe, but the Javadoc neglected to mention this until JDK 1.4. That this particular class isn’t thread-safe comes as a surprise to many developers. How many programs mistakenly create a shared instance of a nonthread-safe object and used it from multiple threads, unaware that this might cause erroneous results under heavy load?</p>
<p>The problem with <code class="literal">SimpleDateFormat</code> could be avoided by not assuming a class is thread-safe if it doesn’t say so. On the other hand, it is impossible to develop a servlet-based application without making some pretty questionable assumptions about the thread safety of container-provided objects like <code class="literal">HttpSession</code>. Don’t make your customers or colleagues have to make guesses like this.</p>
<div class="section" title="Interpreting Vague Documentation"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lev2sec13"/>Interpreting Vague Documentation</h3></div></div></div>

<p>Many Java technology specifications are silent, or at least unforthcoming, about thread safety guarantees and requirements for interfaces such as <code class="literal">ServletContext</code>, <code class="literal">HttpSession</code>, or <code class="literal">DataSource</code>.<sup>[<a id="ch04fn09" href="#ftn.ch04fn09" class="footnote">9</a>]</sup> Since these interfaces are implemented by your container or database vendor, you often can’t look at the code to see what it does. Besides, you don’t want to rely on the implementation details of one particular JDBC driver—you want to be compliant with the standard so your code works properly with any JDBC driver. But the words “thread” and “concurrent” do not appear at all in the JDBC specification, and appear frustratingly rarely in the servlet specification. So what do you do?</p>
<p>You are going to have to guess. One way to improve the quality of your guess is to interpret the specification from the perspective of someone who will <span class="emphasis"><em>implement</em></span> it (such as a container or database vendor), as opposed to someone who will merely use it. Servlets are always called from a container-managed thread, and it is safe to assume that if there is more than one such thread, the container knows this. The servlet container makes available certain objects that provide service to multiple servlets, such as <code class="literal">HttpSession</code> or <code class="literal">ServletContext</code>. So the servlet container should expect to have these objects accessed concurrently, since it has created multiple threads and called methods like <code class="literal">Servlet.service</code> from them that could reasonably be expected to access the <code class="literal">ServletContext</code>.</p>
<p>Since it is impossible to imagine a single-threaded context in which these objects would be useful, one has to assume that they have been made thread-safe, even though the specification does not explicitly require this. Besides, if they required client-side locking, on what lock should the client code synchronize? The documentation doesn’t say, and it seems absurd to guess. This “reasonable assumption” is further bolstered by the examples in the specification and official tutorials that show how to access <code class="literal">ServletContext</code> or <code class="literal">HttpSession</code> and do not use any client-side synchronization.</p>
<p>On the other hand, the objects placed in the <code class="literal">ServletContext</code> or <code class="literal">HttpSession</code> with <code class="literal">setAttribute</code> are owned by the web application, not the servlet container. The servlet specification does not suggest any mechanism for coordinating concurrent access to shared attributes. So attributes stored by the container on behalf of the web application should be thread-safe or effectively immutable. If all the container did was store these attributes on behalf of the web application, another option would be to ensure that they are consistently guarded by a lock when accessed from servlet application code. But because the container may want to serialize objects in the <code class="literal">HttpSession</code> for replication or passivation purposes, and the servlet container can’t possibly know your locking protocol, you should make them thread-safe.</p>
<p>One can make a similar inference about the JDBC <code class="literal">DataSource</code> interface, which represents a pool of reusable database connections. A <code class="literal">DataSource</code> provides service to an application, and it doesn’t make much sense in the context of a singlethreaded application. It is hard to imagine a use case that doesn’t involve calling <code class="literal">getConnection</code> from multiple threads. And, as with servlets, the examples in the JDBC specification do not suggest the need for any client-side locking in the many code examples using <code class="literal">DataSource</code>. So, even though the specification doesn’t promise that <code class="literal">DataSource</code> is thread-safe or require container vendors to provide a thread-safe implementation, by the same “it would be absurd if it weren’t” argument, we have no choice but to assume that <code class="literal">DataSource.getConnection</code> does not require additional client-side locking.</p>
<p>On the other hand, we would not make the same argument about the JDBC <code class="literal">Connection</code> objects dispensed by the <code class="literal">DataSource</code>, since these are not necessarily intended to be shared by other activities until they are returned to the pool. So if an activity that obtains a JDBC <code class="literal">Connection</code> spans multiple threads, it must take responsibility for ensuring that access to the <code class="literal">Connection</code> is properly guarded by synchronization. (In most applications, activities that use a JDBC <code class="literal">Connection</code> are implemented so as to confine the <code class="literal">Connection</code> to a specific thread anyway.)</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch04fn08" href="#ch04fn08" class="para">8</a>] </sup>If you’ve never wondered this, we admire your optimism.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn09" href="#ch04fn09" class="para">9</a>] </sup>We find it particularly frustrating that these omissions persist despite multiple major revisions of the specifications.</p></div></div></div></body></html>
