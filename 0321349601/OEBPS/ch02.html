<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 2. Thread Safety</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="chapter" title="Chapter 2. Thread Safety"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Thread Safety</h1></div></div></div>




<p><a id="iddle1017" class="indexterm"/><a id="iddle1018" class="indexterm"/><a id="iddle1019" class="indexterm"/><a id="iddle1254" class="indexterm"/><a id="iddle1451" class="indexterm"/><a id="iddle1452" class="indexterm"/><a id="iddle1453" class="indexterm"/><a id="iddle1531" class="indexterm"/><a id="iddle1532" class="indexterm"/><a id="iddle1639" class="indexterm"/><a id="iddle1640" class="indexterm"/><a id="iddle1652" class="indexterm"/><a id="iddle1746" class="indexterm"/><a id="iddle1998" class="indexterm"/><a id="iddle1999" class="indexterm"/><a id="iddle2000" class="indexterm"/><a id="iddle2001" class="indexterm"/><a id="iddle2002" class="indexterm"/><a id="iddle2003" class="indexterm"/><a id="iddle2347" class="indexterm"/><a id="iddle2348" class="indexterm"/><a id="iddle2870" class="indexterm"/><a id="iddle2871" class="indexterm"/><a id="iddle2872" class="indexterm"/><a id="iddle3027" class="indexterm"/><a id="iddle3032" class="indexterm"/><a id="iddle3033" class="indexterm"/><a id="iddle3034" class="indexterm"/><a id="iddle3262" class="indexterm"/><a id="iddle3266" class="indexterm"/><a id="iddle3267" class="indexterm"/><a id="iddle3268" class="indexterm"/><a id="iddle3278" class="indexterm"/><a id="iddle3281" class="indexterm"/><a id="iddle3282" class="indexterm"/><a id="iddle3448" class="indexterm"/><a id="iddle3449" class="indexterm"/><a id="iddle4028" class="indexterm"/><a id="iddle4029" class="indexterm"/><a id="iddle4030" class="indexterm"/><a id="iddle4031" class="indexterm"/><a id="iddle4158" class="indexterm"/><a id="iddle4222" class="indexterm"/><a id="iddle4223" class="indexterm"/><a id="iddle4239" class="indexterm"/><a id="iddle4240" class="indexterm"/><a id="iddle4377" class="indexterm"/><a id="iddle4378" class="indexterm"/><a id="iddle4379" class="indexterm"/><a id="iddle4380" class="indexterm"/><a id="iddle4381" class="indexterm"/><a id="iddle4382" class="indexterm"/><a id="iddle4406" class="indexterm"/><a id="iddle4407" class="indexterm"/><a id="iddle4532" class="indexterm"/><a id="iddle4533" class="indexterm"/><a id="iddle4534" class="indexterm"/><a id="iddle4535" class="indexterm"/><a id="iddle4729" class="indexterm"/><a id="iddle4959" class="indexterm"/><a id="iddle5011" class="indexterm"/><a id="iddle5040" class="indexterm"/><a id="iddle5041" class="indexterm"/><a id="iddle5060" class="indexterm"/><a id="iddle5097" class="indexterm"/><a id="iddle5098" class="indexterm"/><a id="iddle5099" class="indexterm"/>Perhaps surprisingly, concurrent programming isn’t so much about threads or locks, any more than civil engineering is about rivets and I-beams. Of course, building bridges that don’t fall down requires the correct use of a lot of rivets and I-beams, just as building concurrent programs require the correct use of threads and locks. But these are just <span class="emphasis"><em>mechanisms</em></span>—means to an end. Writing thread-safe code is, at its core, about managing access to <span class="emphasis"><em>state</em></span>, and in particular to <span class="emphasis"><em>shared, mutable state</em></span>.</p>
<p>Informally, an object’s <span class="emphasis"><em>state</em></span> is its data, stored in <span class="emphasis"><em>state variables</em></span> such as instance or static fields. An object’s state may include fields from other, dependent objects; a <code class="literal">HashMap</code>’s state is partially stored in the <code class="literal">HashMap</code> object itself, but also in many <code class="literal">Map.Entry</code> objects. An object’s state encompasses any data that can affect its externally visible behavior.</p>
<p>By <span class="emphasis"><em>shared</em></span>, we mean that a variable could be accessed by multiple threads; by <span class="emphasis"><em>mutable</em></span>, we mean that its value could change during its lifetime. We may talk about thread safety as if it were about <span class="emphasis"><em>code</em></span>, but what we are really trying to do is protect <span class="emphasis"><em>data</em></span> from uncontrolled concurrent access.</p>
<p>Whether an object needs to be thread-safe depends on whether it will be accessed from multiple threads. This is a property of how the object is <span class="emphasis"><em>used</em></span> in a program, not what it <span class="emphasis"><em>does</em></span>. Making an object thread-safe requires using synchronization to coordinate access to its mutable state; failing to do so could result in data corruption and other undesirable consequences.</p>
<p><span class="emphasis"><em>Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization.</em></span> The primary mechanism for synchronization in Java is the <code class="literal">synchronized</code> keyword, which provides exclusive locking, but the term “synchronization” also includes the use of <code class="literal">volatile</code> variables, explicit locks, and atomic variables.</p>
<p>You should avoid the temptation to think that there are “special” situations in which this rule does not apply. A program that omits needed synchronization might appear to work, passing its tests and performing well for years, but it is still broken and may fail at any moment.</p>
<div class="sidebar"><a id="ch02sb01"/><p class="title"><b/></p>
<p>If multiple threads access the same mutable state variable without appropriate synchronization, <span class="emphasis"><em>your program is broken</em></span>. There are three ways to fix it:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Don’t share</em></span> the state variable across threads;</p></li><li class="listitem"><p>Make the state variable <span class="emphasis"><em>immutable</em></span>; or</p></li><li class="listitem"><p>Use <span class="emphasis"><em>synchronization</em></span> whenever accessing the state variable.</p></li></ul></div>
</div>
<p class="continued">If you haven’t considered concurrent access in your class design, some of these approaches can require significant design modifications, so fixing the problem might not be as trivial as this advice makes it sound. <span class="emphasis"><em>It is far easier to design a class to be thread-safe than to retrofit it for thread safety later.</em></span></p>
<p>In a large program, identifying whether multiple threads might access a given variable can be complicated. Fortunately, the same object-oriented techniques that help you write well-organized, maintainable classes—such as encapsulation and data hiding—can also help you create thread-safe classes. The less code that has access to a particular variable, the easier it is to ensure that all of it uses the proper synchronization, and the easier it is to reason about the conditions under which a given variable might be accessed. The Java language doesn’t force you to encapsulate state—it is perfectly allowable to store state in public fields (even public static fields) or publish a reference to an otherwise internal object—but the better encapsulated your program state, the easier it is to make your program thread-safe and to help maintainers keep it that way.</p>
<div class="sidebar"><a id="ch02sb02"/><p class="title"><b/></p>
<p>When designing thread-safe classes, good object-oriented techniques—encapsulation, immutability, and clear specification of invariants—are your best friends.</p>
</div>
<p>There will be times when good object-oriented design techniques are at odds with real-world requirements; it may be necessary in these cases to compromise the rules of good design for the sake of performance or for the sake of backward compatibility with legacy code. Sometimes abstraction and encapsulation are at odds with performance—although not nearly as often as many developers believe—but it is always a good practice first to make your code right, and <span class="emphasis"><em>then</em></span> make it fast. Even then, pursue optimization only if your performance measurements and requirements tell you that you must, and if those same measurements tell you that your optimizations actually made a difference under realistic conditions. <sup>[<a id="ch02fn01" href="#ftn.ch02fn01" class="footnote">1</a>]</sup></p>
<p>If you decide that you simply must break encapsulation, all is not lost. It is still possible to make your program thread-safe, it is just a lot harder. Moreover, the <a id="iddle1257" class="indexterm"/><a id="iddle1258" class="indexterm"/><a id="iddle1749" class="indexterm"/><a id="iddle1750" class="indexterm"/><a id="iddle1909" class="indexterm"/><a id="iddle1910" class="indexterm"/><a id="iddle2004" class="indexterm"/><a id="iddle2005" class="indexterm"/><a id="iddle2022" class="indexterm"/><a id="iddle2023" class="indexterm"/><a id="iddle2032" class="indexterm"/><a id="iddle2518" class="indexterm"/><a id="iddle2519" class="indexterm"/><a id="iddle2522" class="indexterm"/><a id="iddle2534" class="indexterm"/><a id="iddle2547" class="indexterm"/><a id="iddle2580" class="indexterm"/><a id="iddle2581" class="indexterm"/><a id="iddle2715" class="indexterm"/><a id="iddle2864" class="indexterm"/><a id="iddle2865" class="indexterm"/><a id="iddle3522" class="indexterm"/><a id="iddle3523" class="indexterm"/><a id="iddle3889" class="indexterm"/><a id="iddle4395" class="indexterm"/><a id="iddle4396" class="indexterm"/><a id="iddle4481" class="indexterm"/><a id="iddle4482" class="indexterm"/><a id="iddle1676" class="indexterm"/><a id="iddle1679" class="indexterm"/><a id="iddle2401" class="indexterm"/><a id="iddle2866" class="indexterm"/><a id="iddle3638" class="indexterm"/><a id="iddle4338" class="indexterm"/><a id="iddle4385" class="indexterm"/><a id="iddle4386" class="indexterm"/><a id="iddle4732" class="indexterm"/>thread safety of your program will be more fragile, increasing not only development cost and risk but maintenance cost and risk as well. <a class="link" href="ch04.html" title="Chapter 4. Composing Objects">Chapter 4</a> characterizes the conditions under which it is safe to relax encapsulation of state variables.</p>
<p>We’ve used the terms “thread-safe class” and “thread-safe program” nearly interchangeably thus far. Is a thread-safe program one that is constructed entirely of thread-safe classes? Not necessarily—a program that consists entirely of thread-safe classes may not be thread-safe, and a thread-safe program may contain classes that are not thread-safe. The issues surrounding the composition of thread-safe classes are also taken up in <a class="link" href="ch04.html" title="Chapter 4. Composing Objects">Chapter 4</a>. In any case, the concept of a thread-safe class makes sense only if the class encapsulates its own state. Thread safety may be a term that is applied to <span class="emphasis"><em>code</em></span>, but it is about <span class="emphasis"><em>state</em></span>, and it can only be applied to the entire body of code that encapsulates its state, which may be an object or an entire program.</p>



<div class="section" title="What is Thread Safety?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lev1sec1"/>What is Thread Safety?</h2></div></div></div>

<p>Defining thread safety is surprisingly tricky. The more formal attempts are so complicated as to offer little practical guidance or intuitive understanding, and the rest are informal descriptions that can seem downright circular. A quick Google search turns up numerous “definitions” like these:</p>
<div class="blockquote"><blockquote class="blockquote">
<p>. . . can be called from multiple program threads without unwanted interactions between the threads.</p>
<p>. . .may be called by more than one thread at a time without requiring any other action on the caller’s part.</p>
</blockquote></div>
<p class="continued">Given definitions like these, it’s no wonder we find thread safety confusing! They sound suspiciously like “a class is thread-safe if it can be used safely from multiple threads.” You can’t really argue with such a statement, but it doesn’t offer much practical help either. How do we tell a thread-safe class from an unsafe one? What do we even mean by “safe”?</p>
<p>At the heart of any reasonable definition of thread safety is the concept of <span class="emphasis"><em>correctness</em></span>. If our definition of thread safety is fuzzy, it is because we lack a clear definition of correctness.</p>
<p>Correctness means that a class <span class="emphasis"><em>conforms to its specification</em></span>. A good specification defines <span class="emphasis"><em>invariants</em></span> constraining an object’s state and <span class="emphasis"><em>postconditions</em></span> describing the effects of its operations. Since we often don’t write adequate specifications for our classes, how can we possibly know they are correct? We can’t, but that doesn’t stop us from using them anyway once we’ve convinced ourselves that “the code works”. This “code confidence” is about as close as many of us get to correctness, so let’s just assume that single-threaded correctness is something that “we know it when we see it”. Having optimistically defined “correctness” as something that can be recognized, we can now define thread safety in a somewhat less circular way: a class is thread-safe when it continues to behave correctly when accessed from multiple threads.</p>
<div class="sidebar"><a id="ch02sb03"/><p class="title"><b/></p>
<p>A class is <span class="emphasis"><em>thread-safe</em></span> if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.</p>
</div>
<p>Since any single-threaded program is also a valid multithreaded program, it cannot be thread-safe if it is not even correct in a single-threaded environment. <sup>[<a id="ch02fn02" href="#ftn.ch02fn02" class="footnote">2</a>]</sup> If an object is correctly implemented, no sequence of operations—calls to public methods and reads or writes of public fields—should be able to violate any of its invariants or postconditions. <span class="emphasis"><em>No set of operations performed sequentially or concurrently on instances of a thread-safe class can cause an instance to be in an invalid state.</em></span></p>
<div class="sidebar"><a id="ch02sb04"/><p class="title"><b/></p>
<p>Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.</p>
</div>
<div class="section" title="Example: A Stateless Servlet"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lev2sec1"/>Example: A Stateless Servlet</h3></div></div></div>

<p>In <a class="link" href="ch01.html" title="Chapter 1. Introduction">Chapter 1</a>, we listed a number of frameworks that create threads and call your components from those threads, leaving you with the responsibility of making your components thread-safe. Very often, thread-safety requirements stem not from a decision to use threads directly but from a decision to use a facility like the Servlets framework. We’re going to develop a simple example—a servlet-based factorization service—and slowly extend it to add features while preserving its thread safety.</p>
<p><a class="link" href="ch02.html#ch02list01" title="Example 2.1. A Stateless Servlet.">Listing 2.1</a> shows our simple factorization servlet. It unpacks the number to be factored from the servlet request, factors it, and packages the results into the servlet response.</p>
<div class="example"><a id="ch02list01"/><p class="title"><b>Example 2.1. A Stateless Servlet.</b></p><div class="example-contents">

<pre class="programlisting">@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
</pre>
</div></div><br class="example-break"/>
<p><a id="iddle2185" class="indexterm"/><a id="iddle2571" class="indexterm"/><a id="iddle2572" class="indexterm"/><a id="iddle2608" class="indexterm"/><a id="iddle2779" class="indexterm"/><a id="iddle2780" class="indexterm"/><a id="iddle4208" class="indexterm"/><a id="iddle4209" class="indexterm"/><a id="iddle4422" class="indexterm"/><a id="iddle4423" class="indexterm"/><a id="iddle4551" class="indexterm"/><a id="iddle4728" class="indexterm"/><a id="iddle1166" class="indexterm"/><a id="iddle1167" class="indexterm"/><a id="iddle2210" class="indexterm"/><a id="iddle2556" class="indexterm"/><a id="iddle2557" class="indexterm"/><a id="iddle2591" class="indexterm"/><a id="iddle2592" class="indexterm"/><a id="iddle2719" class="indexterm"/><a id="iddle2720" class="indexterm"/><a id="iddle4204" class="indexterm"/><a id="iddle4205" class="indexterm"/><a id="iddle4417" class="indexterm"/><a id="iddle4418" class="indexterm"/><a id="iddle4737" class="indexterm"/><code class="literal">StatelessFactorizer</code> is, like most servlets, stateless: it has no fields and references no fields from other classes. The transient state for a particular computation exists solely in local variables that are stored on the thread’s stack and are accessible only to the executing thread. One thread accessing a <code class="literal">StatelessFactorizer</code> cannot influence the result of another thread accessing the same <code class="literal">StatelessFactorizer</code>; because the two threads do not share state, it is as if they were accessing different instances. Since the actions of a thread accessing a stateless object cannot affect the correctness of operations in other threads, stateless objects are thread-safe.</p>
<div class="sidebar"><a id="ch02sb05"/><p class="title"><b/></p>
<p>Stateless objects are always thread-safe.</p>
</div>
<p>The fact that most servlets can be implemented with no state greatly reduces the burden of making servlets thread-safe. It is only when servlets want to remember things from one request to another that the thread safety requirement becomes an issue.</p>
</div>
</div>





<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch02fn01" href="#ch02fn01" class="para">1</a>] </sup>In concurrent code, this practice should be adhered to even more than usual. Because concurrency bugs are so difficult to reproduce and debug, the benefit of a small performance gain on some infrequently used code path may well be dwarfed by the risk that the program will fail in the field.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn02" href="#ch02fn02" class="para">2</a>] </sup>If the loose use of “correctness” here bothers you, you may prefer to think of a thread-safe class as one that is no more broken in a concurrent environment than in a single-threaded environment.</p></div></div></div></body></html>
