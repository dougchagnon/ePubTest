<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 3. Sharing Objects</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="chapter" title="Chapter 3. Sharing Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Sharing Objects</h1></div></div></div>




<p><a id="iddle1031" class="indexterm"/><a id="iddle1753" class="indexterm"/><a id="iddle3209" class="indexterm"/><a id="iddle3211" class="indexterm"/><a id="iddle3362" class="indexterm"/><a id="iddle4237" class="indexterm"/><a id="iddle4408" class="indexterm"/><a id="iddle4409" class="indexterm"/><a id="iddle4548" class="indexterm"/><a id="iddle4560" class="indexterm"/><a id="iddle5105" class="indexterm"/><a id="iddle5107" class="indexterm"/>We stated at the beginning of <a class="link" href="ch02.html" title="Chapter 2. Thread Safety">Chapter 2</a> that writing correct concurrent programs is primarily about managing access to shared, mutable state. That chapter was about using synchronization to prevent multiple threads from accessing the same data at the same time; this chapter examines techniques for sharing and publishing objects so they can be safely accessed by multiple threads. Together, they lay the foundation for building thread-safe classes and safely structuring concurrent applications using the <code class="literal">java.util.concurrent</code> library classes.</p>
<p>We have seen how <code class="literal">synchronized</code> blocks and methods can ensure that operations execute atomically, but it is a common misconception that <code class="literal">synchronized</code> is <span class="emphasis"><em>only</em></span> about atomicity or demarcating “critical sections”. Synchronization also has another significant, and subtle, aspect: <span class="emphasis"><em>memory visibility</em></span>. We want not only to prevent one thread from modifying the state of an object when another is using it, but also to ensure that when a thread modifies the state of an object, other threads can actually <span class="emphasis"><em>see</em></span> the changes that were made. But without synchronization, this may not happen. You can ensure that objects are published safely either by using explicit synchronization or by taking advantage of the synchronization built into library classes.</p>



<div class="section" title="Visibility"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lev1sec1"/>Visibility</h2></div></div></div>

<p>Visibility is subtle because the things that can go wrong are so counterintuitive. In a single-threaded environment, if you write a value to a variable and later read that variable with no intervening writes, you can expect to get the same value back. This seems only natural. It may be hard to accept at first, but when the reads and writes occur in different threads, <span class="emphasis"><em>this is simply not the case</em></span>. In general, there is <span class="emphasis"><em>no</em></span> guarantee that the reading thread will see a value written by another thread on a timely basis, or even at all. In order to ensure visibility of memory writes across threads, you must use synchronization.</p>
<p><code class="literal">NoVisibility</code> in <a class="link" href="ch03.html#ch03list01" title="Example 3.1. Sharing Variables without Synchronization. Don’t Do this.">Listing 3.1</a> illustrates what can go wrong when threads share data without synchronization. Two threads, the main thread and the reader thread, access the shared variables <code class="literal">ready</code> and <code class="literal">number</code>. The main thread starts the reader thread and then sets <code class="literal">number</code> to 42 and <code class="literal">ready</code> to <code class="literal">true</code>. The reader <a id="iddle1141" class="indexterm"/><a id="iddle1428" class="indexterm"/><a id="iddle1429" class="indexterm"/><a id="iddle1430" class="indexterm"/><a id="iddle1939" class="indexterm"/><a id="iddle2146" class="indexterm"/><a id="iddle2618" class="indexterm"/><a id="iddle2619" class="indexterm"/><a id="iddle3398" class="indexterm"/><a id="iddle3399" class="indexterm"/><a id="iddle3496" class="indexterm"/><a id="iddle3529" class="indexterm"/><a id="iddle3530" class="indexterm"/><a id="iddle3847" class="indexterm"/><a id="iddle3848" class="indexterm"/><a id="iddle3849" class="indexterm"/><a id="iddle3850" class="indexterm"/><a id="iddle3851" class="indexterm"/><a id="iddle3852" class="indexterm"/><a id="iddle4286" class="indexterm"/><a id="iddle4287" class="indexterm"/><a id="iddle4456" class="indexterm"/>thread spins until it sees <code class="literal">ready</code> is <code class="literal">true</code>, and then prints out <code class="literal">number</code>. While it may seem obvious that <code class="literal">NoVisibility</code> will print 42, it is in fact possible that it will print zero, or never terminate at all! Because it does not use adequate synchronization, there is no guarantee that the values of <code class="literal">ready</code> and <code class="literal">number</code> written by the main thread will be visible to the reader thread.</p>
<div class="example"><a id="ch03list01"/><p class="title"><b>Example 3.1. Sharing Variables without Synchronization. <span class="emphasis"><em>Don’t Do this</em></span>.</b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face.jpg" width="52" alt="Sharing Variables without Synchronization. Don’t Do this."/></div>
<pre class="programlisting">public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
</pre>
</div></div><br class="example-break"/>
<p><code class="literal">NoVisibility</code> could loop forever because the value of <code class="literal">ready</code> might never become visible to the reader thread. Even more strangely, <code class="literal">NoVisibility</code> could print zero because the write to <code class="literal">ready</code> might be made visible to the reader thread <span class="emphasis"><em>before</em></span> the write to <code class="literal">number</code>, a phenomenon known as <span class="emphasis"><em>reordering</em></span>. There is no guarantee that operations in one thread will be performed in the order given by the program, as long as the reordering is not detectable from within <span class="emphasis"><em>that</em></span> thread—<span class="emphasis"><em>even if the reordering is apparent to other threads</em></span>.<sup>[<a id="ch03fn01" href="#ftn.ch03fn01" class="footnote">1</a>]</sup> When the main thread writes first to <code class="literal">number</code> and then to <code class="literal">ready</code> without synchronization, the reader thread could see those writes happen in the opposite order—or not at all.</p>
<div class="sidebar"><a id="ch03sb01"/><p class="title"><b/></p>
<p><a id="iddle1686" class="indexterm"/><a id="iddle1761" class="indexterm"/><a id="iddle2227" class="indexterm"/><a id="iddle2228" class="indexterm"/><a id="iddle2305" class="indexterm"/><a id="iddle2306" class="indexterm"/><a id="iddle2558" class="indexterm"/><a id="iddle2559" class="indexterm"/><a id="iddle3409" class="indexterm"/><a id="iddle3410" class="indexterm"/><a id="iddle4364" class="indexterm"/><a id="iddle4561" class="indexterm"/><a id="iddle4730" class="indexterm"/>In the absence of synchronization, the compiler, processor, and runtime can do some downright weird things to the order in which operations appear to execute. Attempts to reason about the order in which memory actions “must” happen in insufflciently synchronized multithreaded programs will almost certainly be incorrect.</p>
</div>
<p><code class="literal">NoVisibility</code> is about as simple as a concurrent program can get—two threads and two shared variables—and yet it is still all too easy to come to the wrong conclusions about what it does or even whether it will terminate. Reasoning about insufficiently synchronized concurrent programs is prohibitively difficult.</p>
<p>This may all sound a little scary, and it should. Fortunately, there’s an easy way to avoid these complex issues: <span class="emphasis"><em>always use the proper synchronization whenever data is shared across threads.</em></span></p>
<div class="section" title="Stale Data"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lev2sec1"/>Stale Data</h3></div></div></div>

<p><code class="literal">NoVisibility</code> demonstrated one of the ways that insufficiently synchronized programs can cause surprising results: <span class="emphasis"><em>stale data</em></span>. When the reader thread examines <code class="literal">ready</code>, it may see an out-of-date value. Unless synchronization is used <span class="emphasis"><em>every time a variable is accessed</em></span>, it is possible to see a stale value for that variable. Worse, staleness is not all-or-nothing: a thread can see an up-to-date value of one variable but a stale value of another variable that was written first.</p>
<p>When food is stale, it is usually still edible—just less enjoyable. But stale data can be more dangerous. While an out-of-date hit counter in a web application might not be so bad,<sup>[<a id="ch03fn02" href="#ftn.ch03fn02" class="footnote">2</a>]</sup> stale values can cause serious safety or liveness failures. In <code class="literal">NoVisibility</code>, stale values could cause it to print the wrong value or prevent the program from terminating. Things can get even more complicated with stale values of object references, such as the link pointers in a linked list implementation. <span class="emphasis"><em>Stale data can cause serious and confusing failures such as unexpected exceptions, corrupted data structures, inaccurate computations, and infinite loops.</em></span></p>
<p><code class="literal">MutableInteger</code> in <a class="link" href="ch03.html#ch03list02" title="Example 3.2. Non-thread-safe Mutable Integer Holder.">Listing 3.2</a> is not thread-safe because the <code class="literal">value</code> field is accessed from both <code class="literal">get</code> and <code class="literal">set</code> without synchronization. Among other hazards, it is susceptible to stale values: if one thread calls <code class="literal">set</code>, other threads calling <code class="literal">get</code> may or may not see that update.</p>
<p>We can make <code class="literal">MutableInteger</code> thread safe by synchronizing the getter and setter as shown in <code class="literal">SynchronizedInteger</code> in <a class="link" href="ch03.html#ch03list03" title="Example 3.3. Thread-safe Mutable Integer Holder.">Listing 3.3</a>. Synchronizing only the setter would not be sufficient: threads calling <code class="literal">get</code> would still be able to see stale values.</p>

<p/><div class="example"><a id="ch03list02"/><p class="title"><b>Example 3.2. Non-thread-safe Mutable Integer Holder.</b></p><div class="example-contents">


<div class="mediaobject"><img src="graphics/face1.jpg" width="45" alt="Non-thread-safe Mutable Integer Holder."/></div>
<pre class="programlisting">@NotThreadSafe
public class MutableInteger {
    private int value;

    public int  get() { return value; }
    public void set(int value) { this.value = value; }
}
</pre>
</div></div><br class="example-break"/>
<div class="example"><a id="ch03list03"/><p class="title"><b>Example 3.3. Thread-safe Mutable Integer Holder.</b></p><div class="example-contents">

<pre class="programlisting">@ThreadSafe
public class SynchronizedInteger {
    <span class="strong"><strong>@GuardedBy("this")</strong></span> private int value;

    public <span class="strong"><strong>synchronized</strong></span> int get() { return value; }
    public <span class="strong"><strong>synchronized</strong></span> void set(int value) { this.value = value; }
}
</pre>
</div></div><br class="example-break"/>
</div>
<div class="section" title="Nonatomic 64-bit Operations"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lev2sec2"/>Nonatomic 64-bit Operations</h3></div></div></div>

<p><a id="iddle1001" class="indexterm"/><a id="iddle1002" class="indexterm"/><a id="iddle1147" class="indexterm"/><a id="iddle1148" class="indexterm"/><a id="iddle1751" class="indexterm"/><a id="iddle1752" class="indexterm"/><a id="iddle2140" class="indexterm"/><a id="iddle2192" class="indexterm"/><a id="iddle2839" class="indexterm"/><a id="iddle3161" class="indexterm"/><a id="iddle3300" class="indexterm"/><a id="iddle3374" class="indexterm"/><a id="iddle3375" class="indexterm"/><a id="iddle5104" class="indexterm"/>When a thread reads a variable without synchronization, it may see a stale value, but at least it sees a value that was actually placed there by some thread rather than some random value. This safety guarantee is called <span class="emphasis"><em>out-of-thin-air safety</em></span>.</p>
<p>Out-of-thin-air safety applies to all variables, with one exception: 64-bit numeric variables (<code class="literal">double</code> and <code class="literal">long</code>) that are not declared <code class="literal">volatile</code> (see <a class="link" href="ch03.html#ch03lev2sec4" title="Volatile Variables">Section 3.1.4</a>). The Java Memory Model requires fetch and store operations to be atomic, but for nonvolatile <code class="literal">long</code> and <code class="literal">double</code> variables, the JVM is permitted to treat a 64-bit read or write as two separate 32-bit operations. If the reads and writes occur in different threads, it is therefore possible to read a nonvolatile <code class="literal">long</code> and get back the high 32 bits of one value and the low 32 bits of another.<sup>[<a id="ch03fn03" href="#ftn.ch03fn03" class="footnote">3</a>]</sup> Thus, even if you don’t care about stale values, it is not safe to use shared mutable <code class="literal">long</code> and <code class="literal">double</code> variables in multithreaded programs unless they are declared <code class="literal">volatile</code> or guarded by a lock.</p>
</div>
<div class="section" title="Locking and Visibility"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lev2sec3"/>Locking and Visibility</h3></div></div></div>

<p>Intrinsic locking can be used to guarantee that one thread sees the effects of another in a predictable manner, as illustrated by <a class="link" href="ch03.html#ch03fig01" title="Figure 3.1. Visibility Guarantees for Synchronization.">Figure 3.1</a>. When thread <span class="emphasis"><em>A</em></span> executes a <code class="literal">synchronized</code> block, and subsequently thread <span class="emphasis"><em>B</em></span> enters a <code class="literal">synchronized</code> block guarded by the same lock, the values of variables that were visible to <span class="emphasis"><em>A</em></span> prior to releasing the lock are guaranteed to be visible to <span class="emphasis"><em>B</em></span> upon acquiring the<a id="iddle5064" class="indexterm"/><a id="iddle5122" class="indexterm"/>lock. In other words, everything <span class="emphasis"><em>A</em></span> did in or prior to a <code class="literal">synchronized</code> block is visible to <span class="emphasis"><em>B</em></span> when it executes a <code class="literal">synchronized</code> block guarded by the same lock. <span class="emphasis"><em>Without synchronization, there is no such guarantee.</em></span></p>
<div class="figure-float"><div class="figure"><a id="ch03fig01"/><p class="title"><b>Figure 3.1. Visibility Guarantees for Synchronization.</b></p><div class="figure-contents">


<div class="mediaobject"><img src="graphics/03fig01.gif" width="500" alt="Visibility Guarantees for Synchronization."/></div>
</div></div><br class="figure-break"/></div>
<p>We can now give the other reason for the rule requiring all threads to synchronize on the <span class="emphasis"><em>same</em></span> lock when accessing a shared mutable variable—to guarantee that values written by one thread are made visible to other threads. Otherwise, if a thread reads a variable without holding the appropriate lock, it might see a stale value.</p>
<div class="sidebar"><a id="ch03sb02"/><p class="title"><b/></p>
<p>Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all threads see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lock.</p>
</div>
</div>
<div class="section" title="Volatile Variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lev2sec4"/>Volatile Variables</h3></div></div></div>

<p>The Java language also provides an alternative, weaker form of synchronization, <span class="emphasis"><em>volatile variables</em></span>, to ensure that updates to a variable are propagated predictably <a id="iddle1832" class="indexterm"/><a id="iddle2398" class="indexterm"/><a id="iddle2610" class="indexterm"/><a id="iddle2640" class="indexterm"/><a id="iddle2641" class="indexterm"/><a id="iddle2642" class="indexterm"/><a id="iddle2919" class="indexterm"/><a id="iddle3383" class="indexterm"/><a id="iddle3384" class="indexterm"/><a id="iddle3857" class="indexterm"/><a id="iddle4245" class="indexterm"/><a id="iddle4445" class="indexterm"/><a id="iddle4446" class="indexterm"/><a id="iddle4447" class="indexterm"/><a id="iddle4580" class="indexterm"/><a id="iddle5050" class="indexterm"/><a id="iddle5051" class="indexterm"/><a id="iddle5063" class="indexterm"/><a id="iddle5121" class="indexterm"/>to other threads. When a field is declared <code class="literal">volatile</code>, the compiler and runtime are put on notice that this variable is shared and that operations on it should not be reordered with other memory operations. Volatile variables are not cached in registers or in caches where they are hidden from other processors, so a read of a volatile variable always returns the most recent write by any thread.</p>
<p>A good way to think about volatile variables is to imagine that they behave roughly like the <code class="literal">SynchronizedInteger</code> class in <a class="link" href="ch03.html#ch03list03" title="Example 3.3. Thread-safe Mutable Integer Holder.">Listing 3.3</a>, replacing reads and writes of the volatile variable with calls to <code class="literal">get</code> and <code class="literal">set</code>.<sup>[<a id="ch03fn04" href="#ftn.ch03fn04" class="footnote">4</a>]</sup> Yet accessing a volatile variable performs no locking and so cannot cause the executing thread to block, making volatile variables a lighter-weight synchronization mechanism than <code class="literal">synchronized</code>.<sup>[<a id="ch03fn05" href="#ftn.ch03fn05" class="footnote">5</a>]</sup></p>
<p>The visibility effects of volatile variables extend beyond the value of the volatile variable itself. When thread <span class="emphasis"><em>A</em></span> writes to a volatile variable and subsequently thread <span class="emphasis"><em>B</em></span> reads that same variable, the values of <span class="emphasis"><em>all</em></span> variables that were visible to <span class="emphasis"><em>A</em></span> prior to writing to the volatile variable become visible to <span class="emphasis"><em>B</em></span> after reading the volatile variable. So from a memory visibility perspective, writing a volatile variable is like exiting a <code class="literal">synchronized</code> block and reading a volatile variable is like entering a <code class="literal">synchronized</code> block. However, we do not recommend relying too heavily on volatile variables for visibility; code that relies on volatile variables for visibility of arbitrary state is more fragile and harder to understand than code that uses locking.</p>
<div class="sidebar"><a id="ch03sb03"/><p class="title"><b/></p>
<p>Use <code class="literal">volatile</code> variables only when they simplify implementing and verifying your synchronization policy; avoid using <code class="literal">volatile</code> variables when veryfing correctness would require subtle reasoning about visibility. Good uses of <code class="literal">volatile</code> variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event (such as initialization or shutdown) has occurred.</p>
</div>
<p><a class="link" href="ch03.html#ch03list04" title="Example 3.4. Counting Sheep.">Listing 3.4</a> illustrates a typical use of volatile variables: checking a status flag to determine when to exit a loop. In this example, our anthropomorphized thread is trying to get to sleep by the time-honored method of counting sheep. For this example to work, the <code class="literal">asleep</code> flag must be volatile. Otherwise, the thread might not notice when <code class="literal">asleep</code> has been set by another thread.<sup>[<a id="ch03fn06" href="#ftn.ch03fn06" class="footnote">6</a>]</sup> We could instead have <a id="iddle1142" class="indexterm"/><a id="iddle1404" class="indexterm"/><a id="iddle2021" class="indexterm"/><a id="iddle2046" class="indexterm"/><a id="iddle2050" class="indexterm"/><a id="iddle2821" class="indexterm"/><a id="iddle2863" class="indexterm"/><a id="iddle3162" class="indexterm"/><a id="iddle3717" class="indexterm"/><a id="iddle3718" class="indexterm"/><a id="iddle3719" class="indexterm"/><a id="iddle3720" class="indexterm"/><a id="iddle3721" class="indexterm"/><a id="iddle4107" class="indexterm"/><a id="iddle4108" class="indexterm"/><a id="iddle4133" class="indexterm"/><a id="iddle5046" class="indexterm"/><a id="iddle5066" class="indexterm"/><a id="iddle5124" class="indexterm"/>used locking to ensure visibility of changes to <code class="literal">asleep</code>, but that would have made the code more cumbersome.</p>
<div class="example"><a id="ch03list04"/><p class="title"><b>Example 3.4. Counting Sheep.</b></p><div class="example-contents">

<pre class="programlisting"><span class="strong"><strong>volatile</strong></span> boolean asleep;
...
    while (!asleep)
        countSomeSheep();
</pre>
</div></div><br class="example-break"/>
<p>Volatile variables are convenient, but they have limitations. The most common use for volatile variables is as a completion, interruption, or status flag, such as the <code class="literal">asleep</code> flag in <a class="link" href="ch03.html#ch03list04" title="Example 3.4. Counting Sheep.">Listing 3.4</a>. Volatile variables can be used for other kinds of state information, but more care is required when attempting this. For example, the semantics of <code class="literal">volatile</code> are not strong enough to make the increment operation (<code class="literal">count++</code>) atomic, unless you can guarantee that the variable is written only from a single thread. (Atomic variables do provide atomic read-modify-write support and can often be used as “better volatile variables”; see <a class="link" href="ch15.html" title="Chapter 15. Atomic Variables and Nonblocking Synchronization">Chapter 15</a>.)</p>
<div class="sidebar"><a id="ch03sb04"/><p class="title"><b/></p>
<p>Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.</p>
</div>
<p>You can use volatile variables only when all the following criteria are met:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;</p></li><li class="listitem"><p>The variable does not participate in invariants with other state variables; and</p></li><li class="listitem"><p>Locking is not required for any other reason while the variable is being accessed.</p></li></ul></div>
</div>
</div>





<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch03fn01" href="#ch03fn01" class="para">1</a>] </sup>This may seem like a broken design, but it is meant to allow JVMs to take full advantage of the performance of modern multiprocessor hardware. For example, in the absence of synchronization, the Java Memory Model permits the compiler to reorder operations and cache values in registers, and permits CPUs to reorder operations and cache values in processor-specific caches. For more details, see <a class="link" href="ch16.html" title="Chapter 16. The Java Memory Model">Chapter 16</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn02" href="#ch03fn02" class="para">2</a>] </sup>Reading data without synchronization is analogous to using the <code class="literal">READ_UNCOMMITTED</code> isolation level in a database, where you are willing to trade accuracy for performance. However, in the case of unsynchronized reads, you are trading away a greater degree of accuracy, since the visible value for a shared variable can be arbitrarily stale.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn03" href="#ch03fn03" class="para">3</a>] </sup>When the Java Virtual Machine Specification was written, many widely used processor architectures could not efficiently provide atomic 64-bit arithmetic operations.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn04" href="#ch03fn04" class="para">4</a>] </sup>This analogy is not exact; the memory visibility effects of <code class="literal">SynchronizedInteger</code> are actually slightly stronger than those of volatile variables. See <a class="link" href="ch16.html" title="Chapter 16. The Java Memory Model">Chapter 16</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn05" href="#ch03fn05" class="para">5</a>] </sup>Volatile reads are only slightly more expensive than nonvolatile reads on most current processor architectures.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn06" href="#ch03fn06" class="para">6</a>] </sup>Debugging tip: For server applications, be sure to always specify the <code class="literal">-server</code> JVM command line switch when invoking the JVM, even for development and testing. The server JVM performs more optimization than the client JVM, such as hoisting variables out of a loop that are not modified in the loop; code that might appear to work in the development environment (client JVM) can break in the deployment environment (server JVM). For example, had we “forgotten” to declare the variable <code class="literal">asleep</code> as <code class="literal">volatile</code> in <a class="link" href="ch03.html#ch03list04" title="Example 3.4. Counting Sheep.">Listing 3.4</a>, the server JVM could hoist the test out of the loop (turning it into an infinite loop), but the client JVM would not. An infinite loop that shows up in development is far less costly than one that only shows up in production.</p></div></div></div></body></html>
