<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Avoiding Performance Testing Pitfalls</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Avoiding Performance Testing Pitfalls"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lev1sec3"/>Avoiding Performance Testing Pitfalls</h2></div></div></div>


<p><a id="iddle2441" class="indexterm"/><a id="iddle2442" class="indexterm"/><a id="iddle3539" class="indexterm"/><a id="iddle4702" class="indexterm"/><a id="iddle4703" class="indexterm"/><a id="iddle4706" class="indexterm"/>In theory, developing performance tests is easy—find a typical usage scenario, write a program that executes that scenario many times, and time it. In practice, you have to watch out for a number of coding pitfalls that prevent performance tests from yielding meaningful results.</p>
<div class="section" title="Garbage Collection"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lev2sec10"/>Garbage Collection</h3></div></div></div>

<p>The timing of garbage collection is unpredictable, so there is always the possibility that the garbage collector will run during a measured test run. If a test program performs <span class="emphasis"><em>N</em></span> iterations and triggers no garbage collection but iteration <span class="emphasis"><em>N</em></span> + 1would trigger a garbage collection, a small variation in the size of the run could have a big (but spurious) effect on the measured time per iteration.</p>
<p>There are two strategies for preventing garbage collection from biasing your results. One is to ensure that garbage collection does not run at all during your test (you can invoke the JVM with <code class="literal">-verbose:gc</code> to find out); alternatively, you can make sure that the garbage collector runs a number of times during your run so that the test program adequately reflects the cost of ongoing allocation and garbage collection. The latter strategy is often better—it requires a longer test and is more likely to reflect real-world performance.</p>
<p>Most producer-consumer applications involve a fair amount of allocation and garbage collection—producers allocate new objects that are used and discarded by consumers. Running the bounded buffer test for long enough to incur multiple garbage collections yields more accurate results.</p>
</div>
<div class="section" title="Dynamic Compilation"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lev2sec11"/>Dynamic Compilation</h3></div></div></div>


<p><a id="iddle1392" class="indexterm"/><a id="iddle1393" class="indexterm"/><a id="iddle1394" class="indexterm"/><a id="iddle1976" class="indexterm"/><a id="iddle1977" class="indexterm"/><a id="iddle2658" class="indexterm"/><a id="iddle2659" class="indexterm"/><a id="iddle4705" class="indexterm"/><a id="iddle4899" class="indexterm"/><a id="iddle4900" class="indexterm"/>Writing and interpreting performance benchmarks for dynamically compiled languages like Java is far more difficult than for statically compiled languages like C or C++. The HotSpot JVM (and other modern JVMs) uses a combination of bytecode interpretation and dynamic compilation. When a class is first loaded, the JVM executes it by interpreting the bytecode. At some point, if a method is run often enough, the dynamic compiler kicks in and converts it to machine code; when compilation completes, it switches from interpretation to direct execution.</p>
<p>The timing of compilation is unpredictable. Your timing tests should run only after all code has been compiled; there is no value in measuring the speed of the interpreted code since most programs run long enough that all frequently executed code paths are compiled. Allowing the compiler to run during a measured test run can bias test results in two ways: compilation consumes CPU resources, and measuring the run time of a combination of interpreted and compiled code is not a meaningful performance metric. <a class="link" href="ch12s03.html#ch12fig05" title="Figure 12.5. Results Biased by Dynamic Compilation.">Figure 12.5</a> shows how this can bias your results. The three timelines represent the execution of the same number of iterations: timeline <span class="emphasis"><em>A</em></span> represents all interpreted execution, <span class="emphasis"><em>B</em></span> represents compilation halfway through the run, and <span class="emphasis"><em>C</em></span> represents compilation early in the run. The point at which compilation runs seriously affects the measured per-operation runtime.<sup>[<a id="ch12fn07" href="#ftn.ch12fn07" class="footnote">7</a>]</sup></p>
<div class="figure-float"><div class="figure"><a id="ch12fig05"/><p class="title"><b>Figure 12.5. Results Biased by Dynamic Compilation.</b></p><div class="figure-contents">


<div class="mediaobject"><img src="graphics/12fig05.gif" height="190" alt="Results Biased by Dynamic Compilation."/></div>
</div></div><br class="figure-break"/></div>
<p>Code may also be decompiled (reverting to interpreted execution) and recompiled for various reasons, such as loading a class that invalidates assumptions made by prior compilations, or gathering sufficient profiling data to decide that a code path should be recompiled with different optimizations.</p>
<p>One way to to prevent compilation from biasing your results is to run your program for a long time (at least several minutes) so that compilation and interpreted execution represent a small fraction of the total run time. Another approach is to use an unmeasured “warm-up” run, in which your code is executed enough to be fully compiled when you actually start timing. On HotSpot, running your program with <code class="literal">-XX:+PrintCompilation</code> prints out a message when <a id="iddle1434" class="indexterm"/><a id="iddle1435" class="indexterm"/><a id="iddle1609" class="indexterm"/><a id="iddle1610" class="indexterm"/><a id="iddle2914" class="indexterm"/><a id="iddle3256" class="indexterm"/><a id="iddle3380" class="indexterm"/><a id="iddle3381" class="indexterm"/><a id="iddle3382" class="indexterm"/><a id="iddle4710" class="indexterm"/><a id="iddle4711" class="indexterm"/><a id="iddle4839" class="indexterm"/><a id="iddle4840" class="indexterm"/><a id="iddle4986" class="indexterm"/>dynamic compilation runs, so you can verify that this is prior to, rather than during, measured test runs.</p>
<p>Running the same test several times in the same JVM instance can be used to validate the testing methodology. The first group of results should be discarded as warm-up; seeing inconsistent results in the remaining groups suggests that the test should be examined further to determine why the timing results are not repeatable.</p>
<p>The JVM uses various background threads for housekeeping tasks. When measuring multiple <span class="emphasis"><em>unrelated</em></span> computationally intensive activities in a single run, it is a good idea to place explicit pauses between the measured trials to give the JVM a chance to catch up with background tasks with minimal interference from measured tasks. (When measuring multiple related activities, however, such as multiple runs of the same test, excluding JVM background tasks in this way may give unrealistically optimistic results.)</p>
</div>
<div class="section" title="Unrealistic Sampling of Code Paths"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lev2sec12"/>Unrealistic Sampling of Code Paths</h3></div></div></div>

<p>Runtime compilers use profiling information to help optimize the code being compiled. The JVM is permitted to use information specific to the execution in order to produce better code, which means that compiling method <span class="emphasis"><em>M</em></span> in one program may generate different code than compiling <span class="emphasis"><em>M</em></span> in another. In some cases, the JVM may make optimizations based on assumptions that may only be true temporarily, and later back them out by invalidating the compiled code if they become untrue.<sup>[<a id="ch12fn08" href="#ftn.ch12fn08" class="footnote">8</a>]</sup></p>
<p>As a result, it is important that your test programs not only adequately approximate the usage patterns of a typical application, but also approximate the set of code paths used by such an application. Otherwise, a dynamic compiler could make special optimizations to a purely single-threaded test program that could not be applied in real applications containing at least occasional parallelism. Therefore, tests of multithreaded performance should normally be mixed with tests of single-threaded performance, even if you want to measure only singlethreaded performance. (This issue does not arise in <code class="literal">TimedPutTakeTest</code> because even the smallest test case uses two threads.)</p>
</div>
<div class="section" title="Unrealistic Degrees of Contention"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lev2sec13"/>Unrealistic Degrees of Contention</h3></div></div></div>

<p>Concurrent applications tend to interleave two very different sorts of work: accessing shared data, such as fetching the next task from a shared work queue, and thread-local computation (executing the task, assuming the task itself does not access shared data). Depending on the relative proportions of the two types of work, the application will experience different levels of contention and exhibit different performance and scaling behaviors.</p>
<p>If <span class="emphasis"><em>N</em></span> threads are fetching tasks from a shared work queue and executing them, and the tasks are compute-intensive and long-running (and do not access shared <a id="iddle1787" class="indexterm"/><a id="iddle1788" class="indexterm"/><a id="iddle4704" class="indexterm"/>data very much), there will be almost no contention; throughput is dominated by the availability of CPU resources. On the other hand, if the tasks are very short-lived, there will be a lot of contention for the work queue and throughput is dominated by the cost of synchronization.</p>
<p>To obtain realistic results, concurrent performance tests should try to approximate the thread-local computation done by a typical application in addition to the concurrent coordination under study. If the the work done for each task in an application is significantly different in nature or scope from the test program, it is easy to arrive at unwarranted conclusions about where the performance bottlenecks lie. We saw in <a class="link" href="ch11s05.html" title="Example: Comparing Map Performance">Section 11.5</a> that, for lock-based classes such as the synchronized <code class="literal">Map</code> implementations, whether access to the lock is mostly contended or mostly uncontended can have a dramatic effect on throughput. The tests in that section do nothing but pound on the <code class="literal">Map</code>; even with two threads, all attempts to access the <code class="literal">Map</code> are contended. However, if an application did a significant amount of thread-local computation for each time it accesses the shared data structure, the contention level might be low enough to offer good performance.</p>
<p>In this regard, <code class="literal">TimedPutTakeTest</code> may be a poor model for some applications. Since the worker threads do not do very much, throughput is dominated by coordination overhead, and this is not necessarily the case in all applications that exchange data between producers and consumers via bounded buffers.</p>
</div>
<div class="section" title="Dead Code Elimination"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lev2sec14"/>Dead Code Elimination</h3></div></div></div>

<p>One of the challenges of writing good benchmarks (in any language) is that optimizing compilers are adept at spotting and eliminating dead code—code that has no effect on the outcome. Since benchmarks often don’t compute anything, they are an easy target for the optimizer. Most of the time, it is a good thing when the optimizer prunes dead code from a program, but for a benchmark this is a big problem because then you are measuring less execution than you think. If you’re lucky, the optimizer will prune away your <span class="emphasis"><em>entire</em></span> program, and then it will be obvious that your data is bogus. If you’re unlucky, dead-code elimination will just speed up your program by some factor that <span class="emphasis"><em>could</em></span> be explained by other means.</p>
<p>Dead-code elimination is a problem in benchmarking statically compiled languages too, but detecting that the compiler has eliminated a good chunk of your benchmark is a lot easier because you can look at the machine code and see that a part of your program is missing. With dynamically compiled languages, that information is not easily accessible.</p>
<p>Many microbenchmarks perform much “better” when run with HotSpot’s <code class="literal">-server</code> compiler than with <code class="literal">-client</code>, not just because the server compiler can produce more efficient code, but also because it is more adept at optimizing dead code. Unfortunately, the dead-code elimination that made such short work of your benchmark won’t do quite as well with code that actually does something. But you should still prefer <code class="literal">-server</code> to <code class="literal">-client</code> for both production and testing on multiprocessor systems—you just have to write your tests so that they are not susceptible to dead-code elimination.</p>
<div class="sidebar"><a id="ch12sb03"/><p class="title"><b/></p>
<p><a id="iddle2598" class="indexterm"/><a id="iddle2599" class="indexterm"/><a id="iddle3743" class="indexterm"/><a id="iddle4715" class="indexterm"/>Writing effective performance tests requires tricking the optimizer into not optimizing away your benchmark as dead code. This requires every computed result to be used somehow by your program—in a way that does not require synchronization or substantial computation.</p>
</div>
<p>In <code class="literal">PutTakeTest</code>, we compute the checksum of elements added to and removed from the queue and combine these checksums across all the threads, but this could still be optimized away if we do not actually <span class="emphasis"><em>use</em></span> the checksum value. We happen to need it to verify the correctness of the algorithm, but you can ensure that a value is used by printing it out. However, you should avoid doing I/O while the test is actually running, so as not to distort the run time measurement.</p>
<p>A cheap trick for preventing a calculation from being optimized away without introducing too much overhead is to compute the <code class="literal">hashCode</code> of the field of some derived object, compare it to an arbitrary value such as the current value of <code class="literal">System. nanoTime</code>, and print a useless and ignorable message if they happen to match:</p>
<div class="informalexample">
<pre class="programlisting">if (foo.x.hashCode() == System.nanoTime())
    System.out.print(" ");
</pre>
</div>
<p>The comparison will rarely succeed, and if it does, its only effect will be to insert a harmless space character into the output. (The <code class="literal">print</code> method buffers output until <code class="literal">println</code> is called, so in the rare case that <code class="literal">hashCode</code> and <code class="literal">System.nanoTime</code> are equal no I/O is actually performed.)</p>
<p>Not only should every computed result be used, but results should also be unguessable. Otherwise, a smart dynamic optimizing compiler is allowed to replace actions with precomputed results. We addressed this in the construction of <code class="literal">PutTakeTest</code>, but any test program whose input is static data is vulnerable to this optimization.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch12fn07" href="#ch12fn07" class="para">7</a>] </sup>The JVMmay choose to perform compilation in the application thread or in the background thread; each can bias timing results in different ways.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch12fn08" href="#ch12fn08" class="para">8</a>] </sup>For example, the JVM can use <span class="emphasis"><em>monomorphic call transformation</em></span> to convert a virtual method call to a direct method call if no classes currently loaded override that method, but it invalidates the compiled code if a class is subsequently loaded that overrides the method.</p></div></div></div></body></html>
