<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>JVM Shutdown</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="JVM Shutdown"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lev1sec4"/>JVM Shutdown</h2></div></div></div>


<p><a id="iddle1010" class="indexterm"/><a id="iddle1355" class="indexterm"/><a id="iddle2356" class="indexterm"/><a id="iddle2357" class="indexterm"/><a id="iddle2648" class="indexterm"/><a id="iddle2649" class="indexterm"/><a id="iddle2650" class="indexterm"/><a id="iddle2651" class="indexterm"/><a id="iddle2922" class="indexterm"/><a id="iddle2924" class="indexterm"/><a id="iddle3419" class="indexterm"/><a id="iddle4166" class="indexterm"/><a id="iddle4247" class="indexterm"/><a id="iddle4248" class="indexterm"/><a id="iddle4254" class="indexterm"/><a id="iddle4255" class="indexterm"/><a id="iddle4256" class="indexterm"/><a id="iddle4259" class="indexterm"/><a id="iddle4293" class="indexterm"/><a id="iddle4731" class="indexterm"/><a id="iddle4975" class="indexterm"/>The JVM can shut down in either an <span class="emphasis"><em>orderly</em></span> or <span class="emphasis"><em>abrupt</em></span> manner. An orderly shutdown is initiated when the last “normal” (nondaemon) thread terminates, someone calls <code class="literal">System.exit</code>, or by other platform-specific means (such as sending a <code class="literal">SIGINT</code> or hitting <code class="literal">Ctrl-C</code>). While this is the standard and preferred way for the JVM to shut down, it can also be shut down abruptly by calling <code class="literal">Runtime.halt</code> or by killing the JVM process through the operating system (such as sending a <code class="literal">SIGKILL</code>).</p>
<div class="section" title="Shutdown Hooks"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lev2sec14"/>Shutdown Hooks</h3></div></div></div>

<p>In an orderly shutdown, the JVM first starts all registered <span class="emphasis"><em>shutdown hooks</em></span>. Shutdown hooks are unstarted threads that are registered with <code class="literal">Runtime.addShutdownHook</code>. The JVM makes no guarantees on the order in which shutdown hooks are started. If any application threads (daemon or nondaemon) are still running at shutdown time, they continue to run concurrently with the shutdown process. When all shutdown hooks have completed, the JVM may choose to run finalizers if <code class="literal">runFinalizersOnExit</code> is <code class="literal">true</code>, and then halts. The JVM makes no attempt to stop or interrupt any application threads that are still running at shutdown time; they are abruptly terminated when the JVM eventually halts. If the shutdown hooks or finalizers don’t complete, then the orderly shutdown process “hangs” and the JVM must be shut down abruptly. In an abrupt shutdown, the JVM is not required to do anything other than halt the JVM; shutdown hooks will not run.</p>
<p>Shutdown hooks should be thread-safe: they must use synchronization when accessing shared data and should be careful to avoid deadlock, just like any other concurrent code. Further, they should not make assumptions about the state of the application (such as whether other services have shut down already or all normal threads have completed) or about why the JVM is shutting down, and must therefore be coded extremely defensively. Finally, they should exit as quickly as possible, since their existence delays JVM termination at a time when the user may be expecting the JVM to terminate quickly.</p>
<p>Shutdown hooks can be used for service or application cleanup, such as deleting temporary files or cleaning up resources that are not automatically cleaned up by the OS. <a class="link" href="ch07s04.html#ch07list26" title="Example 7.26. Registering a Shutdown Hook to Stop the Logging Service.">Listing 7.26</a> shows how <code class="literal">LogService</code> in <a class="link" href="ch07s02.html#ch07list16" title="Example 7.16. Logging Service that Uses an ExecutorService.">Listing 7.16</a> could register a shutdown hook from its <code class="literal">start</code> method to ensure the log file is closed on exit.</p>
<p>Because shutdown hooks all run concurrently, closing the log file could cause trouble for other shutdown hooks who want to use the logger. To avoid this problem, shutdown hooks should not rely on services that can be shut down by the application or other shutdown hooks. One way to accomplish this is to use a single shutdown hook for all services, rather than one for each service, and have it call a series of shutdown actions. This ensures that shutdown actions execute sequentially in a single thread, thus avoiding the possibility of race conditions or deadlock between shutdown actions. This technique can be used whether or not you use shutdown hooks; executing shutdown actions sequentially rather than concurrently eliminates many potential sources of failure. In applications <a id="iddle1745" class="indexterm"/><a id="iddle2358" class="indexterm"/><a id="iddle2603" class="indexterm"/><a id="iddle2604" class="indexterm"/><a id="iddle2923" class="indexterm"/><a id="iddle3293" class="indexterm"/><a id="iddle3294" class="indexterm"/><a id="iddle3922" class="indexterm"/><a id="iddle4257" class="indexterm"/><a id="iddle4766" class="indexterm"/>that maintain explicit dependency information among services, this technique can also ensure that shutdown actions are performed in the right order.</p>
<div class="example"><a id="ch07list26"/><p class="title"><b>Example 7.26. Registering a Shutdown Hook to Stop the Logging Service.</b></p><div class="example-contents">

<pre class="programlisting">public void start() {
    Runtime.getRuntime().addShutdownHook(new Thread() {
        public void run() {
            try { LogService.this.stop(); }
            catch (InterruptedException ignored) {}
        }
    });
}
</pre>
</div></div><br class="example-break"/>
</div>
<div class="section" title="Daemon Threads"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lev2sec15"/>Daemon Threads</h3></div></div></div>

<p>Sometimes you want to create a thread that performs some helper function but you don’t want the existence of this thread to prevent the JVM from shutting down. This is what <span class="emphasis"><em>daemon threads</em></span> are for.</p>
<p>Threads are divided into two types: normal threads and daemon threads. When the JVM starts up, all the threads it creates (such as garbage collector and other housekeeping threads) are daemon threads, except the main thread. When a new thread is created, it inherits the daemon status of the thread that created it, so by default any threads created by the main thread are also normal threads.</p>
<p>Normal threads and daemon threads differ only in what happens when they exit. When a thread exits, the JVM performs an inventory of running threads, and if the only threads that are left are daemon threads, it initiates an orderly shutdown. When the JVM halts, any remaining daemon threads are abandoned—<code class="literal">finally</code> blocks are not executed, stacks are not unwound—the JVM just exits.</p>
<p>Daemon threads should be used sparingly—few processing activities can be safely abandoned at any time with no cleanup. In particular, it is dangerous to use daemon threads for tasks that might perform any sort of I/O. Daemon threads are best saved for “housekeeping” tasks, such as a background thread that periodically removes expired entries from an in-memory cache.</p>
<div class="sidebar"><a id="ch07sb09"/><p class="title"><b/></p>
<p>Daemon threads are not a good substitute for properly managing the lifecycle of services within an application.</p>
</div>
</div>
<div class="section" title="Finalizers"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lev2sec16"/>Finalizers</h3></div></div></div>

<p>The garbage collector does a good job of reclaiming memory resources when they are no longer needed, but some resources, such as file or socket handles, must be explicitly returned to the operating system when no longer needed. To assist in <a id="iddle1985" class="indexterm"/><a id="iddle2528" class="indexterm"/><a id="iddle4468" class="indexterm"/>this, the garbage collector treats objects that have a nontrivial <code class="literal">finalize</code> method specially: after they are reclaimed by the collector, <code class="literal">finalize</code> is called so that persistent resources can be released.</p>
<p>Since finalizers can run in a thread managed by the JVM, any state accessed by a finalizer will be accessed by more than one thread and therefore must be accessed with synchronization. Finalizers offer no guarantees on when or even if they run, and they impose a significant performance cost on objects with nontrivial finalizers. They are also extremely difficult to write correctly.<sup>[<a id="ch07fn09" href="#ftn.ch07fn09" class="footnote">9</a>]</sup> In most cases, the combination of <code class="literal">finally</code> blocks and explicit <code class="literal">close</code> methods does a better job of resource management than finalizers; the sole exception is when you need to manage objects that hold resources acquired by native methods. For these reasons and others, work hard to avoid writing or using classes with finalizers (other than the platform library classes) [EJ Item 6].</p>
<div class="sidebar"><a id="ch07sb10"/><p class="title"><b/></p>
<p>Avoid finalizers.</p>
</div>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch07fn09" href="#ch07fn09" class="para">9</a>] </sup>See (<a class="link" href="bi01.html#biblio01_006" title="JavaOne presentation">Boehm, 2005</a>) for some of the challenges involved in writing finalizers.</p></div></div></div></body></html>
