<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Performance Considerations</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Performance Considerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lev1sec2"/>Performance Considerations</h2></div></div></div>

<p>When <code class="literal">ReentrantLock</code> was added in Java 5.0, it offered far better contended performance than intrinsic locking. For synchronization primitives, contended performance is the key to scalability: if more resources are expended on lock management and scheduling, fewer are available for the application. A better lock implementation makes fewer system calls, forces fewer context switches, and initiates less memory-synchronization traffic on the shared memory bus, operations that are time-consuming and divert computing resources from the program.</p>
<p>Java 6 uses an improved algorithm for managing intrinsic locks, similar to that used by <code class="literal">ReentrantLock</code>, that closes the scalability gap considerably. <a class="link" href="ch13s02.html#ch13fig01" title="Figure 13.1. Intrinsic Locking Versus ReentrantLock Performance on Java 5.0 and Java 6.">Figure 13.1</a> shows the performance difference between intrinsic locks and <code class="literal">ReentrantLock</code> on Java 5.0 and on a prerelease build of Java 6 on a four-way Opteron system running Solaris. The curves represent the “speedup” of <code class="literal">ReentrantLock</code> over intrinsic locking on a single JVM version. On Java 5.0, <code class="literal">ReentrantLock</code> offers considerably better throughput, but on Java 6, the two are quite close.<sup>[<a id="ch13fn02" href="#ftn.ch13fn02" class="footnote">2</a>]</sup> The test program is the same one used in <a class="link" href="ch11s05.html" title="Example: Comparing Map Performance">Section 11.5</a>, this time comparing the throughput of a <code class="literal">HashMap</code> guarded by an intrinsic lock and by a <code class="literal">ReentrantLock</code>.</p>

<p/><div class="figure-float"><div class="figure"><a id="ch13fig01"/><p class="title"><b>Figure 13.1. Intrinsic Locking Versus <code class="literal">ReentrantLock</code> Performance on Java 5.0 and Java 6.</b></p><div class="figure-contents">


<div class="mediaobject"><img src="graphics/13fig01.gif" height="283" alt="Intrinsic Locking Versus ReentrantLock Performance on Java 5.0 and Java 6."/></div>
</div></div><br class="figure-break"/></div>
<p><a id="iddle1184" class="indexterm"/><a id="iddle1185" class="indexterm"/><a id="iddle1186" class="indexterm"/><a id="iddle2322" class="indexterm"/><a id="iddle2323" class="indexterm"/><a id="iddle2328" class="indexterm"/><a id="iddle3137" class="indexterm"/><a id="iddle4982" class="indexterm"/><a id="iddle4983" class="indexterm"/>On Java 5.0, the performance of intrinsic locking drops dramatically in going from one thread (no contention) to more than one thread; the performance of <code class="literal">ReentrantLock</code> drops far less, showing its better scalability. But on Java 6, it is a different story—intrinsic locks no longer fall apart under contention, and the two scale fairly similarly.</p>
<p>Graphs like <a class="link" href="ch13s02.html#ch13fig01" title="Figure 13.1. Intrinsic Locking Versus ReentrantLock Performance on Java 5.0 and Java 6.">Figure 13.1</a> remind us that statements of the form “<span class="emphasis"><em>X</em></span> is faster than <span class="emphasis"><em>Y</em></span>” are at best short-lived. Performance and scalability are sensitive to platform factors such as CPU, processor count, cache size, and JVM characteristics, all of which can change over time. <sup>[<a id="ch13fn03" href="#ftn.ch13fn03" class="footnote">3</a>]</sup></p>
<div class="sidebar"><a id="ch13sb01"/><p class="title"><b/></p>
<p>Performance is a moving target; yesterday’s benchmark showing that <span class="emphasis"><em>X</em></span> is faster than <span class="emphasis"><em>Y</em></span> may already be out of date today.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch13fn02" href="#ch13fn02" class="para">2</a>] </sup>Though this particular graph doesn’t show it, the scalability difference between Java 5.0 and Java 6 really does come from improvement in intrinsic locking, rather than from regression in <code class="literal">Reentrant-Lock</code>.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch13fn03" href="#ch13fn03" class="para">3</a>] </sup>When we started this book, <code class="literal">ReentrantLock</code> seemed the last word in lock scalability. Less than a year later, intrinsic locking gives it a good run for its money. Performance is not just a moving target, it can be a fast-moving target.</p></div></div></div></body></html>
