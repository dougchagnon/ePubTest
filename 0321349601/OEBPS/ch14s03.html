<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Explicit Condition Objects</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Explicit Condition Objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lev1sec3"/>Explicit Condition Objects</h2></div></div></div>

<p>As we saw in <a class="link" href="ch13.html" title="Chapter 13. Explicit Locks">Chapter 13</a>, explicit <code class="literal">Lock</code>s can be useful in some situations where intrinsic locks are too inflexible. Just as <code class="literal">Lock</code> is a generalization of intrinsic locks, <code class="literal">Condition</code> (see <a class="link" href="ch14s03.html#ch14list10" title="Example 14.10. Condition Interface.">Listing 14.10</a>) is a generalization of intrinsic condition queues.</p>
<p><a id="iddle1495" class="indexterm"/><a id="iddle1515" class="indexterm"/><a id="iddle1516" class="indexterm"/><a id="iddle1789" class="indexterm"/><a id="iddle1790" class="indexterm"/><a id="iddle2506" class="indexterm"/><a id="iddle2507" class="indexterm"/><a id="iddle2798" class="indexterm"/><a id="iddle3041" class="indexterm"/><a id="iddle4895" class="indexterm"/><a id="iddle4896" class="indexterm"/><a id="iddle5137" class="indexterm"/><a id="iddle5138" class="indexterm"/><a id="iddle5141" class="indexterm"/>Intrinsic condition queues have several drawbacks. Each intrinsic lock can have only one associated condition queue, which means that in classes like <code class="literal">BoundedBuffer</code> multiple threads might wait on the same condition queue for different condition predicates, and the most common pattern for locking involves exposing the condition queue object. Both of these factors make it impossible to enforce the uniform waiter requirement for using <code class="literal">notify</code>. If you want to write a concurrent object with multiple condition predicates, or you want to exercise more control over the visibility of the condition queue, the explicit <code class="literal">Lock</code> and <code class="literal">Condition</code> classes offer a more flexible alternative to intrinsic locks and condition queues.</p>
<p>A <code class="literal">Condition</code> is associated with a single <code class="literal">Lock</code>, just as a condition queue is associated with a single intrinsic lock; to create a <code class="literal">Condition</code>, call <code class="literal">Lock.newCondition</code> on the associated lock. And just as <code class="literal">Lock</code> offers a richer feature set than intrinsic locking, <code class="literal">Condition</code> offers a richer feature set than intrinsic condition queues: multiple wait sets per lock, interruptible and uninterruptible condition waits, deadline-based waiting, and a choice of fair or nonfair queueing.</p>
<div class="example"><a id="ch14list10"/><p class="title"><b>Example 14.10. <code class="literal">Condition</code> Interface.</b></p><div class="example-contents">

<pre class="programlisting">public interface Condition {
    void await() throws InterruptedException;
    boolean await(long time, TimeUnit unit)
            throws InterruptedException;
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    void awaitUninterruptibly();
    boolean awaitUntil(Date deadline) throws InterruptedException;

    void signal();
    void signalAll();
}
</pre>
</div></div><br class="example-break"/>
<p>Unlike intrinsic condition queues, you can have as many <code class="literal">Condition</code> objects per <code class="literal">Lock</code> as you want. <code class="literal">Condition</code> objects inherit the fairness setting of their associated <code class="literal">Lock</code>; for fair locks, threads are released from <code class="literal">Condition.await</code> in FIFO order.</p>
<div class="sidebar"><a id="ch14sb06"/><p class="title"><b/></p>
<p title="Hazard warning:"><b>Hazard warning: </b>The equivalents of <code class="literal">wait</code>, <code class="literal">notify</code>, and <code class="literal">notifyAll</code> for <code class="literal">Condition</code> objects are <code class="literal">await</code>, <code class="literal">signal</code>, and <code class="literal">signalAll</code>. However, <code class="literal">Condition</code> extends <code class="literal">Object</code>, which means that it also has <code class="literal">wait</code> and <code class="literal">notify</code> methods. Be sure to use the proper versions—<code class="literal">await</code> and <code class="literal">signal</code>—instead!</p>
</div>
<p><a class="link" href="ch14s04.html#ch14list11" title="Example 14.11. Bounded Buffer Using Explicit Condition Variables.">Listing 14.11</a> shows yet another bounded buffer implementation, this time using two <code class="literal">Condition</code>s, <code class="literal">notFull</code> and <code class="literal">notEmpty</code>, to represent explicitly the “not full” and “not empty” condition predicates. When <code class="literal">take</code> blocks because the buffer is empty, it waits on <code class="literal">notEmpty</code>, and <code class="literal">put</code> unblocks any threads blocked in <code class="literal">take</code> by signaling on <code class="literal">notEmpty</code>.</p>
<p><a id="iddle2102" class="indexterm"/><a id="iddle1016" class="indexterm"/><a id="iddle1104" class="indexterm"/><a id="iddle1105" class="indexterm"/><a id="iddle1106" class="indexterm"/><a id="iddle1116" class="indexterm"/><a id="iddle1497" class="indexterm"/><a id="iddle1498" class="indexterm"/><a id="iddle1502" class="indexterm"/><a id="iddle1595" class="indexterm"/><a id="iddle1619" class="indexterm"/><a id="iddle2101" class="indexterm"/><a id="iddle2403" class="indexterm"/><a id="iddle2404" class="indexterm"/><a id="iddle2405" class="indexterm"/><a id="iddle2406" class="indexterm"/><a id="iddle2407" class="indexterm"/><a id="iddle3077" class="indexterm"/><a id="iddle3817" class="indexterm"/><a id="iddle4143" class="indexterm"/><a id="iddle4192" class="indexterm"/><a id="iddle4193" class="indexterm"/><a id="iddle4278" class="indexterm"/><a id="iddle4279" class="indexterm"/><a id="iddle4591" class="indexterm"/>The behavior of <code class="literal">ConditionBoundedBuffer</code> is the same as <code class="literal">BoundedBuffer</code>, but its use of condition queues is more readable—it is easier to analyze a class that uses multiple <code class="literal">Condition</code>s than one that uses a single intrinsic condition queue with multiple condition predicates. By separating the two condition predicates into separate wait sets, <code class="literal">Condition</code> makes it easier to meet the requirements for single notification. Using the more efficient <code class="literal">signal</code> instead of <code class="literal">signalAll</code> reduces the number of context switches and lock acquisitions triggered by each buffer operation.</p>
<p>Just as with built-in locks and condition queues, the three-way relationship among the lock, the condition predicate, and the condition variable must also hold when using explicit <code class="literal">Lock</code>s and <code class="literal">Condition</code>s. The variables involved in the condition predicate must be guarded by the <code class="literal">Lock</code>, and the <code class="literal">Lock</code> must be held when testing the condition predicate and when calling <code class="literal">await</code> and <code class="literal">signal</code>.<sup>[<a id="ch14fn11" href="#ftn.ch14fn11" class="footnote">11</a>]</sup></p>
<p>Choose between using explicit <code class="literal">Condition</code>s and intrinsic condition queues in the same way as you would choose between <code class="literal">ReentrantLock</code> and <code class="literal">synchronized</code>: use <code class="literal">Condition</code> if you need its advanced features such as fair queueing or multiple wait sets per lock, and otherwise prefer intrinsic condition queues. (If you already use <code class="literal">ReentrantLock</code> because you need its advanced features, the choice is already made.)</p>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch14fn11" href="#ch14fn11" class="para">11</a>] </sup><code class="literal">ReentrantLock</code> requires that the <code class="literal">Lock</code> be held when calling <code class="literal">signal</code> or <code class="literal">signalAll</code>, but <code class="literal">Lock</code> implementations are permitted to construct <code class="literal">Condition</code>s that do not have this requirement.</p></div></div></div></body></html>
