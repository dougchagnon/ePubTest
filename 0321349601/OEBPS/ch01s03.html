<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Risks of Threads</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Risks of Threads"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lev1sec3"/>Risks of Threads</h2></div></div></div>

<p>Java’s built-in support for threads is a double-edged sword. While it simplifies the development of concurrent applications by providing language and library support and a formal cross-platform memory model (it is this formal cross-platform memory model thatmakes possible the development of write-once, run-anywhere <span class="emphasis"><em>concurrent</em></span> applications in Java), it also raises the bar for developers because more programs will use threads. When threads were more esoteric, concurrency was an “advanced” topic; now, mainstream developers must be aware of thread-safety issues.</p>
<div class="section" title="Safety Hazards"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lev2sec5"/>Safety Hazards</h3></div></div></div>

<p>Thread safety can be unexpectedly subtle because, in the absence of sufficient synchronization, the ordering of operations in multiple threads is unpredictable and sometimes surprising. <code class="literal">UnsafeSequence</code> in <a class="link" href="ch01s03.html#ch01list01" title="Example 1.1. Non-thread-safe Sequence Generator.">Listing 1.1</a>, which is supposed to generate a sequence of unique integer values, offers a simple illustration of how the interleaving of actions in multiple threads can lead to undesirable results. It behaves correctly in a single-threaded environment, but in a multithreaded environment does not.</p>

<p/><div class="example"><a id="ch01list01"/><p class="title"><b>Example 1.1. Non-thread-safe Sequence Generator.</b></p><div class="example-contents">


<div class="mediaobject"><img src="graphics/face1.jpg" width="45" alt="Non-thread-safe Sequence Generator."/></div>
<pre class="programlisting">@NotThreadSafe
public class UnsafeSequence {
    private int value;

    <span class="emphasis"><em>/** Returns a unique value. */</em></span>
    public int getNext() {
        return value++;
    }
}
</pre>
</div></div><br class="example-break"/>
<p><a id="iddle1094" class="indexterm"/><a id="iddle1635" class="indexterm"/><a id="iddle1636" class="indexterm"/><a id="iddle1637" class="indexterm"/><a id="iddle1959" class="indexterm"/><a id="iddle2537" class="indexterm"/><a id="iddle2768" class="indexterm"/><a id="iddle2769" class="indexterm"/><a id="iddle3338" class="indexterm"/><a id="iddle4465" class="indexterm"/><a id="iddle4466" class="indexterm"/>The problem with <code class="literal">UnsafeSequence</code> is that with some unlucky timing, two threads could call <code class="literal">getNext</code> and receive <span class="emphasis"><em>the same value</em></span>. <a class="link" href="ch01s03.html#ch01fig01" title="Figure 1.1. Unlucky Execution of UnsafeSequence.getNext.">Figure 1.1</a> shows how this can happen. The increment notation, <code class="literal">someVariable++</code>, may <span class="emphasis"><em>appear</em></span> to be a single operation, but is in fact three separate operations: read the value, add one to it, and write out the new value. Since operations in multiple threads may be arbitrarily interleaved by the runtime, it is possible for two threads to read the value at the same time, both see the same value, and then both add one to it. The result is that the same sequence number is returned from multiple calls in different threads.</p>
<div class="figure-float"><div class="figure"><a id="ch01fig01"/><p class="title"><b>Figure 1.1. Unlucky Execution of <code class="literal">UnsafeSequence.getNext</code>.</b></p><div class="figure-contents">


<div class="mediaobject"><img src="graphics/01fig01.gif" height="134" alt="Unlucky Execution of UnsafeSequence.getNext."/></div>
</div></div><br class="figure-break"/></div>
<div class="sidebar"><a id="ch01sb01"/><p class="title"><b/></p>
<p>Diagrams like <a class="link" href="ch01s03.html#ch01fig01" title="Figure 1.1. Unlucky Execution of UnsafeSequence.getNext.">Figure 1.1</a> depict possible interleavings of operations in different threads. In these diagrams, time runs from left to right, and each line represents the activities of a different thread. These interleaving diagrams usually depict the worst case<sup>[<a id="ch01fn02" href="#ftn.ch01fn02" class="footnote">2</a>]</sup> and are intended to show the danger of incorrectly assuming things will happen in a particular order.</p>
</div>
<p><code class="literal">UnsafeSequence</code> uses a nonstandard annotation: <code class="literal">@NotThreadSafe</code>. This is one of several custom annotations used throughout this book to document concurrency properties of classes and class members. (Other class-level annotations used <a id="iddle1395" class="indexterm"/><a id="iddle1396" class="indexterm"/><a id="iddle2175" class="indexterm"/><a id="iddle2481" class="indexterm"/><a id="iddle2621" class="indexterm"/><a id="iddle2622" class="indexterm"/><a id="iddle2703" class="indexterm"/><a id="iddle3415" class="indexterm"/><a id="iddle3416" class="indexterm"/><a id="iddle3544" class="indexterm"/><a id="iddle3545" class="indexterm"/><a id="iddle3776" class="indexterm"/><a id="iddle3777" class="indexterm"/><a id="iddle3778" class="indexterm"/><a id="iddle4020" class="indexterm"/><a id="iddle4021" class="indexterm"/><a id="iddle4022" class="indexterm"/><a id="iddle4566" class="indexterm"/><a id="iddle4860" class="indexterm"/><a id="iddle48911" class="indexterm"/><a id="iddle4915" class="indexterm"/>in this way are <code class="literal">@ThreadSafe</code> and <code class="literal">@Immutable</code>; see <a class="link" href="apa.html" title="Appendix A. Annotations for Concurrency">Appendix A</a> for details.) Annotations documenting thread safety are useful to multiple audiences. If a class is annotated with <code class="literal">@ThreadSafe</code>, users can use it with confidence in a multithreaded environment, maintainers are put on notice that it makes thread safety guarantees that must be preserved, and software analysis tools can identify possible coding errors.</p>
<p><code class="literal">UnsafeSequence</code> illustrates a common concurrency hazard called a <span class="emphasis"><em>race condition</em></span>. Whether or not <code class="literal">getNext</code> returns a unique value when called from multiple threads, as required by its specification, depends on how the runtime interleaves the operations—which is not a desirable state of affairs.</p>
<p>Because threads share the same memory address space and run concurrently, they can access or modify variables that other threads might be using. This is a tremendous convenience, because it makes data sharing much easier than would other inter-thread communications mechanisms. But it is also a significant risk: threads can be confused by having data change unexpectedly. Allowing multiple threads to access and modify the same variables introduces an element of nonsequentiality into an otherwise sequential programming model, which can be confusing and difficult to reason about. For a multithreaded program’s behavior to be predictable, access to shared variables must be properly coordinated so that threads do not interfere with one another. Fortunately, Java provides synchronization mechanisms to coordinate such access.</p>
<p><code class="literal">UnsafeSequence</code> can be fixed by making <code class="literal">getNext</code> a <code class="literal">synchronized</code> method, as shown in <code class="literal">Sequence</code> in <a class="link" href="ch01s03.html#ch01list02" title="Example 1.2. Thread-safe Sequence Generator.">Listing 1.2</a>,<sup>[<a id="ch01fn03" href="#ftn.ch01fn03" class="footnote">3</a>]</sup> thus preventing the unfortunate interaction in <a class="link" href="ch01s03.html#ch01fig01" title="Figure 1.1. Unlucky Execution of UnsafeSequence.getNext.">Figure 1.1</a>. (Exactly why this works is the subject of <a class="link" href="ch02.html" title="Chapter 2. Thread Safety">Chapters 2</a> and <a class="link" href="ch03.html" title="Chapter 3. Sharing Objects">3</a>.)</p>
<div class="example"><a id="ch01list02"/><p class="title"><b>Example 1.2. Thread-safe Sequence Generator.</b></p><div class="example-contents">

<pre class="programlisting">@ThreadSafe
public class Sequence {
    <span class="strong"><strong>@GuardedBy("this")</strong></span> private int Value;

    public <span class="strong"><strong>synchronized</strong></span> int getNext() {
        return Value++;
    }
}
</pre>
</div></div><br class="example-break"/>
<p>In the absence of synchronization, the compiler, hardware, and runtime are allowed to take substantial liberties with the timing and ordering of actions, such as caching variables in registers or processor-local caches where they are temporarily (or even permanently) invisible to other threads. These tricks are in aid of better performance and are generally desirable, but they place a burden on the developer to clearly identify where data is being shared across threads so that these optimizations do not undermine safety. (<a class="link" href="ch16.html" title="Chapter 16. The Java Memory Model">Chapter 16</a> gives the gory details on exactly what ordering guarantees the JVM makes and how synchronization <a id="iddle1261" class="indexterm"/><a id="iddle1279" class="indexterm"/><a id="iddle1614" class="indexterm"/><a id="iddle1693" class="indexterm"/><a id="iddle1694" class="indexterm"/><a id="iddle1709" class="indexterm"/><a id="iddle1758" class="indexterm"/><a id="iddle1797" class="indexterm"/><a id="iddle1991" class="indexterm"/><a id="iddle2074" class="indexterm"/><a id="iddle2075" class="indexterm"/><a id="iddle2616" class="indexterm"/><a id="iddle2950" class="indexterm"/><a id="iddle3014" class="indexterm"/><a id="iddle3015" class="indexterm"/><a id="iddle3016" class="indexterm"/><a id="iddle3028" class="indexterm"/><a id="iddle3031" class="indexterm"/><a id="iddle3037" class="indexterm"/><a id="iddle3038" class="indexterm"/><a id="iddle3422" class="indexterm"/><a id="iddle3423" class="indexterm"/><a id="iddle3424" class="indexterm"/><a id="iddle3425" class="indexterm"/><a id="iddle3426" class="indexterm"/><a id="iddle3477" class="indexterm"/><a id="iddle3478" class="indexterm"/><a id="iddle3479" class="indexterm"/><a id="iddle3480" class="indexterm"/><a id="iddle3481" class="indexterm"/><a id="iddle3494" class="indexterm"/><a id="iddle3495" class="indexterm"/><a id="iddle3511" class="indexterm"/><a id="iddle3512" class="indexterm"/><a id="iddle3543" class="indexterm"/><a id="iddle3907" class="indexterm"/><a id="iddle3908" class="indexterm"/><a id="iddle3974" class="indexterm"/><a id="iddle4087" class="indexterm"/><a id="iddle4227" class="indexterm"/><a id="iddle4372" class="indexterm"/><a id="iddle4759" class="indexterm"/><a id="iddle4760" class="indexterm"/><a id="iddle4761" class="indexterm"/><a id="iddle4867" class="indexterm"/><a id="iddle4878" class="indexterm"/>affects those guarantees, but if you follow the rules in <a class="link" href="ch02.html" title="Chapter 2. Thread Safety">Chapters 2</a> and <a class="link" href="ch03.html" title="Chapter 3. Sharing Objects">3</a>, you can safely avoid these low-level details.)</p>
</div>
<div class="section" title="Liveness Hazards"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lev2sec6"/>Liveness Hazards</h3></div></div></div>

<p>It is critically important to pay attention to thread safety issues when developing concurrent code: safety cannot be compromised. The importance of safety is not unique to multithreaded programs—single-threaded programs also must take care to preserve safety and correctness—but the use of threads introduces additional safety hazards not present in single-threaded programs. Similarly, the use of threads introduces additional forms of <span class="emphasis"><em>liveness failure</em></span> that do not occur in single-threaded programs.</p>
<p>While <span class="emphasis"><em>safety</em></span> means “nothing bad ever happens”, liveness concerns the complementary goal that “something good eventually happens”. A liveness failure occurs when an activity gets into a state such that it is permanently unable to make forward progress. One form of liveness failure that can occur in sequential programs is an inadvertent infinite loop, where the code that follows the loop never gets executed. The use of threads introduces additional liveness risks. For example, if thread <span class="emphasis"><em>A</em></span> is waiting for a resource that thread <span class="emphasis"><em>B</em></span> holds exclusively, and <span class="emphasis"><em>B</em></span> never releases it, <span class="emphasis"><em>A</em></span> will wait forever. <a class="link" href="ch10.html" title="Chapter 10. Avoiding Liveness Hazards">Chapter 10</a> describes various forms of liveness failures and how to avoid them, including deadlock (<a class="link" href="ch10.html#ch10lev1sec1" title="Deadlock">Section 10.1</a>), starvation (<a class="link" href="ch10s03.html#ch10lev2sec8" title="Starvation">Section 10.3.1</a>), and livelock (<a class="link" href="ch10s03.html#ch10lev2sec10" title="Livelock">Section 10.3.3</a>). Like most concurrency bugs, bugs that cause liveness failures can be elusive because they depend on the relative timing of events in different threads, and therefore do not always manifest themselves in development or testing.</p>
</div>
<div class="section" title="Performance Hazards"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lev2sec7"/>Performance Hazards</h3></div></div></div>

<p>Related to liveness is <span class="emphasis"><em>performance</em></span>. While liveness means that something good <span class="emphasis"><em>eventually</em></span> happens, eventually may not be good enough—we often want good things to happen quickly. Performance issues subsume a broad range of problems, including poor service time, responsiveness, throughput, resource consumption, or scalability. Just as with safety and liveness, multithreaded programs are subject to all the performance hazards of single-threaded programs, and to others as well that are introduced by the use of threads.</p>
<p>In well designed concurrent applications the use of threads is a net performance gain, but threads nevertheless carry some degree of runtime overhead. <span class="emphasis"><em>Context switches</em></span>—when the scheduler suspends the active thread temporarily so another thread can run—are more frequent in applications with many threads, and have significant costs: saving and restoring execution context, loss of locality, and CPU time spent scheduling threads instead of running them. When threads share data, they must use synchronization mechanisms that can inhibit compiler optimizations, flush or invalidate memory caches, and create synchronization traffic on the shared memory bus. All these factors introduce additional performance costs; <a class="link" href="ch11.html" title="Chapter 11. Performance and Scalability">Chapter 11</a> covers techniques for analyzing and reducing these costs.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch01fn02" href="#ch01fn02" class="para">2</a>] </sup>Actually, as we’ll see in <a class="link" href="ch03.html" title="Chapter 3. Sharing Objects">Chapter 3</a>, the worst case can be even worse than these diagrams usually show because of the possibility of reordering.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn03" href="#ch01fn03" class="para">3</a>] </sup><code class="literal">@GuardedBy</code> is described in <a class="link" href="ch02s04.html" title="Guarding State with Locks">Section 2.4</a>; it documents the <span class="emphasis"><em>synchronization policy</em></span> for <code class="literal">Sequence</code>.</p></div></div></div></body></html>
