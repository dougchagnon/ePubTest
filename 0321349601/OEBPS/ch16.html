<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 16. The Java Memory Model</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="chapter" title="Chapter 16. The Java Memory Model"><div class="titlepage"><div><div><h1 class="title"><a id="ch16"/>Chapter 16. The Java Memory Model</h1></div></div></div>




<p><a id="iddle1014" class="indexterm"/><a id="iddle1015" class="indexterm"/><a id="iddle2892" class="indexterm"/><a id="iddle2893" class="indexterm"/><a id="iddle2894" class="indexterm"/><a id="iddle2895" class="indexterm"/><a id="iddle2908" class="indexterm"/><a id="iddle3202" class="indexterm"/><a id="iddle3216" class="indexterm"/><a id="iddle3217" class="indexterm"/><a id="iddle3218" class="indexterm"/><a id="iddle3219" class="indexterm"/><a id="iddle3224" class="indexterm"/><a id="iddle3230" class="indexterm"/><a id="iddle3444" class="indexterm"/><a id="iddle4135" class="indexterm"/><a id="iddle4224" class="indexterm"/><a id="iddle5155" class="indexterm"/>Throughout this book, we’ve mostly avoided the low-level details of the Java Memory Model (JMM) and instead focused on higher-level design issues such as safe publication, specification of, and adherence to synchronization policies. These derive their safety from the JMM, and you may find it easier to use these mechanisms effectively when you understand <span class="emphasis"><em>why</em></span> they work. This chapter pulls back the curtain to reveal the low-level requirements and guarantees of the Java Memory Model and the reasoning behind some of the higher-level design rules offered in this book.</p>



<div class="section" title="What is a Memory Model, and Why would I Want One?"><div class="titlepage"><div><div><h2 class="title"><a id="ch16lev1sec1"/>What is a Memory Model, and Why would I Want One?</h2></div></div></div>

<p>Suppose one thread assigns a value to <code class="literal">aVariable</code>:</p>
<div class="informalexample">
<pre class="programlisting">aVariable = 3;</pre>
</div>
<p class="continued">A memory model addresses the question “Under what conditions does a thread that reads <code class="literal">aVariable</code> see the value 3?” This may sound like a dumb question, but in the absence of synchronization, there are a number of reasons a threadmight not immediately—or ever—see the results of an operation in another thread. Compilers may generate instructions in a different order than the “obvious” one suggested by the source code, or store variables in registers instead of in memory; processors may execute instructions in parallel or out of order; caches may vary the order in which writes to variables are committed to main memory; and values stored in processor-local caches may not be visible to other processors. These factors can prevent a thread from seeing the most up-to-date value for a variable and can cause memory actions in other threads to appear to happen out of order—if you don’t use adequate synchronization.</p>
<p>In a single-threaded environment, all these tricks played on our program by the environment are hidden from us and have no effect other than to speed up execution. The Java Language Specification requires the JVM to maintain <span class="emphasis"><em>withinthread as-if-serial semantics</em></span>: as long as the program has the same result as if it were executed in program order in a strictly sequential environment, all these games are permissible. And that’s a good thing, too, because these rearrangements are responsible for much of the improvement in computing performance <a id="iddle1196" class="indexterm"/><a id="iddle2620" class="indexterm"/><a id="iddle3195" class="indexterm"/><a id="iddle3200" class="indexterm"/><a id="iddle3201" class="indexterm"/><a id="iddle3205" class="indexterm"/><a id="iddle3222" class="indexterm"/><a id="iddle3223" class="indexterm"/><a id="iddle3263" class="indexterm"/><a id="iddle3264" class="indexterm"/><a id="iddle4160" class="indexterm"/><a id="iddle4233" class="indexterm"/><a id="iddle4234" class="indexterm"/><a id="iddle5102" class="indexterm"/><a id="iddle5103" class="indexterm"/>in recent years. Certainly higher clock rates have contributed to improved performance, but so has increased parallelism—pipelined superscalar execution units, dynamic instruction scheduling, speculative execution, and sophisticated multilevel memory caches. As processors have become more sophisticated, so too have compilers, rearranging instructions to facilitate optimal execution and using sophisticated global register-allocation algorithms. And as processor manufacturers transition to multicore processors, largely because clock rates are getting harder to increase economically, hardware parallelism will only increase.</p>
<p>In a multithreaded environment, the illusion of sequentiality cannot be maintained without significant performance cost. Sincemost of the time threads within a concurrent application are each “doing their own thing”, excessive inter-thread coordination would only slow down the application to no real benefit. It is only when multiple threads share data that it is necessary to coordinate their activities, and the JVM relies on the program to identify when this is happening by using synchronization.</p>
<p>The JMM specifies the minimal guarantees the JVM must make about when writes to variables become visible to other threads. It was designed to balance the need for predictability and ease of program development with the realities of implementing high-performance JVMs on a wide range of popular processor architectures. Some aspects of the JMM may be disturbing at first if you are not familiar with the tricks used by modern processors and compilers to squeeze extra performance out of your program.</p>
<div class="section" title="Platform Memory Models"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lev2sec1"/>Platform Memory Models</h3></div></div></div>

<p>In a shared-memory multiprocessor architecture, each processor has its own cache that is periodically reconciled with main memory. Processor architectures provide varying degrees of <span class="emphasis"><em>cache coherence</em></span>; some provide minimal guarantees that allow different processors to see different values for the same memory location at virtually any time. The operating system, compiler, and runtime (and sometimes, the program, too) must make up the difference between what the hardware provides and what thread safety requires.</p>
<p>Ensuring that every processor knows what every other processor is doing at all times is expensive. Most of the time this information is not needed, so processors relax their memory-coherency guarantees to improve performance. An architecture’s <span class="emphasis"><em>memory model</em></span> tells programs what guarantees they can expect from the memory system, and specifies the special instructions required (called <span class="emphasis"><em>memory barriers</em></span> or <span class="emphasis"><em>fences</em></span>) to get the additional memory coordination guarantees required when sharing data. In order to shield the Java developer from the differences between memory models across architectures, Java provides its own memory model, and the JVMdeals with the differences between the JMMand the underlying platform’s memory model by inserting memory barriers at the appropriate places.</p>
<p>One convenient mental model for program execution is to imagine that there is a single order in which the operations happen in a program, regardless of what processor they execute on, and that each read of a variable will see the last write in the execution order to that variable by any processor. This happy, if unrealistic, model is called <span class="emphasis"><em>sequential consistency</em></span>. Software developers often <a id="iddle1040" class="indexterm"/><a id="iddle2775" class="indexterm"/><a id="iddle3203" class="indexterm"/><a id="iddle3204" class="indexterm"/><a id="iddle3856" class="indexterm"/>mistakenly assume sequential consistency, but no modern multiprocessor offers sequential consistency and the JMM does not either. The classic sequential computing model, the von Neumann model, is only a vague approximation of how modern multiprocessors behave.</p>
<p>The bottom line is that modern shared-memory multiprocessors (and compilers) can do some surprising things when data is shared across threads, unless you’ve told them not to through the use of memory barriers. Fortunately, Java programs need not specify the placement of memory barriers; they need only identify when shared state is being accessed, through the proper use of synchronization.</p>
</div>
<div class="section" title="Reordering"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lev2sec2"/>Reordering</h3></div></div></div>

<p>In describing race conditions and atomicity failures in <a class="link" href="ch02.html" title="Chapter 2. Thread Safety">Chapter 2</a>, we used interaction diagrams depicting “unlucky timing” where the scheduler interleaved operations so as to cause incorrect results in insufficiently synchronized programs. To make matters worse, the JMM can permit actions to appear to execute in different orders from the perspective of different threads, making reasoning about ordering in the absence of synchronization even more complicated. The various reasons why operations might be delayed or appear to execute out of order can all be grouped into the general category of <span class="emphasis"><em>reordering</em></span>.</p>
<p><code class="literal">PossibleReordering</code> in <a class="link" href="ch16.html#ch16list01" title="Example 16.1. Insufficiently Synchronized Program that can have Surprising Results. Don’t Do this.">Listing 16.1</a> illustrates how difficult it is to reason about the behavior of even the simplest concurrent programs unless they are correctly synchronized. It is fairly easy to imagine how <code class="literal">PossibleReordering</code> could print (1, 0), or (0, 1), or (1, 1): thread <span class="emphasis"><em>A</em></span> could run to completion before <span class="emphasis"><em>B</em></span> starts, <span class="emphasis"><em>B</em></span> could run to completion before <span class="emphasis"><em>A</em></span> starts, or their actions could be interleaved. But, strangely, <code class="literal">PossibleReordering</code> can also print (0, 0)! The actions in each thread have no dataflow dependence on each other, and accordingly can be executed out of order. (Even if they are executed in order, the timing by which caches are flushed to main memory can make it appear, from the perspective of <span class="emphasis"><em>B</em></span>, that the assignments in <span class="emphasis"><em>A</em></span> occurred in the opposite order.) <a class="link" href="ch16.html#ch16fig01" title="Figure 16.1. Interleaving Showing Reordering in PossibleReordering.">Figure 16.1</a> shows a possible interleaving with reordering that results in printing (0, 0).</p>
<div class="figure-float"><div class="figure"><a id="ch16fig01"/><p class="title"><b>Figure 16.1. Interleaving Showing Reordering in <code class="literal">PossibleReordering</code>.</b></p><div class="figure-contents">


<div class="mediaobject"><img src="graphics/16fig01.gif" height="119" alt="Interleaving Showing Reordering in PossibleReordering."/></div>
</div></div><br class="figure-break"/></div>
<p><a id="iddle2155" class="indexterm"/><a id="iddle2612" class="indexterm"/><a id="iddle2613" class="indexterm"/><a id="iddle3411" class="indexterm"/><a id="iddle3412" class="indexterm"/><a id="iddle3460" class="indexterm"/><a id="iddle3463" class="indexterm"/><code class="literal">PossibleReordering</code> is a trivial program, and it is still surprisingly tricky to enumerate its possible results. Reordering at the memory level can make programs behave unexpectedly. It is prohibitively difficult to reason about ordering in the absence of synchronization; it is much easier to ensure that your program uses synchronization appropriately. Synchronization inhibits the compiler, runtime, and hardware from reordering memory operations in ways that would violate the visibility guarantees provided by the JMM.<sup>[<a id="ch16fn01" href="#ftn.ch16fn01" class="footnote">1</a>]</sup></p>
</div>
<div class="section" title="The Java Memory Model in 500 Words or Less"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lev2sec3"/>The Java Memory Model in 500 Words or Less</h3></div></div></div>

<p>The Java Memory Model is specified in terms of <span class="emphasis"><em>actions</em></span>, which include reads and writes to variables, locks and unlocks of monitors, and starting and joining with threads. The JMM defines a partial ordering <sup>[<a id="ch16fn02" href="#ftn.ch16fn02" class="footnote">2</a>]</sup> called <span class="emphasis"><em>happens-before</em></span> on all actions within the program. To guarantee that the thread executing action <span class="emphasis"><em>B</em></span> can see the results of action <span class="emphasis"><em>A</em></span> (whether or not <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span> occur in different threads), there must be a <span class="emphasis"><em>happens-before</em></span> relationship between <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span>. In the absence of a <span class="emphasis"><em>happens-before</em></span> ordering between two operations, the JVM is free to reorder them as it pleases.</p>
<div class="example"><a id="ch16list01"/><p class="title"><b>Example 16.1. Insufficiently Synchronized Program that can have Surprising Results. <span class="emphasis"><em>Don’t Do this.</em></span></b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face.jpg" width="52" alt="Insufficiently Synchronized Program that can have Surprising Results. Don’t Do this."/></div>
<pre class="programlisting">public class PossibleReordering {
    static int x = 0, y = 0;
    static int a = 0, b = 0;

    public static void main(String[] args)
            throws InterruptedException {
        Thread one = new Thread(new Runnable() {
            public void run() {
                a = 1;
                x = b;
            }
        });
        Thread other = new Thread(new Runnable() {
            public void run() {
                b = 1;
                y = a;
            }
        });
        one.start(); other.start();
        one.join();   other.join();
        System.out.println("( "+ x + "," + y + ")");
    }
}
</pre>
</div></div><br class="example-break"/>
<p><a id="iddle1675" class="indexterm"/><a id="iddle1763" class="indexterm"/><a id="iddle3417" class="indexterm"/><a id="iddle3418" class="indexterm"/><a id="iddle4013" class="indexterm"/><a id="iddle4547" class="indexterm"/>A <span class="emphasis"><em>data race</em></span> occurs when a variable is read by more than one thread, and written by at least one thread, but the reads and writes are not ordered by <span class="emphasis"><em>happens-before</em></span>. A <span class="emphasis"><em>correctly synchronized program</em></span> is one with no data races; correctly synchronized programs exhibit sequential consistency, meaning that all actions within the program appear to happen in a fixed, global order.</p>
<div class="sidebar"><a id="ch16sb01"/><p class="title"><b/></p>
<p>The rules for <span class="emphasis"><em>happens-before</em></span> are:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="Program order rule."><b><span class="strong"><strong>Program order rule.</strong></span> </b>Each action in a thread <span class="emphasis"><em>happens-before</em></span> every action in that thread that comes later in the program order.</p></li><li class="listitem"><p title="Monitor lock rule."><b><span class="strong"><strong>Monitor lock rule.</strong></span> </b>An unlock on a monitor lock <span class="emphasis"><em>happens-before</em></span> every subsequent lock on that same monitor lock.<sup>[<a id="ch16fn03" href="#ftn.ch16fn03" class="footnote">3</a>]</sup></p></li><li class="listitem"><p title="Volatile variable rule."><b><span class="strong"><strong>Volatile variable rule.</strong></span> </b>A write to a volatile field <span class="emphasis"><em>happens-before</em></span> every subsequent read of that same field.<sup>[<a id="ch16fn04" href="#ftn.ch16fn04" class="footnote">4</a>]</sup></p></li><li class="listitem"><p title="Thread start rule."><b><span class="strong"><strong>Thread start rule.</strong></span> </b>A call to <code class="literal">Thread.start</code> on a thread <span class="emphasis"><em>happens-before</em></span> every action in the started thread.</p></li><li class="listitem"><p title="Thread termination rule."><b><span class="strong"><strong>Thread termination rule.</strong></span> </b>Any action in a thread <span class="emphasis"><em>happens-before</em></span> any other thread detects that thread has terminated, either by successfully return from <code class="literal">Thread.join</code> or by <code class="literal">Thread.isAlive</code> returning <code class="literal">false</code>.</p></li><li class="listitem"><p title="Interruption rule."><b><span class="strong"><strong>Interruption rule.</strong></span> </b>A thread calling <code class="literal">interrupt</code> on another thread <span class="emphasis"><em>happens-before</em></span> the interrupted thread detects the interrupt (either by having <code class="literal">InterruptedException</code> thrown, or invoking <code class="literal">isInterrupted</code> or <code class="literal">interrupted</code>).</p></li><li class="listitem"><p title="Finalizer rule."><b><span class="strong"><strong>Finalizer rule.</strong></span> </b>The end of a constructor for an object <span class="emphasis"><em>happens-before</em></span> the start of the finalizer for that object.</p></li><li class="listitem"><p title="Transitivity."><b><span class="strong"><strong>Transitivity.</strong></span> </b>If <span class="emphasis"><em>A happens-before B</em></span>, and <span class="emphasis"><em>B happens-before C</em></span>, then <span class="emphasis"><em>A happens-before C</em></span>.</p></li></ul></div>
</div>
<p class="continued">Even though actions are only partially ordered, synchronization actions—lock acquisition and release, and reads and writes of <code class="literal">volatile</code> variables—are totally ordered. This makes it sensible to describe <span class="emphasis"><em>happens-before</em></span> in terms of “subsequent” lock acquisitions and reads of <code class="literal">volatile</code> variables.</p>
<p><a class="link" href="ch16.html#ch16fig02" title="Figure 16.2. Illustration of Happens-before in the Java Memory Model.">Figure 16.2</a> illustrates the <span class="emphasis"><em>happens-before</em></span> relation when two threads synchronize using a common lock. All the actions within thread <span class="emphasis"><em>A</em></span> are ordered by the program <a id="iddle1119" class="indexterm"/><a id="iddle1120" class="indexterm"/><a id="iddle2396" class="indexterm"/><a id="iddle2614" class="indexterm"/><a id="iddle3413" class="indexterm"/><a id="iddle3464" class="indexterm"/><a id="iddle3554" class="indexterm"/><a id="iddle4562" class="indexterm"/>order rule, as are the actions within thread <span class="emphasis"><em>B</em></span>. Because <span class="emphasis"><em>A</em></span> releases lock <span class="emphasis"><em>M</em></span> and <span class="emphasis"><em>B</em></span> subsequently acquires <span class="emphasis"><em>M</em></span>, all the actions in <span class="emphasis"><em>A</em></span> before releasing the lock are therefore ordered before the actions in <span class="emphasis"><em>B</em></span> after acquiring the lock. When two threads synchronize on <span class="emphasis"><em>different</em></span> locks, we can’t say anything about the ordering of actions between them—there is no <span class="emphasis"><em>happens-before</em></span> relation between the actions in the two threads.</p>
<div class="figure-float"><div class="figure"><a id="ch16fig02"/><p class="title"><b>Figure 16.2. Illustration of <span class="emphasis"><em>Happens-before</em></span> in the Java Memory Model.</b></p><div class="figure-contents">


<div class="mediaobject"><img src="graphics/16fig02.gif" width="500" alt="Illustration of Happens-before in the Java Memory Model."/></div>
</div></div><br class="figure-break"/></div>
</div>
<div class="section" title="Piggybacking on Synchronization"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lev2sec4"/>Piggybacking on Synchronization</h3></div></div></div>

<p>Because of the strength of the <span class="emphasis"><em>happens-before</em></span> ordering, you can sometimes piggyback on the visibility properties of an existing synchronization. This entails combining the program order rule for <span class="emphasis"><em>happens-before</em></span> with one of the other ordering rules (usually the monitor lock or volatile variable rule) to order accesses to a variable not otherwise guarded by a lock. This technique is very sensitive to the order in which statements occur and is therefore quite fragile; it is an advanced technique that should be reserved for squeezing the last drop of performance out of the most performance-critical classes like <code class="literal">ReentrantLock</code>.</p>
<p>The implementation of the protected <code class="literal">AbstractQueuedSynchronizer</code> methods in <code class="literal">FutureTask</code> illustrates piggybacking. AQS maintains an integer of synchronizer state that <code class="literal">FutureTask</code> uses to store the task state: running, completed, or <a id="iddle2190" class="indexterm"/>cancelled. But <code class="literal">FutureTask</code> also maintains additional variables, such as the result of the computation. When one thread calls <code class="literal">set</code> to save the result and another thread calls <code class="literal">get</code> to retrieve it, the two had better be ordered by <span class="emphasis"><em>happens-before</em></span>. This could be done by making the reference to the result <code class="literal">volatile</code>, but it is possible to exploit existing synchronization to achieve the same result at lower cost.</p>
<p><code class="literal">FutureTask</code> is carefully crafted to ensure that a successful call to <code class="literal">tryReleaseShared</code> always <span class="emphasis"><em>happens-before</em></span> a subsequent call to <code class="literal">tryAcquireShared</code>; <code class="literal">try-ReleaseShared</code> always writes to a volatile variable that is read by <code class="literal">tryAcquire-Shared</code>. <a class="link" href="ch16.html#ch16list02" title="Example 16.2. Inner Class of FutureTask Illustrating Synchronization Piggybacking.">Listing 16.2</a> shows the <code class="literal">innerSet</code> and <code class="literal">innerGet</code> methods that are called when the result is saved or retrieved; since <code class="literal">innerSet</code> writes <code class="literal">result</code> before calling <code class="literal">releaseShared</code> (which calls <code class="literal">tryReleaseShared</code>) and <code class="literal">innerGet</code> reads <code class="literal">result</code> after calling <code class="literal">acquireShared</code> (which calls <code class="literal">tryAcquireShared</code>), the program order rule combines with the volatile variable rule to ensure that the write of <code class="literal">result</code> in <code class="literal">innerGet</code> <span class="emphasis"><em>happens-before</em></span> the read of <code class="literal">result</code> in <code class="literal">innerGet</code>.</p>
<div class="example"><a id="ch16list02"/><p class="title"><b>Example 16.2. Inner Class of <code class="literal">FutureTask</code> Illustrating Synchronization Piggybacking.</b></p><div class="example-contents">

<div class="mediaobject"><img src="graphics/face1.jpg" width="45" alt="Inner Class of FutureTask Illustrating Synchronization Piggybacking."/></div>
<pre class="programlisting"><span class="emphasis"><em>// Inner class of FutureTask</em></span>
private final class Sync extends AbstractQueuedSynchronizer {
    private static final int RUNNING = 1, RAN = 2, CANCELLED = 4;
    private V result;
    private Exception exception;

    void innerSet(V v) {
        while (true) {
            int s = getState();
            if (ranOrCancelled(s))
                return;
            if (compareAndSetState(s, RAN))
                break;
        }
        result = v;
        releaseShared(0);
        done();
    }

    V innerGet() throws InterruptedException, ExecutionException {
        acquireSharedInterruptibly(0);
        if (getState() == CANCELLED)
            throw new CancellationException();
        if (exception != null)
            throw new ExecutionException(exception);
        return result;
    }
}
</pre>
</div></div><br class="example-break"/>
<p><a id="iddle3553" class="indexterm"/><a id="iddle3735" class="indexterm"/>We call this technique “piggybacking” because it uses an existing <span class="emphasis"><em>happensbefore</em></span> ordering that was created for some other reason to ensure the visibility of object <span class="emphasis"><em>X</em></span>, rather than creating a <span class="emphasis"><em>happens-before</em></span> ordering specifically for publishing <span class="emphasis"><em>X</em></span>.</p>
<p>Piggybacking of the sort employed by <code class="literal">FutureTask</code> is quite fragile and should not be undertaken casually. However, in some cases piggybacking is perfectly reasonable, such as when a class commits to a <span class="emphasis"><em>happens-before</em></span> ordering between methods as part of its specification. For example, safe publication using a <code class="literal">BlockingQueue</code> is a form of piggybacking. One thread putting an object on a queue and another thread subsequently retrieving it constitutes safe publication because there is guaranteed to be sufficient internal synchronization in a <code class="literal">BlockingQueue</code> implementation to ensure that the enqueue <span class="emphasis"><em>happens-before</em></span> the dequeue.</p>
<p>Other <span class="emphasis"><em>happens-before</em></span> orderings guaranteed by the class library include:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Placing an item in a thread-safe collection <span class="emphasis"><em>happens-before</em></span> another thread retrieves that item from the collection;</p></li><li class="listitem"><p>Counting down on a <code class="literal">CountDownLatch</code> <span class="emphasis"><em>happens-before</em></span> a thread returns from <code class="literal">await</code> on that latch;</p></li><li class="listitem"><p>Releasing a permit to a <code class="literal">Semaphore</code> <span class="emphasis"><em>happens-before</em></span> acquiring a permit from that same <code class="literal">Semaphore</code>;</p></li><li class="listitem"><p>Actions taken by the task represented by a <code class="literal">Future</code> <span class="emphasis"><em>happens-before</em></span> another thread successfully returns from <code class="literal">Future.get</code>;</p></li><li class="listitem"><p>Submitting a <code class="literal">Runnable</code> or <code class="literal">Callable</code> to an <code class="literal">Executor</code> <span class="emphasis"><em>happens-before</em></span> the task begins execution; and</p></li><li class="listitem"><p>A thread arriving at a <code class="literal">CyclicBarrier</code> or <code class="literal">Exchanger</code> <span class="emphasis"><em>happens-before</em></span> the other threads are released from that same barrier or exchange point. If <code class="literal">CyclicBarrier</code> uses a barrier action, arriving at the barrier <span class="emphasis"><em>happens-before</em></span> the barrier action, which in turn <span class="emphasis"><em>happens-before</em></span> threads are released from the barrier.</p></li></ul></div>
</div>
</div>







<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch16fn01" href="#ch16fn01" class="para">1</a>] </sup>On most popular processor architectures, the memory model is strong enough that the performance cost of a volatile read is in line with that of a nonvolatile read.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch16fn02" href="#ch16fn02" class="para">2</a>] </sup>A partial ordering <span class="inlinemediaobject"><img src="graphics/gamma.jpg" width="12" alt="The Java Memory Model in 500 Words or Less"/></span> is a relation on a set that is antisymmetric, reflexive, and transitive, but for any two elements <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>, it need not be the case that <span class="emphasis"><em>x</em></span> <span class="inlinemediaobject"><img src="graphics/gamma.jpg" width="12" alt="The Java Memory Model in 500 Words or Less"/></span> <span class="emphasis"><em>y</em></span> or <span class="emphasis"><em>y</em></span> <span class="inlinemediaobject"><img src="graphics/gamma.jpg" width="12" alt="The Java Memory Model in 500 Words or Less"/></span> <span class="emphasis"><em>x</em></span>. We use partial orderings every day to express preferences; we may prefer sushi to cheeseburgers and Mozart to Mahler, but we don’t necessarily have a clear preference between cheeseburgers and Mozart.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch16fn03" href="#ch16fn03" class="para">3</a>] </sup>Locks and unlocks on explicit <code class="literal">Lock</code> objects have the same memory semantics as intrinsic locks.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch16fn04" href="#ch16fn04" class="para">4</a>] </sup>Reads and writes of atomic variables have the same memory semantics as volatile variables.</p></div></div></div></body></html>
