<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Blocking and Interruptible Methods</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Blocking and Interruptible Methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lev1sec4"/>Blocking and Interruptible Methods</h2></div></div></div>

<p>Threads may <span class="emphasis"><em>block</em></span>, or pause, for several reasons: waiting for I/O completion, waiting to acquire a lock, waiting to wake up from <code class="literal">Thread.sleep</code>, or waiting for the result of a computation in another thread. When a thread blocks, it is usually suspended and placed in one of the blocked thread states (<code class="literal">BLOCKED</code>, <code class="literal">WAITING</code>, or <a id="iddle1641" class="indexterm"/><a id="iddle1642" class="indexterm"/><a id="iddle1929" class="indexterm"/><a id="iddle1930" class="indexterm"/><a id="iddle2787" class="indexterm"/><a id="iddle2790" class="indexterm"/><a id="iddle2791" class="indexterm"/><a id="iddle2792" class="indexterm"/><a id="iddle2793" class="indexterm"/><a id="iddle2794" class="indexterm"/><a id="iddle2795" class="indexterm"/><a id="iddle2816" class="indexterm"/><a id="iddle2817" class="indexterm"/><a id="iddle4125" class="indexterm"/><a id="iddle4327" class="indexterm"/><a id="iddle4328" class="indexterm"/><a id="iddle4329" class="indexterm"/><a id="iddle4330" class="indexterm"/><a id="iddle4463" class="indexterm"/><a id="iddle4464" class="indexterm"/><a id="iddle4469" class="indexterm"/><a id="iddle4515" class="indexterm"/><a id="iddle4516" class="indexterm"/><a id="iddle4974" class="indexterm"/><code class="literal">TIMED_WAITING</code>). The distinction between a blocking operation and an ordinary operation that merely takes a long time to finish is that a blocked thread must wait for an event that is beyond its control before it can proceed—the I/O completes, the lock becomes available, or the external computation finishes. When that external event occurs, the thread is placed back in the <code class="literal">RUNNABLE</code> state and becomes eligible again for scheduling.</p>
<p>The <code class="literal">put</code> and <code class="literal">take</code> methods of <code class="literal">BlockingQueue</code> throw the checked <code class="literal">InterruptedException</code>, as do a number of other library methods such as <code class="literal">Thread.sleep</code>. When a method can throw <code class="literal">InterruptedException</code>, it is telling you that it is a blocking method, and further that if it is <span class="emphasis"><em>interrupted</em></span>, it will make an effort to stop blocking early.</p>
<p><code class="literal">Thread</code> provides the <code class="literal">interrupt</code> method for interrupting a thread and for querying whether a thread has been interrupted. Each thread has a boolean property that represents its interrupted status; interrupting a thread sets this status.</p>
<p>Interruption is a <span class="emphasis"><em>cooperative</em></span> mechanism. One thread cannot force another to stop what it is doing and do something else; when thread <span class="emphasis"><em>A</em></span> interrupts thread <span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>A</em></span> is merely requesting that <span class="emphasis"><em>B</em></span> stop what it is doing when it gets to a convenient stopping point—if it feels like it. While there is nothing in the API or language specification that demands any specific application-level semantics for interruption, the most sensible use for interruption is to cancel an activity. Blocking methods that are responsive to interruption make it easier to cancel long-running activities on a timely basis.</p>
<p>When your code calls a method that throws <code class="literal">InterruptedException</code>, then your method is a blocking method too, and must have a plan for responding to interruption. For library code, there are basically two choices:</p>
<p title="Propagate the InterruptedException."><b><span class="strong"><strong>Propagate the InterruptedException.</strong></span> </b>This is often the most sensible policy if you can get away with it—just propagate the <code class="literal">InterruptedException</code> to your caller. This could involve not catching <code class="literal">InterruptedException</code>, or catching it and throwing it again after performing some brief activity-specific cleanup.</p>
<p title="Restore the interrupt."><b><span class="strong"><strong>Restore the interrupt.</strong></span> </b>Sometimes you cannot throw <code class="literal">InterruptedException</code>, for instance when your code is part of a <code class="literal">Runnable</code>. In these situations, you must catch <code class="literal">InterruptedException</code> and restore the interrupted status by calling <code class="literal">interrupt</code> on the current thread, so that code higher up the call stack can see that an interrupt was issued, as demonstrated in <a class="link" href="ch05s04.html#ch05list10" title="Example 5.10. Restoring the Interrupted Status so as Not to Swallow the Interrupt.">Listing 5.10</a>.</p>
<p class="continued">You can get much more sophisticated with interruption, but these two approaches should work in the vast majority of situations. But there is one thing you should <span class="emphasis"><em>not</em></span> do with <code class="literal">InterruptedException</code>—catch it and do nothing in response. This deprives code higher up on the call stack of the opportunity to act on the interruption, because the evidence that the thread was interrupted is lost. <span class="emphasis"><em>The only situation in which it is acceptable to swallow an interrupt is when you are extending Thread and therefore control all the code higher up on the call stack.</em></span> Cancellation and interruption are covered in greater detail in <a class="link" href="ch07.html" title="Chapter 7. Cancellation and Shutdown">Chapter 7</a>.</p>

<p/><div class="example"><a id="ch05list10"/><p class="title"><b>Example 5.10. Restoring the Interrupted Status so as Not to Swallow the Interrupt.</b></p><div class="example-contents">


<pre class="programlisting">public class TaskRunnable implements Runnable {
    BlockingQueue&lt;Task&gt; queue;
    ...
    public void run() {
        try {
            processTask(queue.take());
        } catch (InterruptedException e) {
             <span class="emphasis"><em>// restore interrupted status</em></span>
             <span class="strong"><strong>Thread.currentThread().interrupt();</strong></span>
        }
    }
}
</pre>
</div></div><br class="example-break"/>
</div></body></html>
