<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Instance Confinement</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Instance Confinement"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lev1sec2"/>Instance Confinement</h2></div></div></div>

<p>If an object is not thread-safe, several techniques can still let it be used safely in a multithreaded program. You can ensure that it is only accessed from a single thread (thread confinement), or that all access to it is properly guarded by a lock.</p>
<p><a id="iddle1342" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle1438" class="indexterm"/><a id="iddle1533" class="indexterm"/><a id="iddle2048" class="indexterm"/><a id="iddle2049" class="indexterm"/><a id="iddle2153" class="indexterm"/><a id="iddle2520" class="indexterm"/><a id="iddle2747" class="indexterm"/><a id="iddle2748" class="indexterm"/><a id="iddle2956" class="indexterm"/><a id="iddle2957" class="indexterm"/><a id="iddle3059" class="indexterm"/><a id="iddle4217" class="indexterm"/><a id="iddle4745" class="indexterm"/>Encapsulation simplifies making classes thread-safe by promoting <span class="emphasis"><em>instance confinement</em></span>, often just called <span class="emphasis"><em>confinement</em></span> [CPJ 2.3.3]. When an object is encapsulated within another object, all code paths that have access to the encapsulated object are known and can be therefore be analyzed more easily than if that object were accessible to the entire program. Combining confinement with an appropriate locking discipline can ensure that otherwise non-thread-safe objects are used in a thread-safe manner.</p>
<div class="sidebar"><a id="ch04sb03"/><p class="title"><b/></p>
<p>Encapsulating data within an object confines access to the data to the object’s methods, making it easier to ensure that the data is always accessed with the appropriate lock held.</p>
</div>
<p>Confined objects must not escape their intended scope. An object may be confined to a class instance (such as a private class member), a lexical scope (such as a local variable), or a thread (such as an object that is passed from method to method within a thread, but not supposed to be shared across threads). Objects don’t escape on their own, of course—they need help from the developer, who assists by publishing the object beyond its intended scope.</p>
<p><code class="literal">PersonSet</code> in <a class="link" href="ch04s02.html#ch04list02" title="Example 4.2. Using Confinement to Ensure Thread Safety.">Listing 4.2</a> illustrates how confinement and locking can work together to make a class thread-safe even when its component state variables are not. The state of <code class="literal">PersonSet</code> is managed by a <code class="literal">HashSet</code>, which is not thread-safe. But because <code class="literal">mySet</code> is private and not allowed to escape, the <code class="literal">HashSet</code> is confined to the <code class="literal">PersonSet</code>. The only code paths that can access <code class="literal">mySet</code> are <code class="literal">addPerson</code> and <code class="literal">containsPerson</code>, and each of these acquires the lock on the <code class="literal">PersonSet</code>. All its state is guarded by its intrinsic lock, making <code class="literal">PersonSet</code> thread-safe.</p>
<div class="example"><a id="ch04list02"/><p class="title"><b>Example 4.2. Using Confinement to Ensure Thread Safety.</b></p><div class="example-contents">

<pre class="programlisting">@ThreadSafe
public class PersonSet {
    @GuardedBy("this")
    private final Set&lt;Person&gt; mySet = new HashSet&lt;Person&gt;();

    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }

    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
}
</pre>
</div></div><br class="example-break"/>
<p>This example makes no assumptions about the thread-safety of <code class="literal">Person</code>, but if it is mutable, additional synchronization will be needed when accessing a <code class="literal">Person</code> retrieved from a <code class="literal">PersonSet</code>. The most reliable way to do this would be to make <a id="iddle1842" class="indexterm"/><a id="iddle1843" class="indexterm"/><a id="iddle1946" class="indexterm"/><a id="iddle1947" class="indexterm"/><a id="iddle1948" class="indexterm"/><a id="iddle1949" class="indexterm"/><a id="iddle2051" class="indexterm"/><a id="iddle2052" class="indexterm"/><a id="iddle2374" class="indexterm"/><a id="iddle2512" class="indexterm"/><a id="iddle2638" class="indexterm"/><a id="iddle2639" class="indexterm"/><a id="iddle2897" class="indexterm"/><a id="iddle2898" class="indexterm"/><a id="iddle3056" class="indexterm"/><a id="iddle3244" class="indexterm"/><a id="iddle3708" class="indexterm"/><a id="iddle3709" class="indexterm"/><a id="iddle5166" class="indexterm"/><a id="iddle5167" class="indexterm"/><a id="iddle5168" class="indexterm"/><code class="literal">Person</code> thread-safe; less reliable would be to guard the <code class="literal">Person</code> objects with a lock and ensure that all clients follow the protocol of acquiring the appropriate lock before accessing the <code class="literal">Person</code>.</p>
<p>Instance confinement is one of the easiest ways to build thread-safe classes. It also allows flexibility in the choice of locking strategy; <code class="literal">PersonSet</code> happened to use its own intrinsic lock to guard its state, but any lock, consistently used, would do just as well. Instance confinement also allows different state variables to be guarded by different locks. (For an example of a class that uses multiple lock objects to guard its state, see <code class="literal">ServerStatus</code> on <a class="link" href="ch11s04.html#ch11list06" title="Example 11.6. Candidate for Lock Splitting.">236</a>.)</p>
<p>There are many examples of confinement in the platform class libraries, including some classes that exist solely to turn non-thread-safe classes into threadsafe ones. The basic collection classes such as <code class="literal">ArrayList</code> and <code class="literal">HashMap</code> are not thread-safe, but the class library provides wrapper factory methods (<code class="literal">Collections.synchronizedList</code> and friends) so they can be used safely in multithreaded environments. These factories use the Decorator pattern (<a class="link" href="bi01.html#biblio01_011">Gamma et al., 1995</a>) to wrap the collection with a synchronized wrapper object; the wrapper implements each method of the appropriate interface as a synchronized method that forwards the request to the underlying collection object. So long as the wrapper object holds the only reachable reference to the underlying collection (i.e., the underlying collection is confined to the wrapper), the wrapper object is then thread-safe. The Javadoc for these methods warns that all access to the underlying collection must be made through the wrapper.</p>
<p>Of course, it is still possible to violate confinement by publishing a supposedly confined object; if an object is intended to be confined to a specific scope, then letting it escape from that scope is a bug. Confined objects can also escape by publishing other objects such as iterators or inner class instances that may indirectly publish the confined objects.</p>
<div class="sidebar"><a id="ch04sb04"/><p class="title"><b/></p>
<p>Confinement makes it easier to build thread-safe classes because a class that confines its state can be analyzed for thread safety without having to examine the whole program.</p>
</div>
<div class="section" title="The Java Monitor Pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lev2sec4"/>The Java Monitor Pattern</h3></div></div></div>

<p>Following the principle of instance confinement to its logical conclusion leads you to the <span class="emphasis"><em>Java monitor pattern</em></span>.<sup>[<a id="ch04fn02" href="#ftn.ch04fn02" class="footnote">2</a>]</sup> An object following the Java monitor pattern encapsulates all its mutable state and guards it with the object’s own intrinsic lock.</p>
<p><code class="literal">Counter</code> in <a class="link" href="ch04.html#ch04list01" title="Example 4.1. Simple Thread-safe Counter Using the Java Monitor Pattern.">Listing 4.1</a> shows a typical example of this pattern. It encapsulates one state variable, <code class="literal">value</code>, and all access to that state variable is through the methods of <code class="literal">Counter</code>, which are all synchronized.</p>
<p><a id="iddle1632" class="indexterm"/><a id="iddle1638" class="indexterm"/><a id="iddle2159" class="indexterm"/><a id="iddle2491" class="indexterm"/><a id="iddle2492" class="indexterm"/><a id="iddle2900" class="indexterm"/><a id="iddle3023" class="indexterm"/><a id="iddle3051" class="indexterm"/><a id="iddle3113" class="indexterm"/><a id="iddle3128" class="indexterm"/><a id="iddle3129" class="indexterm"/><a id="iddle3227" class="indexterm"/><a id="iddle3289" class="indexterm"/><a id="iddle3668" class="indexterm"/><a id="iddle3669" class="indexterm"/><a id="iddle4283" class="indexterm"/><a id="iddle4476" class="indexterm"/><a id="iddle4477" class="indexterm"/><a id="iddle5080" class="indexterm"/><a id="iddle5082" class="indexterm"/><a id="iddle5089" class="indexterm"/>The Java monitor pattern is used by many library classes, such as <code class="literal">Vector</code> and <code class="literal">Hashtable</code>. Sometimes a more sophisticated synchronization policy is needed; <a class="link" href="ch11.html" title="Chapter 11. Performance and Scalability">Chapter 11</a> shows how to improve scalability through finer-grained locking strategies. The primary advantage of the Java monitor pattern is its simplicity.</p>
<p>The Java monitor pattern is merely a convention; any lock object could be used to guard an object’s state so long as it is used consistently. <a class="link" href="ch04s02.html#ch04list03" title="Example 4.3. Guarding State with a Private Lock.">Listing 4.3</a> illustrates a class that uses a private lock to guard its state.</p>
<div class="example"><a id="ch04list03"/><p class="title"><b>Example 4.3. Guarding State with a Private Lock.</b></p><div class="example-contents">

<pre class="programlisting">public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;

    void someMethod() {
        synchronized(myLock) {
            // Access or modify the state of widget
        }
    }
}
</pre>
</div></div><br class="example-break"/>
<p>There are advantages to using a private lock object instead of an object’s intrinsic lock (or any other publicly accessible lock). Making the lock object private encapsulates the lock so that client code cannot acquire it, whereas a publicly accessible lock allows client code to participate in its synchronization policy—correctly or incorrectly. Clients that improperly acquire another object’s lock could cause liveness problems, and verifying that a publicly accessible lock is properly used requires examining the entire program rather than a single class.</p>
</div>
<div class="section" title="Example: Tracking Fleet Vehicles"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lev2sec5"/>Example: Tracking Fleet Vehicles</h3></div></div></div>

<p><code class="literal">Counter</code> in <a class="link" href="ch04.html#ch04list01" title="Example 4.1. Simple Thread-safe Counter Using the Java Monitor Pattern.">Listing 4.1</a> is a concise, but trivial, example of the Java monitor pattern. Let’s build a slightly less trivial example: a “vehicle tracker” for dispatching fleet vehicles such as taxicabs, police cars, or delivery trucks. We’ll build it first using the monitor pattern, and then see how to relax some of the encapsulation requirements while retaining thread safety.</p>
<p>Each vehicle is identified by a <code class="literal">String</code> and has a location represented by (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates. The <code class="literal">VehicleTracker</code> classes encapsulate the identity and locations of the known vehicles, making them well-suited as a data model in a modelview-controller GUI application where it might be shared by a view thread and multiple updater threads. The view thread would fetch the names and locations of the vehicles and render them on a display:</p>
<div class="informalexample">
<pre class="programlisting">Map&lt;String, Point&gt; locations = vehicles.getLocations();
for (String key : locations.keySet())
    renderVehicle(key, locations.get(key));
</pre>
</div>
<p class="continued"><a id="iddle1550" class="indexterm"/><a id="iddle1551" class="indexterm"/><a id="iddle1552" class="indexterm"/><a id="iddle1662" class="indexterm"/><a id="iddle1663" class="indexterm"/><a id="iddle1863" class="indexterm"/><a id="iddle1940" class="indexterm"/><a id="iddle4734" class="indexterm"/>Similarly, the updater threads would modify vehicle locations with data received from GPS devices or entered manually by a dispatcher through a GUI interface:</p>
<div class="informalexample">
<pre class="programlisting">void vehicleMoved(VehicleMovedEvent evt) {
    Point loc = evt.getNewLocation();
    vehicles.setLocation(evt.getVehicleId(), loc.x, loc.y);
}
</pre>
</div>
<p class="continued">Since the view thread and the updater threads will access the data model concurrently, it must be thread-safe. <a class="link" href="ch04s03.html#ch04list04" title="Example 4.4. Monitor-based Vehicle Tracker Implementation.">Listing 4.4</a> shows an implementation of the vehicle tracker using the Java monitor pattern that uses <code class="literal">MutablePoint</code> in <a class="link" href="ch04s03.html#ch04list05" title="Example 4.5. Mutable Point Class Similar to Java.awt.Point.">Listing 4.5</a> for representing the vehicle locations.</p>
<p>Even though <code class="literal">MutablePoint</code> is not thread-safe, the tracker class is. Neither the map nor any of the mutable points it contains is ever published. When we need to a return vehicle locations to callers, the appropriate values are copied using either the <code class="literal">MutablePoint</code> copy constructor or <code class="literal">deepCopy</code>, which creates a new <code class="literal">Map</code> whose values are copies of the keys and values from the old <code class="literal">Map</code>.<sup>[<a id="ch04fn03" href="#ftn.ch04fn03" class="footnote">3</a>]</sup></p>
<p>This implementation maintains thread safety in part by copying mutable data before returning it to the client. This is usually not a performance issue, but could become one <span class="emphasis"><em>if</em></span> the set of vehicles is very large.<sup>[<a id="ch04fn04" href="#ftn.ch04fn04" class="footnote">4</a>]</sup> Another consequence of copying the data on each call to <code class="literal">getLocation</code> is that the contents of the returned collection do not change even if the underlying locations change. Whether this is good or bad depends on your requirements. It could be a benefit if there are internal consistency requirements on the location set, in which case returning a consistent snapshot is critical, or a drawback if callers require up-to-date information for each vehicle and therefore need to refresh their snapshot more often.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch04fn02" href="#ch04fn02" class="para">2</a>] </sup>The Java monitor pattern is inspired by Hoare’s work on <span class="emphasis"><em>monitors</em></span> (<a class="link" href="bi01.html#biblio01_018" title="Monitors: An Operating System Structuring Concept">Hoare, 1974</a>), though there are significant differences between this pattern and a true monitor. The bytecode instructions for entering and exiting a synchronized block are even called <code class="literal">monitorenter</code> and <code class="literal">monitorexit</code>, and Java’s built-in (intrinsic) locks are sometimes called <span class="emphasis"><em>monitor locks</em></span> or <span class="emphasis"><em>monitors</em></span>.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn03" href="#ch04fn03" class="para">3</a>] </sup>Note that <code class="literal">deepCopy</code> can’t just wrap the <code class="literal">Map</code> with an <code class="literal">unmodifiableMap</code>, because that protects only the <span class="emphasis"><em>collection</em></span> from modification; it does not prevent callers from modifying the mutable objects stored in it. For the same reason, populating the <code class="literal">HashMap</code> in <code class="literal">deepCopy</code> via a copy constructor wouldn’t work either, because only the <span class="emphasis"><em>references</em></span> to the points would be copied, not the point objects themselves.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn04" href="#ch04fn04" class="para">4</a>] </sup>Because<code class="literal">deepCopy</code> is called from a <code class="literal">synchronized</code> method, the tracker’s intrinsic lock is held for the duration of what might be a long-running copy operation, and this could degrade the responsiveness of the user interface when many vehicles are being tracked.</p></div></div></div></body></html>
