<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Choosing Between Synchronized and ReentrantLock</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Choosing Between Synchronized and ReentrantLock"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lev1sec4"/>Choosing Between Synchronized and ReentrantLock</h2></div></div></div>

<p><code class="literal">ReentrantLock</code> provides the same locking and memory semantics as intrinsic locking, as well as additional features such as timed lock waits, interruptible lock waits, fairness, and the ability to implement non-block-structured locking. The performance of <code class="literal">ReentrantLock</code> appears to dominate that of intrinsic locking, winning slightly on Java 6 and dramatically on Java 5.0. So why not deprecate <code class="literal">synchronized</code> and encourage all new concurrent code to use <code class="literal">ReentrantLock</code>? Some authors have in fact suggested this, treating <code class="literal">synchronized</code> as a “legacy” construct. But this is taking a good thing <span class="emphasis"><em>way</em></span> too far.</p>
<p>Intrinsic locks still have significant advantages over explicit locks. The notation is familiar and compact, and many existing programs already use intrinsic locking—and mixing the two could be confusing and error-prone. <code class="literal">Reentrant-Lock</code> is definitely a more dangerous tool than synchronization; if you forget to wrap the <code class="literal">unlock</code> call in a <code class="literal">finally</code> block, your code will probably appear to run properly, but you’ve created a time bomb that may well hurt innocent bystanders. Save <code class="literal">ReentrantLock</code> for situations in which you need something <code class="literal">ReentrantLock</code> provides that intrinsic locking doesn’t.</p>
<div class="sidebar"><a id="ch13sb02"/><p class="title"><b/></p>
<p><code class="literal">ReentrantLock</code> is an advanced tool for situations where intrinsic locking is not practical. Use it if you need its advanced features: timed, polled, or interruptible lock acquisition, fair queueing, or non-block-structured locking. Otherwise, prefer <code class="literal">synchronized</code>.</p>
</div>
<p>Under Java 5.0, intrinsic locking has another advantage over <code class="literal">ReentrantLock</code>: thread dumps show which call frames acquired which locks and can detect and identify deadlocked threads. The JVM knows nothing about which threads hold <code class="literal">ReentrantLock</code>s and therefore cannot help in debugging threading problems using <code class="literal">ReentrantLock</code>. This disparity is addressed in Java 6 by providing a management and monitoring interface with which locks can register, enabling locking information for <code class="literal">ReentrantLock</code>s to appear in thread dumps and through other management and debugging interfaces. The availability of this information for debugging is a substantial, if mostly temporary, advantage for <code class="literal">synchronized</code>; locking information in thread dumps has saved many programmers from utter consternation. The non-block-structured nature of <code class="literal">ReentrantLock</code> still means that lock acquisitions cannot be tied to specific stack frames, as they can with intrinsic locks.</p>
<p><a id="iddle1368" class="indexterm"/><a id="iddle1478" class="indexterm"/><a id="iddle1997" class="indexterm"/><a id="iddle2920" class="indexterm"/><a id="iddle3072" class="indexterm"/><a id="iddle3091" class="indexterm"/><a id="iddle3132" class="indexterm"/><a id="iddle3261" class="indexterm"/><a id="iddle3385" class="indexterm"/><a id="iddle3520" class="indexterm"/><a id="iddle3795" class="indexterm"/><a id="iddle3796" class="indexterm"/>Future performance improvements are likely to favor <code class="literal">synchronized</code> over <code class="literal">ReentrantLock</code>. Because <code class="literal">synchronized</code> is built into the JVM, it can perform optimizations such as lock elision for thread-confined lock objects and lock coarsening to eliminate synchronization with intrinsic locks (see <a class="link" href="ch11s03.html#ch11lev2sec6" title="Memory Synchronization">Section 11.3.2</a>); doing this with library-based locks seems far less likely. Unless you are deploying on Java 5.0 for the foreseeable future and you have a <span class="emphasis"><em>demonstrated</em></span> need for <code class="literal">ReentrantLock</code>’s scalability benefits on that platform, it is not a good idea to choose <code class="literal">ReentrantLock</code> over <code class="literal">synchronized</code> for performance reasons.</p>
</div></body></html>
