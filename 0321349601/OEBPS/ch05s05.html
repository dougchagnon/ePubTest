<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Synchronizers</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Synchronizers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lev1sec5"/>Synchronizers</h2></div></div></div>

<p><a id="iddle1440" class="indexterm"/><a id="iddle1582" class="indexterm"/><a id="iddle1624" class="indexterm"/><a id="iddle1625" class="indexterm"/><a id="iddle1629" class="indexterm"/><a id="iddle1653" class="indexterm"/><a id="iddle1654" class="indexterm"/><a id="iddle1728" class="indexterm"/><a id="iddle1903" class="indexterm"/><a id="iddle1904" class="indexterm"/><a id="iddle2026" class="indexterm"/><a id="iddle2194" class="indexterm"/><a id="iddle2446" class="indexterm"/><a id="iddle2932" class="indexterm"/><a id="iddle2933" class="indexterm"/><a id="iddle2934" class="indexterm"/><a id="iddle2935" class="indexterm"/><a id="iddle2936" class="indexterm"/><a id="iddle3683" class="indexterm"/><a id="iddle3684" class="indexterm"/><a id="iddle4398" class="indexterm"/><a id="iddle4585" class="indexterm"/><a id="iddle4586" class="indexterm"/><a id="iddle4587" class="indexterm"/><a id="iddle4588" class="indexterm"/><a id="iddle4589" class="indexterm"/><a id="iddle4590" class="indexterm"/>Blocking queues are unique among the collections classes: not only do they act as containers for objects, but they can also coordinate the control flow of producer and consumer threads because <code class="literal">take</code> and <code class="literal">put</code> block until the queue enters the desired state (not empty or not full).</p>
<p>A <span class="emphasis"><em>synchronizer</em></span> is any object that coordinates the control flow of threads based on its state. Blocking queues can act as synchronizers; other types of synchronizers include semaphores, barriers, and latches. There are a number of synchronizer classes in the platform library; if these do not meet your needs, you can also create your own using the mechanisms described in <a class="link" href="ch14.html" title="Chapter 14. Building Custom Synchronizers">Chapter 14</a>.</p>
<p>All synchronizers share certain structural properties: they encapsulate state that determines whether threads arriving at the synchronizer should be allowed to pass or forced to wait, provide methods to manipulate that state, and provide methods to wait efficiently for the synchronizer to enter the desired state.</p>
<div class="section" title="Latches"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lev2sec10"/>Latches</h3></div></div></div>

<p>A <span class="emphasis"><em>latch</em></span> is a synchronizer that can delay the progress of threads until it reaches its <span class="emphasis"><em>terminal</em></span> state [CPJ 3.4.2]. A latch acts as a gate: until the latch reaches the terminal state the gate is closed and no thread can pass, and in the terminal state the gate opens, allowing all threads to pass. Once the latch reaches the terminal state, it cannot change state again, so it remains open forever. Latches can be used to ensure that certain activities do not proceed until other one-time activities complete, such as:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ensuring that a computation does not proceed until resources it needs have been initialized. A simple binary (two-state) latch could be used to indicate “Resource <span class="emphasis"><em>R</em></span> has been initialized”, and any activity that requires <span class="emphasis"><em>R</em></span> would wait first on this latch.</p></li><li class="listitem"><p><a id="iddle1700" class="indexterm"/><a id="iddle2197" class="indexterm"/><a id="iddle1136" class="indexterm"/><a id="iddle1291" class="indexterm"/><a id="iddle1300" class="indexterm"/><a id="iddle1397" class="indexterm"/><a id="iddle1441" class="indexterm"/><a id="iddle1607" class="indexterm"/><a id="iddle1697" class="indexterm"/><a id="iddle2225" class="indexterm"/><a id="iddle2423" class="indexterm"/><a id="iddle2430" class="indexterm"/><a id="iddle2432" class="indexterm"/><a id="iddle2940" class="indexterm"/><a id="iddle3982" class="indexterm"/><a id="iddle4019" class="indexterm"/><a id="iddle4424" class="indexterm"/><a id="iddle4425" class="indexterm"/><a id="iddle4604" class="indexterm"/><a id="iddle4605" class="indexterm"/><a id="iddle4654" class="indexterm"/><a id="iddle4655" class="indexterm"/><a id="iddle5144" class="indexterm"/><a id="iddle5145" class="indexterm"/>Ensuring that a service does not start until other services on which it depends have started. Each service would have an associated binary latch; starting service <span class="emphasis"><em>S</em></span> would involve first waiting on the latches for other services on which <span class="emphasis"><em>S</em></span> depends, and then releasing the <span class="emphasis"><em>S</em></span> latch after startup completes so any services that depend on <span class="emphasis"><em>S</em></span> can then proceed.</p></li><li class="listitem"><p>Waiting until all the parties involved in an activity, for instance the players in a multi-player game, are ready to proceed. In this case, the latch reaches the terminal state after all the players are ready.</p></li></ul></div>
<p class="continued"><code class="literal">CountDownLatch</code> is a flexible latch implementation that can be used in any of these situations; it allows one or more threads to wait for a set of events to occur. The latch state consists of a counter initialized to a positive number, representing the number of events to wait for. The <code class="literal">countDown</code> method decrements the counter, indicating that an event has occurred, and the <code class="literal">await</code> methods wait for the counter to reach zero, which happens when all the events have occurred. If the counter is nonzero on entry, <code class="literal">await</code> blocks until the counter reaches zero, the waiting thread is interrupted, or the wait times out.</p>
<p><code class="literal">TestHarness</code> in <a class="link" href="ch05s05.html#ch05list11" title="Example 5.11. Using CountDownLatch for Starting and Stopping Threads in Timing Tests.">Listing 5.11</a> illustrates two common uses for latches. <code class="literal">TestHarness</code> creates a number of threads that run a given task concurrently. It uses two latches, a “starting gate” and an “ending gate”. The starting gate is initialized with a count of one; the ending gate is initialized with a count equal to the number of worker threads. The first thing each worker thread does is wait on the starting gate; this ensures that none of them starts working until they all are ready to start. The last thing each does is count down on the ending gate; this allows the master thread to wait efficiently until the last of the worker threads has finished, so it can calculate the elapsed time.</p>
<p>Why did we bother with the latches in <code class="literal">TestHarness</code> instead of just starting the threads immediately after they are created? Presumably, we wanted to measure how long it takes to run a task <span class="emphasis"><em>n</em></span> times <span class="emphasis"><em>concurrently</em></span>. If we simply created and started the threads, the threads started earlier would have a “head start” on the later threads, and the degree of contention would vary over time as the number of active threads increased or decreased. Using a starting gate allows the master thread to release all the worker threads at once, and the ending gate allows the master thread to wait for the <span class="emphasis"><em>last</em></span> thread to finish rather than waiting sequentially for each thread to finish.</p>
</div>
<div class="section" title="FutureTask"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lev2sec11"/>FutureTask</h3></div></div></div>

<p><code class="literal">FutureTask</code> also acts like a latch. (<code class="literal">FutureTask</code> implements <code class="literal">Future</code>, which describes an abstract result-bearing computation [CPJ 4.3.3].) A computation represented by a <code class="literal">FutureTask</code> is implemented with a <code class="literal">Callable</code>, the result-bearing equivalent of <code class="literal">Runnable</code>, and can be in one of three states: waiting to run, running, or completed. Completion subsumes all the ways a computation can complete, including normal completion, cancellation, and exception. Once a <code class="literal">FutureTask</code> enters the completed state, it stays in that state forever.</p>
<p>The behavior of <code class="literal">Future.get</code> depends on the state of the task. If it is completed, <code class="literal">get</code> returns the result immediately, and otherwise blocks until the task transitions <a id="iddle2039" class="indexterm"/><a id="iddle2040" class="indexterm"/><a id="iddle2156" class="indexterm"/><a id="iddle2226" class="indexterm"/><a id="iddle2261" class="indexterm"/><a id="iddle2436" class="indexterm"/>to the completed state and then returns the result or throws an exception. <code class="literal">FutureTask</code> conveys the result from the thread executing the computation to the thread(s) retrieving the result; the specification of <code class="literal">FutureTask</code> guarantees that this transfer constitutes a safe publication of the result.</p>
<div class="example"><a id="ch05list11"/><p class="title"><b>Example 5.11. Using <code class="literal">CountDownLatch</code> for Starting and Stopping Threads in Timing Tests.</b></p><div class="example-contents">


<pre class="programlisting">public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i &lt; nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) { }
                }
            };
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end-start;
    }
}
</pre>
</div></div><br class="example-break"/>
<p><code class="literal">FutureTask</code> is used by the <code class="literal">Executor</code> framework to represent asynchronous tasks, and can also be used to represent any potentially lengthy computation that can be started before the results are needed. <code class="literal">Preloader</code> in <a class="link" href="ch05s05.html#ch05list12" title="Example 5.12. Using FutureTask to Preload Data that is Needed Later.">Listing 5.12</a> uses <code class="literal">FutureTask</code> to perform an expensive computation whose results are needed later; by starting the computation early, you reduce the time you would have to wait later when you actually need the results.</p>
<div class="example"><a id="ch05list12"/><p class="title"><b>Example 5.12. Using <code class="literal">FutureTask</code> to Preload Data that is Needed Later.</b></p><div class="example-contents">

<pre class="programlisting">public class Preloader {
    private final FutureTask&lt;ProductInfo&gt; future =
        new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    private final Thread thread = new Thread(future);

    public void start() { thread.start(); }

    public ProductInfo get()
            throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException)
                throw (DataLoadException) cause;
            else
                throw launderThrowable(cause);
        }
    }
}
</pre>
</div></div><br class="example-break"/>
<p><code class="literal">Preloader</code> creates a <code class="literal">FutureTask</code> that describes the task of loading product information from a database and a thread in which the computation will be performed. It provides a <code class="literal">start</code> method to start the thread, since it is inadvisable to start a thread from a constructor or static initializer. When the program later needs the <code class="literal">ProductInfo</code>, it can call <code class="literal">get</code>, which returns the loaded data if it is ready, or waits for the load to complete if not.</p>
<p>Tasks described by <code class="literal">Callable</code> can throw checked and unchecked exceptions, and any code can throw an <code class="literal">Error</code>. Whatever the task code may throw, it is <a id="iddle1319" class="indexterm"/><a id="iddle1320" class="indexterm"/><a id="iddle1442" class="indexterm"/><a id="iddle1701" class="indexterm"/><a id="iddle2252" class="indexterm"/><a id="iddle2253" class="indexterm"/><a id="iddle2701" class="indexterm"/><a id="iddle2702" class="indexterm"/><a id="iddle3551" class="indexterm"/><a id="iddle3612" class="indexterm"/><a id="iddle3613" class="indexterm"/><a id="iddle3841" class="indexterm"/><a id="iddle3842" class="indexterm"/><a id="iddle3936" class="indexterm"/><a id="iddle3937" class="indexterm"/><a id="iddle4025" class="indexterm"/><a id="iddle4136" class="indexterm"/><a id="iddle4145" class="indexterm"/><a id="iddle4146" class="indexterm"/><a id="iddle4150" class="indexterm"/><a id="iddle4880" class="indexterm"/><a id="iddle4881" class="indexterm"/>wrapped in an <code class="literal">ExecutionException</code> and rethrown from <code class="literal">Future.get</code>. This complicates code that calls <code class="literal">get</code>, not only because it must deal with the possibility of <code class="literal">ExecutionException</code> (and the unchecked <code class="literal">CancellationException</code>), but also because the cause of the <code class="literal">ExecutionException</code> is returned as a <code class="literal">Throwable</code>, which is inconvenient to deal with.</p>
<p>When <code class="literal">get</code> throws an <code class="literal">ExecutionException</code> in <code class="literal">Preloader</code>, the cause will fall into one of three categories: a checked exception thrown by the <code class="literal">Callable</code>, a <code class="literal">RuntimeException</code>, or an <code class="literal">Error</code>. We must handle each of these cases separately, but we will use the <code class="literal">launderThrowable</code> utility method in <a class="link" href="ch05s05.html#ch05list13" title="Example 5.13. Coercing an Unchecked Throwable to a RuntimeException.">Listing 5.13</a> to encapsulate some of the messier exception-handling logic. Before calling <code class="literal">launderThrowable</code>, <code class="literal">Preloader</code> tests for the known checked exceptions and rethrows them. That leaves only unchecked exceptions, which <code class="literal">Preloader</code> handles by calling <code class="literal">launderThrowable</code> and throwing the result. If the <code class="literal">Throwable</code> passed to <code class="literal">launderThrowable</code> is an <code class="literal">Error</code>, <code class="literal">launderThrowable</code> rethrows it directly; if it is not a <code class="literal">RuntimeException</code>, it throws an <code class="literal">IllegalStateException</code> to indicate a logic error. That leaves only <code class="literal">RuntimeException</code>, which <code class="literal">launderThrowable</code> returns to its caller, and which the caller generally rethrows.</p>
<div class="example"><a id="ch05list13"/><p class="title"><b>Example 5.13. Coercing an Unchecked <code class="literal">Throwable</code> to a <code class="literal">RuntimeException</code>.</b></p><div class="example-contents">

<pre class="programlisting"><span class="emphasis"><em>/** If the Throwable is an Error, throw it; if it is a</em></span>
 <span class="emphasis"><em>*  RuntimeException return it, otherwise throw IllegalStateException</em></span>
 <span class="emphasis"><em>*/</em></span>
public static RuntimeException launderThrowable(Throwable t) {
    if (t instanceof RuntimeException)
        return (RuntimeException) t;
    else if (t instanceof Error)
        throw (Error) t;
    else
        throw new IllegalStateException("Not unchecked", t);
}
</pre>
</div></div><br class="example-break"/>
</div>
<div class="section" title="Semaphores"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lev2sec12"/>Semaphores</h3></div></div></div>

<p><span class="emphasis"><em>Counting semaphores</em></span> are used to control the number of activities that can access a certain resource or perform a given action at the same time [CPJ 3.4.1]. Counting semaphores can be used to implement resource pools or to impose a bound on a collection.</p>
<p>A <code class="literal">Semaphore</code> manages a set of virtual <span class="emphasis"><em>permits</em></span>; the initial number of permits is passed to the <code class="literal">Semaphore</code> constructor. Activities can acquire permits (as long as some remain) and release permits when they are done with them. If no permit is available, <code class="literal">acquire</code> blocks until one is (or until interrupted or the operation times out). The <code class="literal">release</code> method returns a permit to the semaphore. <sup>[<a id="ch05fn04" href="#ftn.ch05fn04" class="footnote">4</a>]</sup> A degenerate case <a id="iddle1039" class="indexterm"/><a id="iddle1060" class="indexterm"/><a id="iddle1061" class="indexterm"/><a id="iddle1189" class="indexterm"/><a id="iddle1190" class="indexterm"/><a id="iddle1191" class="indexterm"/><a id="iddle1192" class="indexterm"/><a id="iddle1194" class="indexterm"/><a id="iddle1197" class="indexterm"/><a id="iddle1204" class="indexterm"/><a id="iddle1205" class="indexterm"/><a id="iddle1209" class="indexterm"/><a id="iddle1210" class="indexterm"/><a id="iddle1242" class="indexterm"/><a id="iddle1243" class="indexterm"/><a id="iddle1259" class="indexterm"/><a id="iddle1260" class="indexterm"/><a id="iddle1374" class="indexterm"/><a id="iddle1375" class="indexterm"/><a id="iddle1443" class="indexterm"/><a id="iddle1741" class="indexterm"/><a id="iddle2067" class="indexterm"/><a id="iddle2443" class="indexterm"/><a id="iddle2444" class="indexterm"/><a id="iddle2445" class="indexterm"/><a id="iddle2882" class="indexterm"/><a id="iddle2883" class="indexterm"/><a id="iddle2937" class="indexterm"/><a id="iddle3284" class="indexterm"/><a id="iddle3357" class="indexterm"/><a id="iddle3452" class="indexterm"/><a id="iddle3453" class="indexterm"/><a id="iddle3555" class="indexterm"/><a id="iddle3556" class="indexterm"/><a id="iddle3609" class="indexterm"/><a id="iddle4123" class="indexterm"/><a id="iddle4148" class="indexterm"/><a id="iddle4149" class="indexterm"/><a id="iddle4574" class="indexterm"/><a id="iddle4575" class="indexterm"/><a id="iddle4576" class="indexterm"/><a id="iddle4577" class="indexterm"/><a id="iddle4578" class="indexterm"/><a id="iddle4890" class="indexterm"/>of a counting semaphore is a binary semaphore, a <code class="literal">Semaphore</code> with an initial count of one. A binary semaphore can be used as a <span class="emphasis"><em>mutex</em></span> with nonreentrant locking semantics; whoever holds the sole permit holds the mutex.</p>
<p>Semaphores are useful for implementing resource pools such as database connection pools. While it is easy to construct a fixed-sized pool that fails if you request a resource from an empty pool, what you really want is to <span class="emphasis"><em>block</em></span> if the pool is empty and unblock when it becomes nonempty again. If you initialize a <code class="literal">Semaphore</code> to the pool size, <code class="literal">acquire</code> a permit before trying to fetch a resource from the pool, and <code class="literal">release</code> the permit after putting a resource back in the pool, <code class="literal">acquire</code> blocks until the pool becomes nonempty. This technique is used in the bounded buffer class in <a class="link" href="ch12.html" title="Chapter 12. Testing Concurrent Programs">Chapter 12</a>. (An easier way to construct a blocking object pool would be to use a <code class="literal">BlockingQueue</code> to hold the pooled resources.)</p>
<p>Similarly, you can use a <code class="literal">Semaphore</code> to turn any collection into a blocking bounded collection, as illustrated by <code class="literal">BoundedHashSet</code> in <a class="link" href="ch05s05.html#ch05list14" title="Example 5.14. Using Semaphore to Bound a Collection.">Listing 5.14</a>. The semaphore is initialized to the desired maximum size of the collection. The <code class="literal">add</code> operation acquires a permit before adding the item into the underlying collection. If the underlying <code class="literal">add</code> operation does not actually add anything, it releases the permit immediately. Similarly, a successful <code class="literal">remove</code> operation releases a permit, enabling more elements to be added. The underlying <code class="literal">Set</code> implementation knows nothing about the bound; this is handled by <code class="literal">BoundedHashSet</code>.</p>
</div>
<div class="section" title="Barriers"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lev2sec13"/>Barriers</h3></div></div></div>

<p>We have seen how latches can facilitate starting a group of related activities or waiting for a group of related activities to complete. Latches are single-use objects; once a latch enters the terminal state, it cannot be reset.</p>
<p><span class="emphasis"><em>Barriers</em></span> are similar to latches in that they block a group of threads until some event has occurred [CPJ 4.4.3]. The key difference is that with a barrier, all the threads must come together at a barrier point <span class="emphasis"><em>at the same time</em></span> in order to proceed. Latches are for waiting for <span class="emphasis"><em>events</em></span>; barriers are for waiting for <span class="emphasis"><em>other threads</em></span>. A barrier implements the protocol some families use to rendezvous during a day at the mall: “Everyone meet at McDonald’s at 6:00; once you get there, stay there until everyone shows up, and then we’ll figure out what we’re doing next.”</p>
<p><code class="literal">CyclicBarrier</code> allows a fixed number of parties to rendezvous repeatedly at a <span class="emphasis"><em>barrier point</em></span> and is useful in parallel iterative algorithms that break down a problem into a fixed number of independent subproblems. Threads call <code class="literal">await</code> when they reach the barrier point, and <code class="literal">await</code> blocks until <span class="emphasis"><em>all</em></span> the threads have reached the barrier point. If all threads meet at the barrier point, the barrier has been successfully passed, in which case all threads are released and the barrier is reset so it can be used again. If a call to <code class="literal">await</code> times out or a thread blocked in <code class="literal">await</code> is interrupted, then the barrier is considered <span class="emphasis"><em>broken</em></span> and all outstanding calls to <code class="literal">await</code> terminate with <code class="literal">BrokenBarrierException</code>. If the barrier is successfully passed, <code class="literal">await</code> returns a unique arrival index for each thread, which can be used to “elect” a leader that takes some special action in the next iteration. <code class="literal">CyclicBar</code> <a id="iddle2091" class="indexterm"/><a id="iddle4138" class="indexterm"/><a id="iddle4213" class="indexterm"/><a id="iddle1128" class="indexterm"/><a id="iddle1129" class="indexterm"/><a id="iddle1288" class="indexterm"/><a id="iddle1289" class="indexterm"/><a id="iddle1328" class="indexterm"/><a id="iddle1329" class="indexterm"/><a id="iddle1444" class="indexterm"/><a id="iddle1994" class="indexterm"/><a id="iddle2239" class="indexterm"/><a id="iddle2961" class="indexterm"/><a id="iddle2962" class="indexterm"/><a id="iddle3465" class="indexterm"/><a id="iddle3466" class="indexterm"/><a id="iddle3979" class="indexterm"/><a id="iddle3980" class="indexterm"/><a id="iddle4080" class="indexterm"/><a id="iddle4081" class="indexterm"/><a id="iddle4288" class="indexterm"/><a id="iddle4289" class="indexterm"/><a id="iddle4478" class="indexterm"/><a id="iddle4479" class="indexterm"/><a id="iddle4661" class="indexterm"/><a id="iddle4662" class="indexterm"/><code class="literal">rier</code> also lets you pass a <span class="emphasis"><em>barrier action</em></span> to the constructor; this is a <code class="literal">Runnable</code> that is executed (in one of the subtask threads) when the barrier is successfully passed but before the blocked threads are released.</p>
<div class="example"><a id="ch05list14"/><p class="title"><b>Example 5.14. Using <code class="literal">Semaphore</code> to Bound a Collection.</b></p><div class="example-contents">


<pre class="programlisting">public class BoundedHashSet&lt;T&gt; {
    private final Set&lt;T&gt; set;
    private final Semaphore sem;

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());
        sem = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        }
        finally {
            if (!wasAdded)
                sem.release();
        }
    }

    public boolean remove(Object o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
</pre>
</div></div><br class="example-break"/>
<p>Barriers are often used in simulations, where the work to calculate one step can be done in parallel but all the work associated with a given step must complete before advancing to the next step. For example, in <span class="emphasis"><em>n</em></span>-body particle simulations, each step calculates an update to the position of each particle based on the locations and other attributes of the other particles. Waiting on a barrier between each update ensures that all updates for step <span class="emphasis"><em>k</em></span> have completed before moving on to step <span class="emphasis"><em>k</em></span> + 1.</p>
<p><code class="literal">CellularAutomata</code> in <a class="link" href="ch05s06.html#ch05list15" title="Example 5.15. Coordinating Computation in a Cellular Automaton with CyclicBarrier.">Listing 5.15</a> demonstrates using a barrier to compute a cellular automata simulation, such as Conway’s Life game (<a class="link" href="bi01.html#biblio01_012" title="The fantastic combinations of John Conway’s new solitaire game ’Life’">Gardner, 1970</a>). When parallelizing a simulation, it is generally impractical to assign a separate thread to each element (in the case of Life, a cell); this would require too many threads, and the overhead of coordinating them would dwarf the computation. Instead, it makes sense to <span class="emphasis"><em>partition</em></span> the problem into a number of subparts, let each thread solve a subpart, and then merge the results. <code class="literal">CellularAutomata</code> partitions the board into <span class="emphasis"><em>N</em></span><sub><span class="emphasis"><em>cpu</em></span></sub> parts, where <span class="emphasis"><em>N</em></span><sub><span class="emphasis"><em>cpu</em></span></sub> is the number of CPUs available, and assigns each part to a thread. <sup>[<a id="ch05fn05" href="#ftn.ch05fn05" class="footnote">5</a>]</sup> At each step, the worker threads calculate new values for all the cells in their part of the board. When all worker threads have reached the barrier, the barrier action commits the new values to the data model. After the barrier action runs, the worker threads are released to compute the next step of the calculation, which includes consulting an <code class="literal">isDone</code> method to determine whether further iterations are required.</p>
<p>Another form of barrier is <code class="literal">Exchanger</code>, a two-party barrier in which the parties exchange data at the barrier point [CPJ 3.4.3]. Exchangers are useful when the parties perform asymmetric activities, for example when one thread fills a buffer with data and the other thread consumes the data from the buffer; these threads could use an <code class="literal">Exchanger</code> to meet and exchange a full buffer for an empty one. When two threads exchange objects via an <code class="literal">Exchanger</code>, the exchange constitutes a safe publication of both objects to the other party.</p>
<p>The timing of the exchange depends on the responsiveness requirements of the application. The simplest approach is that the filling task exchanges when the buffer is full, and the emptying task exchanges when the buffer is empty; this minimizes the number of exchanges but can delay processing of some data if the arrival rate of new data is unpredictable. Another approach would be that the filler exchanges when the buffer is full, but also when the buffer is partially filled and a certain amount of time has elapsed.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch05fn04" href="#ch05fn04" class="para">4</a>] </sup>The implementation has no actual permit objects, and <code class="literal">Semaphore</code> does not associate dispensed permits with threads, so a permit acquired in one thread can be released from another thread. You can think of <code class="literal">acquire</code> as consuming a permit and <code class="literal">release</code> as creating one; a <code class="literal">Semaphore</code> is not limited to the number of permits it was created with.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch05fn05" href="#ch05fn05" class="para">5</a>] </sup>For computational problems like this that do no I/O and access no shared data, <span class="emphasis"><em>Ncpu</em></span> or <span class="emphasis"><em>Ncpu</em></span> + 1 threads yield optimal throughput; more threads do not help, and may in fact degrade performance as the threads compete for CPU and memory resources.</p></div></div></div></body></html>
