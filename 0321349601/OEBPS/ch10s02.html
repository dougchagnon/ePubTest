<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Avoiding and Diagnosing Deadlocks</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Avoiding and Diagnosing Deadlocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lev1sec2"/>Avoiding and Diagnosing Deadlocks</h2></div></div></div>

<p>A program that never acquires more than one lock at a time cannot experience lock-ordering deadlock. Of course, this is not always practical, but if you can get away with it, it’s a lot less work. If you must acquire multiple locks, lock ordering must be a part of your design: try to minimize the number of potential locking interactions, and follow and document a lock-ordering protocol for locks that may be acquired together.</p>
<p>In programs that use fine-grained locking, audit your code for deadlock freedom using a two-part strategy: first, identify where multiple locks could be acquired (try to make this a small set), and then perform a global analysis of all such instances to ensure that lock ordering is consistent across your entire program. Using open calls wherever possible simplifies this analysis substantially. With no non-open calls, finding instances where multiple locks are acquired is fairly easy, either by code review or by automated bytecode or source code analysis.</p>
<div class="section" title="Timed Lock Attempts"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lev2sec6"/>Timed Lock Attempts</h3></div></div></div>

<p>Another technique for detecting and recovering from deadlocks is to use the timed <code class="literal">tryLock</code> feature of the explicit <code class="literal">Lock</code> classes (see <a class="link" href="ch13.html" title="Chapter 13. Explicit Locks">Chapter 13</a>) instead of intrinsic locking. Where intrinsic locks wait forever if they cannot acquire the lock, explicit locks let you specify a timeout after which <code class="literal">tryLock</code> returns failure. By using a timeout that is much longer than you expect acquiring the lock to take, you can regain control when something unexpected happens. (<a class="link" href="ch13.html#ch13list03" title="Example 13.3. Avoiding Lock-ordering Deadlock Using Trylock.">Listing 13.3</a> on page 280 shows an alternative implementation of <code class="literal">transferMoney</code> using the polled <code class="literal">tryLock</code> with retries for probabilistic deadlock avoidance.)</p>
<p>When a timed lock attempt fails, you do not necessarily know <span class="emphasis"><em>why</em></span>. Maybe there was a deadlock; maybe a thread erroneously entered an infinite loop while <a id="iddle1086" class="indexterm"/><a id="iddle1087" class="indexterm"/><a id="iddle1795" class="indexterm"/><a id="iddle1796" class="indexterm"/><a id="iddle1833" class="indexterm"/><a id="iddle3155" class="indexterm"/><a id="iddle4362" class="indexterm"/><a id="iddle4363" class="indexterm"/><a id="iddle4767" class="indexterm"/><a id="iddle4768" class="indexterm"/><a id="iddle4976" class="indexterm"/>holding that lock; or maybe some activity is just running a lot slower than you expected. Still, at least you have the opportunity to record that your attempt failed, log any useful information about what you were trying to do, and restart the computation somewhat more gracefully than killing the entire process.</p>
<p>Using timed lock acquisition to acquire multiple locks can be effective against deadlock even when timed locking is not used consistently throughout the program. If a lock acquisition times out, you can release the locks, back off and wait for a while, and try again, possibly clearing the deadlock condition and allowing the program to recover. (This technique works only when the two locks are acquired together; if multiple locks are acquired due to the nesting of method calls, you cannot just release the outer lock, even if you know you hold it.)</p>
</div>
<div class="section" title="Deadlock Analysis with Thread Dumps"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lev2sec7"/>Deadlock Analysis with Thread Dumps</h3></div></div></div>

<p>While preventing deadlocks is mostly your problem, the JVM can help identify them when they do happen using <span class="emphasis"><em>thread dumps</em></span>. A thread dump includes a stack trace for each running thread, similar to the stack trace that accompanies an exception. Thread dumps also include locking information, such as which locks are held by each thread, in which stack frame they were acquired, and which lock a blocked thread is waiting to acquire.<sup>[<a id="ch10fn04" href="#ftn.ch10fn04" class="footnote">4</a>]</sup> Before generating a thread dump, the JVM searches the is-waiting-for graph for cycles to find deadlocks. If it finds one, it includes deadlock information identifying which locks and threads are involved, and where in the program the offending lock acquisitions are.</p>
<p>To trigger a thread dump, you can send the JVM process a <code class="literal">SIGQUIT</code> signal (<code class="literal">kill -3</code>) on Unix platforms, or press the <code class="literal">Ctrl-\</code> key on Unix or <code class="literal">Ctrl-Break</code> on Windows platforms. Many IDEs can request a thread dump as well.</p>
<p>If you are using the explicit <code class="literal">Lock</code> classes instead of intrinsic locking, Java 5.0 has no support for associating <code class="literal">Lock</code> information with the thread dump; explicit <code class="literal">Lock</code>s do not show up at all in thread dumps. Java 6 does include thread dump support and deadlock detection with explicit <code class="literal">Lock</code>s, but the information on where <code class="literal">Lock</code>s are acquired is necessarily less precise than for intrinsic locks. Intrinsic locks are associated with the stack frame in which they were acquired; explicit <code class="literal">Lock</code>s are associated only with the acquiring thread.</p>
<p><a class="link" href="ch10s02.html#ch10list07" title="Example 10.7. Portion of Thread Dump After Deadlock.">Listing 10.7</a> shows portions of a thread dump taken from a production J2EE application. The failure that caused the deadlock involves three components—a J2EE application, a J2EE container, and a JDBC driver, each from different vendors. (The names have been changed to protect the guilty.) All three were commercial products that had been through extensive testing cycles; each had a bug that was harmless until they all interacted and caused a fatal server failure.</p>
<p>We’ve shown only the portion of the thread dump relevant to identifying the deadlock. The JVM has done a lot of work for us in diagnosing the deadlock—which locks are causing the problem, which threads are involved, which other locks they hold, and whether other threads are being indirectly inconvenienced. One thread holds the lock on the <code class="literal">MumbleDBConnection</code> and is waiting to acquire the lock on the <code class="literal">MumbleDBCallableStatement</code>; the other holds the lock on the <code class="literal">MumbleDBCallableStatement</code> and is waiting for the lock on the <code class="literal">MumbleDBConnection</code>.</p>
<div class="example"><a id="ch10list07"/><p class="title"><b>Example 10.7. Portion of Thread Dump After Deadlock.</b></p><div class="example-contents">

<pre class="programlisting">Found one Java-level deadlock:
=============================
"ApplicationServerThread":
  waiting to lock monitor 0x080f0cdc (a MumbleDBConnection),
  which is held by "ApplicationServerThread"
"ApplicationServerThread":
  waiting to lock monitor 0x080f0ed4 (a MumbleDBCallableStatement),
  which is held by "ApplicationServerThread"

Java stack information for the threads listed above:
"ApplicationServerThread":
        at MumbleDBConnection.remove_statement
        - waiting to lock &lt;0x650f7f30&gt; (a MumbleDBConnection)
        at MumbleDBStatement.close
        - locked &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement)
     ...

"ApplicationServerThread":
        at MumbleDBCallableStatement.sendBatch
        - waiting to lock &lt;0x6024ffb0&gt; (a MumbleDBCallableStatement)
        at MumbleDBConnection.commit
        - locked &lt;0x650f7f30&gt; (a MumbleDBConnection)
     ...
</pre>
</div></div><br class="example-break"/>
<p>The JDBC driver being used here clearly has a lock-ordering bug: different call chains through the JDBC driver acquire multiple locks in different orders. But this problem would not have manifested itself were it not for another bug: multiple threads were trying to use the same JDBC <code class="literal">Connection</code> at the same time. This was not how the application was supposed to work—the developers were surprised to see the same <code class="literal">Connection</code> used concurrently by two threads. There’s nothing in the JDBC specification that requires a <code class="literal">Connection</code> to be thread-safe, and it is common to confine use of a <code class="literal">Connection</code> to a single thread, as was intended here. This vendor tried to deliver a thread-safe JDBC driver, as evidenced by the synchronization on multiple JDBC objects within the driver code. Unfortunately, because the vendor did not take lock ordering into account, the driver was prone to deadlock, but it was only the interaction of the deadlock-prone driver and the incorrect <code class="literal">Connection</code> sharing by the application that disclosed the problem. Because neither bug was fatal in isolation, both persisted despite extensive testing.</p>
</div>
<div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch10fn04" href="#ch10fn04" class="para">4</a>] </sup>This information is useful for debugging even when you don’t have a deadlock; periodically triggering thread dumps lets you observe your program’s locking behavior.</p></div></div></div></body></html>
