<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Other Forms of Single-threaded Subsystems</title><link rel="stylesheet" href="styles/convert.css" type="text/css"/></head><body><div class="section" title="Other Forms of Single-threaded Subsystems"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lev1sec5"/>Other Forms of Single-threaded Subsystems</h2></div></div></div>

<p>Thread confinement is not restricted to GUIs: it can be used whenever a facility is implemented as a single-threaded subsystem. Sometimes thread confinement is forced on the developer for reasons that have nothing to do with avoiding synchronization or deadlock. For example, some native libraries require that all access to the library, even loading the library with <code class="literal">System.loadLibrary</code>, bemade from the same thread.</p>
<p>Borrowing from the approach taken by GUI frameworks, you can easily create a dedicated thread or single-threaded executor for accessing the native library, and provide a proxy object that intercepts calls to the thread-confined object and submits them as tasks to the dedicated thread. <code class="literal">Future</code> and <code class="literal">newSingleThreadExecutor</code> work together to make this easy; the proxy method can <code class="literal">submit</code> the task and immediately call <code class="literal">Future.get</code> to wait for the result. (If the class to be threadconfined implements an interface, you can automate the process of having each method submit a <code class="literal">Callable</code> to a background thread executor and waiting for the result using dynamic proxies.)</p>
</div></body></html>
